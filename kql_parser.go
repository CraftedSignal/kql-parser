// Code generated from KQLParser.g4 by ANTLR 4.13.2. DO NOT EDIT.

package kql // KQLParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type KQLParser struct {
	*antlr.BaseParser
}

var KQLParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func kqlparserParserInit() {
	staticData := &KQLParserParserStaticData
	staticData.LiteralNames = []string{
		"", "'where'", "'search'", "'find'", "'take'", "'limit'", "'sample'",
		"'sample-distinct'", "'distinct'", "'count'", "'getschema'", "'project'",
		"'project-away'", "'project-keep'", "'project-rename'", "'project-reorder'",
		"'extend'", "'parse'", "'parse-where'", "'parse-kv'", "'sort'", "'order'",
		"'top'", "'top-nested'", "'top-hitters'", "'summarize'", "'make-series'",
		"'make_list'", "'make_set'", "'join'", "'lookup'", "'union'", "'as'",
		"'mv-expand'", "'mv-apply'", "'evaluate'", "'invoke'", "'facet'", "'fork'",
		"'partition'", "'scan'", "'serialize'", "'range'", "'print'", "'render'",
		"'consume'", "'externaldata'", "'make-graph'", "'graph-match'", "'graph-shortest-paths'",
		"'graph-to-table'", "'let'", "'set'", "'alias'", "'declare'", "'pattern'",
		"'restrict'", "'access'", "'materialize'", "'kind'", "'hint.'", "'inner'",
		"'outer'", "'left'", "'right'", "'full'", "'leftsemi'", "'rightsemi'",
		"'leftanti'", "'rightanti'", "'leftouter'", "'rightouter'", "'fullouter'",
		"'anti'", "'semi'", "'innerunique'", "'and'", "'or'", "", "'between'",
		"'!between'", "'in'", "'!in'", "'in~'", "'!in~'", "'has_any'", "'has_all'",
		"'contains'", "'!contains'", "'contains_cs'", "'!contains_cs'", "'has'",
		"'!has'", "'has_cs'", "'!has_cs'", "'hasprefix'", "'!hasprefix'", "'hasprefix_cs'",
		"'!hasprefix_cs'", "'hassuffix'", "'!hassuffix'", "'hassuffix_cs'",
		"'!hassuffix_cs'", "'startswith'", "'!startswith'", "'startswith_cs'",
		"'!startswith_cs'", "'endswith'", "'!endswith'", "'endswith_cs'", "'!endswith_cs'",
		"", "'matches'", "'=='", "'='", "'!='", "'<'", "'>'", "'<='", "'>='",
		"'=~'", "'!~'", "'+'", "'-'", "'*'", "'/'", "'%'", "'..'", "'=>'", "'?'",
		"'?.'", "'|'", "';'", "':'", "','", "'.'", "'('", "')'", "'['", "']'",
		"'{'", "'}'", "'asc'", "'desc'", "'nulls'", "'first'", "'last'", "'by'",
		"'on'", "'with'", "'of'", "'to'", "'from'", "'step'", "'default'", "'typeof'",
		"'pack'", "'pack_all'", "'bag_pack'", "'view'", "'others'", "'$'", "'withsource'",
		"'isfuzzy'", "'bagexpansion'", "'with_itemindex'", "'with_match_id'",
		"'output'", "'datascope'", "'decodeblocks'", "'nodes'", "'edges'", "'datatable'",
		"'case'", "'iff'", "'iif'", "'toscalar'", "'pack_array'", "'true'",
		"'false'", "'null'", "", "", "", "", "", "'bool'", "'datetime'", "'decimal'",
		"'double'", "'dynamic'", "'guid'", "'int'", "'long'", "'real'", "'string'",
		"'timespan'",
	}
	staticData.SymbolicNames = []string{
		"", "WHERE", "SEARCH", "FIND", "TAKE", "LIMIT", "SAMPLE", "SAMPLE_DISTINCT",
		"DISTINCT", "COUNT", "GETSCHEMA", "PROJECT", "PROJECT_AWAY", "PROJECT_KEEP",
		"PROJECT_RENAME", "PROJECT_REORDER", "EXTEND", "PARSE", "PARSE_WHERE",
		"PARSE_KV", "SORT", "ORDER", "TOP", "TOP_NESTED", "TOP_HITTERS", "SUMMARIZE",
		"MAKE_SERIES", "MAKE_LIST", "MAKE_SET", "JOIN", "LOOKUP", "UNION", "AS",
		"MV_EXPAND", "MV_APPLY", "EVALUATE", "INVOKE", "FACET", "FORK", "PARTITION",
		"SCAN", "SERIALIZE", "RANGE", "PRINT", "RENDER", "CONSUME", "EXTERNALDATA",
		"MAKE_GRAPH", "GRAPH_MATCH", "GRAPH_SHORTEST_PATHS", "GRAPH_TO_TABLE",
		"LET", "SET", "ALIAS", "DECLARE", "PATTERN", "RESTRICT", "ACCESS", "MATERIALIZE",
		"KIND", "HINT_DOT", "INNER", "OUTER", "LEFT", "RIGHT", "FULL", "LEFTSEMI",
		"RIGHTSEMI", "LEFTANTI", "RIGHTANTI", "LEFTOUTER", "RIGHTOUTER", "FULLOUTER",
		"ANTI", "SEMI", "INNERUNIQUE", "AND", "OR", "NOT", "BETWEEN", "NOT_BETWEEN",
		"IN", "NOT_IN", "IN_CS", "NOT_IN_CS", "HAS_ANY", "HAS_ALL", "CONTAINS",
		"NOT_CONTAINS", "CONTAINS_CS", "NOT_CONTAINS_CS", "HAS", "NOT_HAS",
		"HAS_CS", "NOT_HAS_CS", "HASPREFIX", "NOT_HASPREFIX", "HASPREFIX_CS",
		"NOT_HASPREFIX_CS", "HASSUFFIX", "NOT_HASSUFFIX", "HASSUFFIX_CS", "NOT_HASSUFFIX_CS",
		"STARTSWITH", "NOT_STARTSWITH", "STARTSWITH_CS", "NOT_STARTSWITH_CS",
		"ENDSWITH", "NOT_ENDSWITH", "ENDSWITH_CS", "NOT_ENDSWITH_CS", "MATCHES_REGEX",
		"MATCHES", "EQ", "ASSIGN", "NEQ", "LT", "GT", "LTE", "GTE", "EQTILDE",
		"NEQTILDE", "PLUS", "MINUS", "STAR", "SLASH", "PERCENT", "DOTDOT", "ARROW",
		"QUESTION", "QUESTIONDOT", "PIPE", "SEMICOLON", "COLON", "COMMA", "DOT",
		"LPAREN", "RPAREN", "LBRACKET", "RBRACKET", "LBRACE", "RBRACE", "ASC",
		"DESC", "NULLS", "FIRST", "LAST", "BY", "ON", "WITH", "OF", "TO", "FROM",
		"STEP", "DEFAULT", "TYPEOF", "PACK", "PACK_ALL", "BAG_PACK", "VIEW",
		"OTHERS", "DOLLAR", "WITH_SOURCE", "IS_FUZZY", "BAG_EXPANSION", "WITH_ITEMINDEX",
		"WITH_MATCH_ID", "OUTPUT", "DATA_SCOPE", "DECODEBLOCKS", "NODES", "EDGES",
		"DATATABLE", "CASE", "IFF", "IIF", "TOSCALAR", "PACK_ARRAY", "TRUE",
		"FALSE", "NULL", "DATETIME_LITERAL", "TIMESPAN_LITERAL", "TIMESPAN_SHORT",
		"DYNAMIC_LITERAL", "GUID_LITERAL", "TYPE_BOOL", "TYPE_DATETIME", "TYPE_DECIMAL",
		"TYPE_DOUBLE", "TYPE_DYNAMIC", "TYPE_GUID", "TYPE_INT", "TYPE_LONG",
		"TYPE_REAL", "TYPE_STRING", "TYPE_TIMESPAN", "STRING_LITERAL", "VERBATIM_STRING",
		"MULTILINE_STRING", "HEX_NUMBER", "REAL_NUMBER", "LONG_NUMBER", "INT_NUMBER",
		"DECIMAL_NUMBER", "IDENTIFIER", "QUOTED_IDENTIFIER", "CLIENT_PARAMETER",
		"LINE_COMMENT", "BLOCK_COMMENT", "WS", "ERROR_CHAR",
	}
	staticData.RuleNames = []string{
		"query", "statement", "letStatement", "setStatement", "aliasStatement",
		"declareStatement", "patternStatement", "restrictStatement", "viewExpression",
		"patternDefinition", "patternParam", "tabularExpression", "tabularSource",
		"tableName", "databaseTableName", "materializeExpression", "tabularOperator",
		"whereOperator", "searchOperator", "searchKind", "tableList", "projectOperator",
		"projectAwayOperator", "projectKeepOperator", "projectRenameOperator",
		"projectReorderOperator", "projectItemList", "projectItem", "identifierOrWildcardList",
		"identifierOrWildcard", "renameList", "renameItem", "extendOperator",
		"extendItemList", "extendItem", "summarizeOperator", "summarizeHints",
		"aggregationList", "aggregationItem", "aggregationFunction", "groupByList",
		"groupByItem", "sortOperator", "sortList", "sortItem", "sortDirection",
		"nullsPosition", "topOperator", "topNestedOperator", "topNestedClause",
		"takeOperator", "distinctOperator", "distinctColumns", "countOperator",
		"joinOperator", "joinKind", "joinFlavor", "joinHints", "joinHint", "joinCondition",
		"joinAttribute", "unionOperator", "unionParameters", "unionParameter",
		"unionTables", "unionTable", "lookupOperator", "lookupKind", "lookupCondition",
		"parseOperator", "parseKind", "parsePattern", "parsePatternItem", "parseKvOperator",
		"kvPairList", "kvPair", "parseKvParameters", "parseKvParam", "mvExpandOperator",
		"mvExpandKind", "mvExpandParams", "mvExpandItemList", "mvExpandItem",
		"limitClause", "mvApplyOperator", "mvApplyItemList", "mvApplyItem",
		"mvApplyOnClause", "evaluateOperator", "evaluateHints", "facetOperator",
		"forkOperator", "forkBranch", "partitionOperator", "partitionHints",
		"scanOperator", "scanParams", "scanDeclare", "scanDeclareItem", "scanStepList",
		"scanStep", "scanAction", "serializeOperator", "sampleOperator", "sampleDistinctOperator",
		"makeSeriesOperator", "makeSeriesItemList", "makeSeriesItem", "makeSeriesOnClause",
		"makeSeriesParams", "findOperator", "findParams", "getschemaOperator",
		"renderOperator", "renderProperties", "renderProperty", "consumeOperator",
		"invokeOperator", "asOperator", "graphOperator", "makeGraphOperator",
		"graphMatchOperator", "graphPattern", "graphPatternElement", "graphEdge",
		"graphShortestPathsOperator", "graphToTableOperator", "graphToTableParams",
		"datatable", "datatableSchema", "datatableColumn", "datatableRows",
		"externalData", "externalDataUri", "externalDataOptions", "externalDataOption",
		"printArgList", "printArg", "expression", "orExpression", "andExpression",
		"notExpression", "comparisonExpression", "comparisonOperator", "stringOperator",
		"additiveExpression", "multiplicativeExpression", "unaryExpression",
		"postfixExpression", "postfixOperator", "primaryExpression", "functionCall",
		"builtinFunction", "argumentList", "argument", "caseExpression", "caseBranch",
		"iffExpression", "toScalarExpression", "arrayExpression", "objectExpression",
		"objectPropertyList", "objectProperty", "functionParameters", "functionParameter",
		"typeSpecifier", "literal", "booleanLiteral", "identifier", "identifierList",
		"expressionList",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 211, 1850, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 1, 0, 5, 0,
		344, 8, 0, 10, 0, 12, 0, 347, 9, 0, 1, 0, 3, 0, 350, 8, 0, 1, 0, 1, 0,
		1, 1, 1, 1, 3, 1, 356, 8, 1, 1, 1, 1, 1, 3, 1, 360, 8, 1, 1, 1, 1, 1, 3,
		1, 364, 8, 1, 1, 1, 1, 1, 3, 1, 368, 8, 1, 1, 1, 1, 1, 3, 1, 372, 8, 1,
		1, 1, 1, 1, 3, 1, 376, 8, 1, 3, 1, 378, 8, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1,
		2, 3, 2, 397, 8, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1,
		2, 1, 2, 3, 2, 409, 8, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1,
		4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1,
		5, 1, 5, 3, 5, 432, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1,
		7, 1, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 9, 1,
		9, 1, 9, 1, 9, 5, 9, 456, 8, 9, 10, 9, 12, 9, 459, 9, 9, 1, 9, 1, 9, 1,
		10, 1, 10, 1, 10, 3, 10, 466, 8, 10, 1, 11, 1, 11, 1, 11, 5, 11, 471, 8,
		11, 10, 11, 12, 11, 474, 9, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12,
		1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 12, 1, 12, 1, 12, 3, 12, 496, 8, 12, 1, 13, 1, 13, 1, 13, 3, 13,
		501, 8, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 3, 14, 513, 8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16,
		1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 558, 8, 16, 1, 17, 1, 17,
		1, 17, 1, 18, 1, 18, 3, 18, 565, 8, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1,
		18, 3, 18, 572, 8, 18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 20,
		1, 20, 1, 20, 5, 20, 583, 8, 20, 10, 20, 12, 20, 586, 9, 20, 1, 21, 1,
		21, 1, 21, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24,
		1, 25, 1, 25, 1, 25, 3, 25, 603, 8, 25, 1, 26, 1, 26, 1, 26, 5, 26, 608,
		8, 26, 10, 26, 12, 26, 611, 9, 26, 1, 27, 1, 27, 1, 27, 3, 27, 616, 8,
		27, 1, 27, 1, 27, 1, 27, 1, 27, 3, 27, 622, 8, 27, 1, 28, 1, 28, 1, 28,
		5, 28, 627, 8, 28, 10, 28, 12, 28, 630, 9, 28, 1, 29, 1, 29, 1, 29, 1,
		29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 643, 8, 29,
		1, 30, 1, 30, 1, 30, 5, 30, 648, 8, 30, 10, 30, 12, 30, 651, 9, 30, 1,
		31, 1, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 5, 33,
		663, 8, 33, 10, 33, 12, 33, 666, 9, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1,
		34, 1, 34, 1, 34, 3, 34, 675, 8, 34, 3, 34, 677, 8, 34, 1, 35, 1, 35, 3,
		35, 681, 8, 35, 1, 35, 1, 35, 1, 35, 3, 35, 686, 8, 35, 1, 36, 1, 36, 1,
		36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 5, 37, 696, 8, 37, 10, 37, 12, 37,
		699, 9, 37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 708,
		8, 38, 3, 38, 710, 8, 38, 1, 39, 1, 39, 3, 39, 714, 8, 39, 1, 40, 1, 40,
		1, 40, 5, 40, 719, 8, 40, 10, 40, 12, 40, 722, 9, 40, 1, 41, 1, 41, 1,
		41, 3, 41, 727, 8, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 733, 8, 41, 1,
		42, 1, 42, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 5, 43, 742, 8, 43, 10, 43,
		12, 43, 745, 9, 43, 1, 44, 1, 44, 3, 44, 749, 8, 44, 1, 44, 3, 44, 752,
		8, 44, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 760, 8, 46, 1,
		47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48, 5, 48, 771,
		8, 48, 10, 48, 12, 48, 774, 9, 48, 1, 49, 1, 49, 3, 49, 778, 8, 49, 1,
		49, 1, 49, 1, 49, 1, 49, 3, 49, 784, 8, 49, 1, 49, 1, 49, 1, 49, 1, 49,
		3, 49, 790, 8, 49, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 3, 51, 797, 8, 51,
		1, 52, 1, 52, 3, 52, 801, 8, 52, 1, 53, 1, 53, 1, 54, 1, 54, 3, 54, 807,
		8, 54, 1, 54, 3, 54, 810, 8, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1,
		54, 1, 54, 1, 54, 3, 54, 820, 8, 54, 1, 54, 3, 54, 823, 8, 54, 1, 54, 1,
		54, 1, 54, 1, 54, 3, 54, 829, 8, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56,
		1, 56, 1, 57, 4, 57, 838, 8, 57, 11, 57, 12, 57, 839, 1, 58, 1, 58, 1,
		58, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 5, 59, 850, 8, 59, 10, 59, 12, 59,
		853, 9, 59, 1, 59, 3, 59, 856, 8, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60,
		1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 869, 8, 60, 1, 61, 1,
		61, 3, 61, 873, 8, 61, 1, 61, 1, 61, 1, 62, 4, 62, 878, 8, 62, 11, 62,
		12, 62, 879, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1,
		63, 3, 63, 891, 8, 63, 1, 64, 1, 64, 1, 64, 5, 64, 896, 8, 64, 10, 64,
		12, 64, 899, 9, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 906, 8, 65,
		1, 66, 1, 66, 3, 66, 910, 8, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1,
		66, 1, 66, 1, 66, 3, 66, 920, 8, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66,
		926, 8, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 68, 1, 68, 1, 69, 1, 69, 3,
		69, 936, 8, 69, 1, 69, 1, 69, 3, 69, 940, 8, 69, 1, 69, 1, 69, 1, 69, 1,
		69, 3, 69, 946, 8, 69, 1, 69, 1, 69, 3, 69, 950, 8, 69, 1, 69, 1, 69, 3,
		69, 954, 8, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 71, 4, 71, 961, 8, 71, 11,
		71, 12, 71, 962, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 1, 72, 3, 72, 971,
		8, 72, 3, 72, 973, 8, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 3, 73, 982, 8, 73, 1, 74, 1, 74, 1, 74, 5, 74, 987, 8, 74, 10, 74,
		12, 74, 990, 9, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 76, 1,
		76, 1, 76, 5, 76, 1001, 8, 76, 10, 76, 12, 76, 1004, 9, 76, 1, 76, 1, 76,
		1, 77, 1, 77, 1, 77, 1, 77, 1, 78, 1, 78, 3, 78, 1014, 8, 78, 1, 78, 3,
		78, 1017, 8, 78, 1, 78, 1, 78, 3, 78, 1021, 8, 78, 1, 79, 1, 79, 1, 79,
		1, 79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 1033, 8, 80, 1,
		81, 1, 81, 1, 81, 5, 81, 1038, 8, 81, 10, 81, 12, 81, 1041, 9, 81, 1, 82,
		1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1050, 8, 82, 1, 82, 1,
		82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1061, 8, 82,
		3, 82, 1063, 8, 82, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 3, 84, 1071,
		8, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 5, 85, 1080, 8,
		85, 10, 85, 12, 85, 1083, 9, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1,
		86, 1, 86, 3, 86, 1092, 8, 86, 1, 86, 1, 86, 3, 86, 1096, 8, 86, 1, 86,
		1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 3, 86, 1107, 8,
		86, 3, 86, 1109, 8, 86, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 3, 88, 1116,
		8, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 90, 1, 90, 1,
		90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 3, 90, 1133, 8, 90, 1, 91, 1, 91,
		4, 91, 1137, 8, 91, 11, 91, 12, 91, 1138, 1, 92, 1, 92, 1, 92, 1, 92, 1,
		93, 1, 93, 3, 93, 1147, 8, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93, 1, 93,
		1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 95, 1, 95, 3, 95, 1162, 8, 95, 1,
		95, 3, 95, 1165, 8, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 96, 1, 96,
		1, 96, 1, 96, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 5, 97, 1181, 8, 97, 10,
		97, 12, 97, 1184, 9, 97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98,
		3, 98, 1193, 8, 98, 1, 99, 1, 99, 1, 99, 5, 99, 1198, 8, 99, 10, 99, 12,
		99, 1201, 9, 99, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 3, 100, 1208,
		8, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 4, 100, 1215, 8, 100, 11,
		100, 12, 100, 1216, 1, 100, 1, 100, 1, 101, 1, 101, 1, 101, 1, 101, 3,
		101, 1225, 8, 101, 1, 102, 1, 102, 3, 102, 1229, 8, 102, 1, 103, 1, 103,
		1, 103, 1, 104, 1, 104, 1, 104, 1, 104, 1, 104, 1, 105, 1, 105, 1, 105,
		1, 105, 3, 105, 1243, 8, 105, 1, 106, 1, 106, 1, 106, 5, 106, 1248, 8,
		106, 10, 106, 12, 106, 1251, 9, 106, 1, 107, 3, 107, 1254, 8, 107, 1, 107,
		3, 107, 1257, 8, 107, 1, 107, 1, 107, 1, 107, 1, 107, 3, 107, 1263, 8,
		107, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 1272,
		8, 108, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 1278, 8, 108, 1, 109, 1,
		109, 1, 109, 1, 109, 1, 110, 1, 110, 3, 110, 1286, 8, 110, 1, 110, 1, 110,
		1, 110, 1, 110, 1, 110, 3, 110, 1293, 8, 110, 1, 110, 1, 110, 1, 110, 1,
		110, 3, 110, 1299, 8, 110, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111,
		3, 111, 1307, 8, 111, 1, 112, 1, 112, 1, 113, 1, 113, 1, 113, 3, 113, 1314,
		8, 113, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 5, 114, 1321, 8, 114, 10,
		114, 12, 114, 1324, 9, 114, 1, 114, 1, 114, 1, 115, 1, 115, 1, 115, 1,
		115, 1, 116, 1, 116, 1, 116, 1, 116, 3, 116, 1336, 8, 116, 1, 117, 1, 117,
		1, 117, 1, 118, 1, 118, 1, 118, 1, 119, 1, 119, 1, 119, 1, 119, 3, 119,
		1348, 8, 119, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1,
		120, 1, 120, 1, 121, 1, 121, 1, 121, 1, 121, 3, 121, 1363, 8, 121, 1, 121,
		1, 121, 3, 121, 1367, 8, 121, 1, 122, 4, 122, 1370, 8, 122, 11, 122, 12,
		122, 1371, 1, 123, 1, 123, 1, 123, 1, 123, 3, 123, 1378, 8, 123, 1, 123,
		1, 123, 3, 123, 1382, 8, 123, 1, 124, 1, 124, 1, 124, 3, 124, 1387, 8,
		124, 1, 124, 1, 124, 3, 124, 1391, 8, 124, 1, 124, 1, 124, 1, 124, 1, 124,
		1, 124, 1, 124, 1, 124, 3, 124, 1400, 8, 124, 1, 124, 1, 124, 3, 124, 1404,
		8, 124, 1, 124, 1, 124, 1, 124, 3, 124, 1409, 8, 124, 1, 125, 1, 125, 1,
		125, 1, 125, 3, 125, 1415, 8, 125, 1, 126, 1, 126, 1, 126, 1, 127, 1, 127,
		1, 127, 3, 127, 1423, 8, 127, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1,
		128, 1, 128, 1, 128, 1, 129, 1, 129, 1, 129, 5, 129, 1436, 8, 129, 10,
		129, 12, 129, 1439, 9, 129, 1, 130, 1, 130, 1, 130, 1, 130, 1, 131, 1,
		131, 1, 131, 5, 131, 1448, 8, 131, 10, 131, 12, 131, 1451, 9, 131, 3, 131,
		1453, 8, 131, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1,
		132, 5, 132, 1463, 8, 132, 10, 132, 12, 132, 1466, 9, 132, 1, 132, 1, 132,
		3, 132, 1470, 8, 132, 1, 133, 1, 133, 1, 134, 1, 134, 1, 134, 1, 134, 1,
		134, 5, 134, 1479, 8, 134, 10, 134, 12, 134, 1482, 9, 134, 1, 134, 1, 134,
		1, 135, 1, 135, 1, 135, 1, 135, 1, 136, 1, 136, 1, 136, 5, 136, 1493, 8,
		136, 10, 136, 12, 136, 1496, 9, 136, 1, 137, 1, 137, 1, 137, 1, 137, 1,
		137, 3, 137, 1503, 8, 137, 1, 138, 1, 138, 1, 139, 1, 139, 1, 139, 5, 139,
		1510, 8, 139, 10, 139, 12, 139, 1513, 9, 139, 1, 140, 1, 140, 1, 140, 5,
		140, 1518, 8, 140, 10, 140, 12, 140, 1521, 9, 140, 1, 141, 1, 141, 1, 141,
		3, 141, 1526, 8, 141, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1,
		142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1,
		142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1,
		142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1,
		142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1,
		142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1,
		142, 1, 142, 3, 142, 1581, 8, 142, 1, 143, 1, 143, 1, 144, 1, 144, 1, 145,
		1, 145, 1, 145, 5, 145, 1590, 8, 145, 10, 145, 12, 145, 1593, 9, 145, 1,
		146, 1, 146, 1, 146, 5, 146, 1598, 8, 146, 10, 146, 12, 146, 1601, 9, 146,
		1, 147, 1, 147, 1, 147, 1, 147, 1, 147, 3, 147, 1608, 8, 147, 1, 148, 1,
		148, 5, 148, 1612, 8, 148, 10, 148, 12, 148, 1615, 9, 148, 1, 149, 1, 149,
		1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 3, 149,
		1627, 8, 149, 1, 150, 1, 150, 1, 150, 1, 150, 1, 150, 1, 150, 1, 150, 1,
		150, 1, 150, 1, 150, 1, 150, 1, 150, 1, 150, 1, 150, 1, 150, 1, 150, 1,
		150, 1, 150, 1, 150, 3, 150, 1648, 8, 150, 1, 151, 1, 151, 1, 151, 3, 151,
		1653, 8, 151, 1, 151, 1, 151, 1, 151, 3, 151, 1658, 8, 151, 1, 152, 1,
		152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 1,
		152, 1, 152, 1, 152, 3, 152, 1673, 8, 152, 1, 152, 1, 152, 1, 152, 1, 152,
		1, 152, 1, 152, 3, 152, 1681, 8, 152, 1, 153, 1, 153, 1, 153, 5, 153, 1686,
		8, 153, 10, 153, 12, 153, 1689, 9, 153, 1, 154, 1, 154, 1, 154, 1, 154,
		1, 154, 1, 154, 3, 154, 1697, 8, 154, 1, 155, 1, 155, 1, 155, 1, 155, 1,
		155, 5, 155, 1704, 8, 155, 10, 155, 12, 155, 1707, 9, 155, 1, 155, 1, 155,
		3, 155, 1711, 8, 155, 1, 155, 1, 155, 1, 156, 1, 156, 1, 156, 1, 156, 1,
		157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1,
		157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 1, 157, 3,
		157, 1737, 8, 157, 1, 158, 1, 158, 1, 158, 1, 158, 1, 158, 1, 159, 1, 159,
		1, 159, 3, 159, 1747, 8, 159, 1, 159, 1, 159, 1, 159, 3, 159, 1752, 8,
		159, 1, 159, 3, 159, 1755, 8, 159, 1, 160, 1, 160, 3, 160, 1759, 8, 160,
		1, 160, 1, 160, 1, 161, 1, 161, 1, 161, 5, 161, 1766, 8, 161, 10, 161,
		12, 161, 1769, 9, 161, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162,
		1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 3, 162, 1782, 8, 162, 1, 163, 1,
		163, 1, 163, 5, 163, 1787, 8, 163, 10, 163, 12, 163, 1790, 9, 163, 1, 164,
		1, 164, 1, 164, 1, 164, 1, 164, 3, 164, 1797, 8, 164, 1, 165, 1, 165, 1,
		165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1, 165, 1,
		165, 3, 165, 1811, 8, 165, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166,
		1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166,
		3, 166, 1828, 8, 166, 1, 167, 1, 167, 1, 168, 1, 168, 1, 169, 1, 169, 1,
		169, 5, 169, 1837, 8, 169, 10, 169, 12, 169, 1840, 9, 169, 1, 170, 1, 170,
		1, 170, 5, 170, 1845, 8, 170, 10, 170, 12, 170, 1848, 9, 170, 1, 170, 0,
		0, 171, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32,
		34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68,
		70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104,
		106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134,
		136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164,
		166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194,
		196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224,
		226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254,
		256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284,
		286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314,
		316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 0, 13,
		1, 0, 113, 114, 1, 0, 142, 143, 1, 0, 20, 21, 1, 0, 4, 5, 1, 0, 61, 75,
		1, 0, 170, 171, 1, 0, 197, 198, 2, 0, 113, 113, 115, 121, 1, 0, 87, 112,
		1, 0, 122, 123, 1, 0, 124, 126, 1, 0, 178, 179, 19, 0, 1, 2, 4, 4, 8, 9,
		11, 11, 16, 17, 20, 20, 22, 22, 25, 25, 29, 32, 35, 35, 42, 44, 51, 52,
		59, 59, 61, 64, 142, 143, 147, 154, 178, 179, 186, 196, 205, 205, 1956,
		0, 345, 1, 0, 0, 0, 2, 377, 1, 0, 0, 0, 4, 408, 1, 0, 0, 0, 6, 410, 1,
		0, 0, 0, 8, 415, 1, 0, 0, 0, 10, 431, 1, 0, 0, 0, 12, 433, 1, 0, 0, 0,
		14, 437, 1, 0, 0, 0, 16, 444, 1, 0, 0, 0, 18, 451, 1, 0, 0, 0, 20, 462,
		1, 0, 0, 0, 22, 467, 1, 0, 0, 0, 24, 495, 1, 0, 0, 0, 26, 500, 1, 0, 0,
		0, 28, 512, 1, 0, 0, 0, 30, 514, 1, 0, 0, 0, 32, 557, 1, 0, 0, 0, 34, 559,
		1, 0, 0, 0, 36, 562, 1, 0, 0, 0, 38, 575, 1, 0, 0, 0, 40, 579, 1, 0, 0,
		0, 42, 587, 1, 0, 0, 0, 44, 590, 1, 0, 0, 0, 46, 593, 1, 0, 0, 0, 48, 596,
		1, 0, 0, 0, 50, 599, 1, 0, 0, 0, 52, 604, 1, 0, 0, 0, 54, 621, 1, 0, 0,
		0, 56, 623, 1, 0, 0, 0, 58, 642, 1, 0, 0, 0, 60, 644, 1, 0, 0, 0, 62, 652,
		1, 0, 0, 0, 64, 656, 1, 0, 0, 0, 66, 659, 1, 0, 0, 0, 68, 676, 1, 0, 0,
		0, 70, 678, 1, 0, 0, 0, 72, 687, 1, 0, 0, 0, 74, 692, 1, 0, 0, 0, 76, 709,
		1, 0, 0, 0, 78, 713, 1, 0, 0, 0, 80, 715, 1, 0, 0, 0, 82, 732, 1, 0, 0,
		0, 84, 734, 1, 0, 0, 0, 86, 738, 1, 0, 0, 0, 88, 746, 1, 0, 0, 0, 90, 753,
		1, 0, 0, 0, 92, 759, 1, 0, 0, 0, 94, 761, 1, 0, 0, 0, 96, 766, 1, 0, 0,
		0, 98, 777, 1, 0, 0, 0, 100, 791, 1, 0, 0, 0, 102, 794, 1, 0, 0, 0, 104,
		800, 1, 0, 0, 0, 106, 802, 1, 0, 0, 0, 108, 828, 1, 0, 0, 0, 110, 830,
		1, 0, 0, 0, 112, 834, 1, 0, 0, 0, 114, 837, 1, 0, 0, 0, 116, 841, 1, 0,
		0, 0, 118, 855, 1, 0, 0, 0, 120, 868, 1, 0, 0, 0, 122, 870, 1, 0, 0, 0,
		124, 877, 1, 0, 0, 0, 126, 890, 1, 0, 0, 0, 128, 892, 1, 0, 0, 0, 130,
		905, 1, 0, 0, 0, 132, 925, 1, 0, 0, 0, 134, 927, 1, 0, 0, 0, 136, 931,
		1, 0, 0, 0, 138, 953, 1, 0, 0, 0, 140, 955, 1, 0, 0, 0, 142, 960, 1, 0,
		0, 0, 144, 972, 1, 0, 0, 0, 146, 974, 1, 0, 0, 0, 148, 983, 1, 0, 0, 0,
		150, 991, 1, 0, 0, 0, 152, 995, 1, 0, 0, 0, 154, 1007, 1, 0, 0, 0, 156,
		1011, 1, 0, 0, 0, 158, 1022, 1, 0, 0, 0, 160, 1032, 1, 0, 0, 0, 162, 1034,
		1, 0, 0, 0, 164, 1062, 1, 0, 0, 0, 166, 1064, 1, 0, 0, 0, 168, 1067, 1,
		0, 0, 0, 170, 1076, 1, 0, 0, 0, 172, 1108, 1, 0, 0, 0, 174, 1110, 1, 0,
		0, 0, 176, 1113, 1, 0, 0, 0, 178, 1119, 1, 0, 0, 0, 180, 1124, 1, 0, 0,
		0, 182, 1134, 1, 0, 0, 0, 184, 1140, 1, 0, 0, 0, 186, 1144, 1, 0, 0, 0,
		188, 1154, 1, 0, 0, 0, 190, 1159, 1, 0, 0, 0, 192, 1171, 1, 0, 0, 0, 194,
		1175, 1, 0, 0, 0, 196, 1187, 1, 0, 0, 0, 198, 1194, 1, 0, 0, 0, 200, 1202,
		1, 0, 0, 0, 202, 1220, 1, 0, 0, 0, 204, 1226, 1, 0, 0, 0, 206, 1230, 1,
		0, 0, 0, 208, 1233, 1, 0, 0, 0, 210, 1238, 1, 0, 0, 0, 212, 1244, 1, 0,
		0, 0, 214, 1253, 1, 0, 0, 0, 216, 1264, 1, 0, 0, 0, 218, 1279, 1, 0, 0,
		0, 220, 1283, 1, 0, 0, 0, 222, 1306, 1, 0, 0, 0, 224, 1308, 1, 0, 0, 0,
		226, 1310, 1, 0, 0, 0, 228, 1315, 1, 0, 0, 0, 230, 1327, 1, 0, 0, 0, 232,
		1331, 1, 0, 0, 0, 234, 1337, 1, 0, 0, 0, 236, 1340, 1, 0, 0, 0, 238, 1347,
		1, 0, 0, 0, 240, 1349, 1, 0, 0, 0, 242, 1358, 1, 0, 0, 0, 244, 1369, 1,
		0, 0, 0, 246, 1373, 1, 0, 0, 0, 248, 1408, 1, 0, 0, 0, 250, 1410, 1, 0,
		0, 0, 252, 1416, 1, 0, 0, 0, 254, 1419, 1, 0, 0, 0, 256, 1424, 1, 0, 0,
		0, 258, 1432, 1, 0, 0, 0, 260, 1440, 1, 0, 0, 0, 262, 1452, 1, 0, 0, 0,
		264, 1454, 1, 0, 0, 0, 266, 1471, 1, 0, 0, 0, 268, 1473, 1, 0, 0, 0, 270,
		1485, 1, 0, 0, 0, 272, 1489, 1, 0, 0, 0, 274, 1502, 1, 0, 0, 0, 276, 1504,
		1, 0, 0, 0, 278, 1506, 1, 0, 0, 0, 280, 1514, 1, 0, 0, 0, 282, 1525, 1,
		0, 0, 0, 284, 1580, 1, 0, 0, 0, 286, 1582, 1, 0, 0, 0, 288, 1584, 1, 0,
		0, 0, 290, 1586, 1, 0, 0, 0, 292, 1594, 1, 0, 0, 0, 294, 1607, 1, 0, 0,
		0, 296, 1609, 1, 0, 0, 0, 298, 1626, 1, 0, 0, 0, 300, 1647, 1, 0, 0, 0,
		302, 1657, 1, 0, 0, 0, 304, 1680, 1, 0, 0, 0, 306, 1682, 1, 0, 0, 0, 308,
		1696, 1, 0, 0, 0, 310, 1698, 1, 0, 0, 0, 312, 1714, 1, 0, 0, 0, 314, 1736,
		1, 0, 0, 0, 316, 1738, 1, 0, 0, 0, 318, 1754, 1, 0, 0, 0, 320, 1756, 1,
		0, 0, 0, 322, 1762, 1, 0, 0, 0, 324, 1781, 1, 0, 0, 0, 326, 1783, 1, 0,
		0, 0, 328, 1791, 1, 0, 0, 0, 330, 1810, 1, 0, 0, 0, 332, 1827, 1, 0, 0,
		0, 334, 1829, 1, 0, 0, 0, 336, 1831, 1, 0, 0, 0, 338, 1833, 1, 0, 0, 0,
		340, 1841, 1, 0, 0, 0, 342, 344, 3, 2, 1, 0, 343, 342, 1, 0, 0, 0, 344,
		347, 1, 0, 0, 0, 345, 343, 1, 0, 0, 0, 345, 346, 1, 0, 0, 0, 346, 349,
		1, 0, 0, 0, 347, 345, 1, 0, 0, 0, 348, 350, 3, 22, 11, 0, 349, 348, 1,
		0, 0, 0, 349, 350, 1, 0, 0, 0, 350, 351, 1, 0, 0, 0, 351, 352, 5, 0, 0,
		1, 352, 1, 1, 0, 0, 0, 353, 355, 3, 4, 2, 0, 354, 356, 5, 132, 0, 0, 355,
		354, 1, 0, 0, 0, 355, 356, 1, 0, 0, 0, 356, 378, 1, 0, 0, 0, 357, 359,
		3, 6, 3, 0, 358, 360, 5, 132, 0, 0, 359, 358, 1, 0, 0, 0, 359, 360, 1,
		0, 0, 0, 360, 378, 1, 0, 0, 0, 361, 363, 3, 8, 4, 0, 362, 364, 5, 132,
		0, 0, 363, 362, 1, 0, 0, 0, 363, 364, 1, 0, 0, 0, 364, 378, 1, 0, 0, 0,
		365, 367, 3, 10, 5, 0, 366, 368, 5, 132, 0, 0, 367, 366, 1, 0, 0, 0, 367,
		368, 1, 0, 0, 0, 368, 378, 1, 0, 0, 0, 369, 371, 3, 12, 6, 0, 370, 372,
		5, 132, 0, 0, 371, 370, 1, 0, 0, 0, 371, 372, 1, 0, 0, 0, 372, 378, 1,
		0, 0, 0, 373, 375, 3, 14, 7, 0, 374, 376, 5, 132, 0, 0, 375, 374, 1, 0,
		0, 0, 375, 376, 1, 0, 0, 0, 376, 378, 1, 0, 0, 0, 377, 353, 1, 0, 0, 0,
		377, 357, 1, 0, 0, 0, 377, 361, 1, 0, 0, 0, 377, 365, 1, 0, 0, 0, 377,
		369, 1, 0, 0, 0, 377, 373, 1, 0, 0, 0, 378, 3, 1, 0, 0, 0, 379, 380, 5,
		51, 0, 0, 380, 381, 3, 336, 168, 0, 381, 382, 5, 114, 0, 0, 382, 383, 3,
		276, 138, 0, 383, 409, 1, 0, 0, 0, 384, 385, 5, 51, 0, 0, 385, 386, 3,
		336, 168, 0, 386, 387, 5, 114, 0, 0, 387, 388, 5, 140, 0, 0, 388, 389,
		3, 22, 11, 0, 389, 390, 5, 141, 0, 0, 390, 409, 1, 0, 0, 0, 391, 392, 5,
		51, 0, 0, 392, 393, 3, 336, 168, 0, 393, 394, 5, 114, 0, 0, 394, 396, 5,
		136, 0, 0, 395, 397, 3, 326, 163, 0, 396, 395, 1, 0, 0, 0, 396, 397, 1,
		0, 0, 0, 397, 398, 1, 0, 0, 0, 398, 399, 5, 137, 0, 0, 399, 400, 5, 140,
		0, 0, 400, 401, 3, 22, 11, 0, 401, 402, 5, 141, 0, 0, 402, 409, 1, 0, 0,
		0, 403, 404, 5, 51, 0, 0, 404, 405, 3, 336, 168, 0, 405, 406, 5, 114, 0,
		0, 406, 407, 3, 16, 8, 0, 407, 409, 1, 0, 0, 0, 408, 379, 1, 0, 0, 0, 408,
		384, 1, 0, 0, 0, 408, 391, 1, 0, 0, 0, 408, 403, 1, 0, 0, 0, 409, 5, 1,
		0, 0, 0, 410, 411, 5, 52, 0, 0, 411, 412, 3, 336, 168, 0, 412, 413, 7,
		0, 0, 0, 413, 414, 3, 276, 138, 0, 414, 7, 1, 0, 0, 0, 415, 416, 5, 53,
		0, 0, 416, 417, 3, 336, 168, 0, 417, 418, 5, 114, 0, 0, 418, 419, 3, 276,
		138, 0, 419, 9, 1, 0, 0, 0, 420, 421, 5, 54, 0, 0, 421, 422, 5, 55, 0,
		0, 422, 423, 3, 336, 168, 0, 423, 424, 5, 114, 0, 0, 424, 425, 3, 18, 9,
		0, 425, 432, 1, 0, 0, 0, 426, 427, 5, 54, 0, 0, 427, 428, 3, 336, 168,
		0, 428, 429, 5, 133, 0, 0, 429, 430, 3, 330, 165, 0, 430, 432, 1, 0, 0,
		0, 431, 420, 1, 0, 0, 0, 431, 426, 1, 0, 0, 0, 432, 11, 1, 0, 0, 0, 433,
		434, 5, 55, 0, 0, 434, 435, 3, 336, 168, 0, 435, 436, 3, 18, 9, 0, 436,
		13, 1, 0, 0, 0, 437, 438, 5, 56, 0, 0, 438, 439, 5, 57, 0, 0, 439, 440,
		5, 151, 0, 0, 440, 441, 5, 136, 0, 0, 441, 442, 3, 338, 169, 0, 442, 443,
		5, 137, 0, 0, 443, 15, 1, 0, 0, 0, 444, 445, 5, 159, 0, 0, 445, 446, 5,
		136, 0, 0, 446, 447, 5, 137, 0, 0, 447, 448, 5, 140, 0, 0, 448, 449, 3,
		22, 11, 0, 449, 450, 5, 141, 0, 0, 450, 17, 1, 0, 0, 0, 451, 452, 5, 136,
		0, 0, 452, 457, 3, 20, 10, 0, 453, 454, 5, 134, 0, 0, 454, 456, 3, 20,
		10, 0, 455, 453, 1, 0, 0, 0, 456, 459, 1, 0, 0, 0, 457, 455, 1, 0, 0, 0,
		457, 458, 1, 0, 0, 0, 458, 460, 1, 0, 0, 0, 459, 457, 1, 0, 0, 0, 460,
		461, 5, 137, 0, 0, 461, 19, 1, 0, 0, 0, 462, 465, 3, 336, 168, 0, 463,
		464, 5, 133, 0, 0, 464, 466, 3, 330, 165, 0, 465, 463, 1, 0, 0, 0, 465,
		466, 1, 0, 0, 0, 466, 21, 1, 0, 0, 0, 467, 472, 3, 24, 12, 0, 468, 469,
		5, 131, 0, 0, 469, 471, 3, 32, 16, 0, 470, 468, 1, 0, 0, 0, 471, 474, 1,
		0, 0, 0, 472, 470, 1, 0, 0, 0, 472, 473, 1, 0, 0, 0, 473, 23, 1, 0, 0,
		0, 474, 472, 1, 0, 0, 0, 475, 496, 3, 26, 13, 0, 476, 496, 3, 302, 151,
		0, 477, 478, 5, 136, 0, 0, 478, 479, 3, 22, 11, 0, 479, 480, 5, 137, 0,
		0, 480, 496, 1, 0, 0, 0, 481, 482, 5, 42, 0, 0, 482, 483, 3, 336, 168,
		0, 483, 484, 5, 152, 0, 0, 484, 485, 3, 276, 138, 0, 485, 486, 5, 151,
		0, 0, 486, 487, 3, 276, 138, 0, 487, 488, 5, 153, 0, 0, 488, 489, 3, 276,
		138, 0, 489, 496, 1, 0, 0, 0, 490, 491, 5, 43, 0, 0, 491, 496, 3, 272,
		136, 0, 492, 496, 3, 256, 128, 0, 493, 496, 3, 264, 132, 0, 494, 496, 3,
		30, 15, 0, 495, 475, 1, 0, 0, 0, 495, 476, 1, 0, 0, 0, 495, 477, 1, 0,
		0, 0, 495, 481, 1, 0, 0, 0, 495, 490, 1, 0, 0, 0, 495, 492, 1, 0, 0, 0,
		495, 493, 1, 0, 0, 0, 495, 494, 1, 0, 0, 0, 496, 25, 1, 0, 0, 0, 497, 501,
		3, 28, 14, 0, 498, 501, 3, 336, 168, 0, 499, 501, 5, 206, 0, 0, 500, 497,
		1, 0, 0, 0, 500, 498, 1, 0, 0, 0, 500, 499, 1, 0, 0, 0, 501, 27, 1, 0,
		0, 0, 502, 503, 3, 336, 168, 0, 503, 504, 5, 135, 0, 0, 504, 505, 3, 336,
		168, 0, 505, 506, 5, 135, 0, 0, 506, 507, 3, 336, 168, 0, 507, 513, 1,
		0, 0, 0, 508, 509, 3, 336, 168, 0, 509, 510, 5, 135, 0, 0, 510, 511, 3,
		336, 168, 0, 511, 513, 1, 0, 0, 0, 512, 502, 1, 0, 0, 0, 512, 508, 1, 0,
		0, 0, 513, 29, 1, 0, 0, 0, 514, 515, 5, 58, 0, 0, 515, 516, 5, 136, 0,
		0, 516, 517, 3, 22, 11, 0, 517, 518, 5, 137, 0, 0, 518, 31, 1, 0, 0, 0,
		519, 558, 3, 34, 17, 0, 520, 558, 3, 36, 18, 0, 521, 558, 3, 42, 21, 0,
		522, 558, 3, 44, 22, 0, 523, 558, 3, 46, 23, 0, 524, 558, 3, 48, 24, 0,
		525, 558, 3, 50, 25, 0, 526, 558, 3, 64, 32, 0, 527, 558, 3, 70, 35, 0,
		528, 558, 3, 84, 42, 0, 529, 558, 3, 94, 47, 0, 530, 558, 3, 96, 48, 0,
		531, 558, 3, 100, 50, 0, 532, 558, 3, 102, 51, 0, 533, 558, 3, 106, 53,
		0, 534, 558, 3, 108, 54, 0, 535, 558, 3, 122, 61, 0, 536, 558, 3, 132,
		66, 0, 537, 558, 3, 138, 69, 0, 538, 558, 3, 146, 73, 0, 539, 558, 3, 156,
		78, 0, 540, 558, 3, 168, 84, 0, 541, 558, 3, 176, 88, 0, 542, 558, 3, 180,
		90, 0, 543, 558, 3, 182, 91, 0, 544, 558, 3, 186, 93, 0, 545, 558, 3, 190,
		95, 0, 546, 558, 3, 204, 102, 0, 547, 558, 3, 206, 103, 0, 548, 558, 3,
		208, 104, 0, 549, 558, 3, 210, 105, 0, 550, 558, 3, 220, 110, 0, 551, 558,
		3, 224, 112, 0, 552, 558, 3, 226, 113, 0, 553, 558, 3, 232, 116, 0, 554,
		558, 3, 234, 117, 0, 555, 558, 3, 236, 118, 0, 556, 558, 3, 238, 119, 0,
		557, 519, 1, 0, 0, 0, 557, 520, 1, 0, 0, 0, 557, 521, 1, 0, 0, 0, 557,
		522, 1, 0, 0, 0, 557, 523, 1, 0, 0, 0, 557, 524, 1, 0, 0, 0, 557, 525,
		1, 0, 0, 0, 557, 526, 1, 0, 0, 0, 557, 527, 1, 0, 0, 0, 557, 528, 1, 0,
		0, 0, 557, 529, 1, 0, 0, 0, 557, 530, 1, 0, 0, 0, 557, 531, 1, 0, 0, 0,
		557, 532, 1, 0, 0, 0, 557, 533, 1, 0, 0, 0, 557, 534, 1, 0, 0, 0, 557,
		535, 1, 0, 0, 0, 557, 536, 1, 0, 0, 0, 557, 537, 1, 0, 0, 0, 557, 538,
		1, 0, 0, 0, 557, 539, 1, 0, 0, 0, 557, 540, 1, 0, 0, 0, 557, 541, 1, 0,
		0, 0, 557, 542, 1, 0, 0, 0, 557, 543, 1, 0, 0, 0, 557, 544, 1, 0, 0, 0,
		557, 545, 1, 0, 0, 0, 557, 546, 1, 0, 0, 0, 557, 547, 1, 0, 0, 0, 557,
		548, 1, 0, 0, 0, 557, 549, 1, 0, 0, 0, 557, 550, 1, 0, 0, 0, 557, 551,
		1, 0, 0, 0, 557, 552, 1, 0, 0, 0, 557, 553, 1, 0, 0, 0, 557, 554, 1, 0,
		0, 0, 557, 555, 1, 0, 0, 0, 557, 556, 1, 0, 0, 0, 558, 33, 1, 0, 0, 0,
		559, 560, 5, 1, 0, 0, 560, 561, 3, 276, 138, 0, 561, 35, 1, 0, 0, 0, 562,
		564, 5, 2, 0, 0, 563, 565, 3, 38, 19, 0, 564, 563, 1, 0, 0, 0, 564, 565,
		1, 0, 0, 0, 565, 571, 1, 0, 0, 0, 566, 567, 5, 81, 0, 0, 567, 568, 5, 136,
		0, 0, 568, 569, 3, 40, 20, 0, 569, 570, 5, 137, 0, 0, 570, 572, 1, 0, 0,
		0, 571, 566, 1, 0, 0, 0, 571, 572, 1, 0, 0, 0, 572, 573, 1, 0, 0, 0, 573,
		574, 3, 276, 138, 0, 574, 37, 1, 0, 0, 0, 575, 576, 5, 59, 0, 0, 576, 577,
		5, 114, 0, 0, 577, 578, 3, 336, 168, 0, 578, 39, 1, 0, 0, 0, 579, 584,
		3, 26, 13, 0, 580, 581, 5, 134, 0, 0, 581, 583, 3, 26, 13, 0, 582, 580,
		1, 0, 0, 0, 583, 586, 1, 0, 0, 0, 584, 582, 1, 0, 0, 0, 584, 585, 1, 0,
		0, 0, 585, 41, 1, 0, 0, 0, 586, 584, 1, 0, 0, 0, 587, 588, 5, 11, 0, 0,
		588, 589, 3, 52, 26, 0, 589, 43, 1, 0, 0, 0, 590, 591, 5, 12, 0, 0, 591,
		592, 3, 56, 28, 0, 592, 45, 1, 0, 0, 0, 593, 594, 5, 13, 0, 0, 594, 595,
		3, 56, 28, 0, 595, 47, 1, 0, 0, 0, 596, 597, 5, 14, 0, 0, 597, 598, 3,
		60, 30, 0, 598, 49, 1, 0, 0, 0, 599, 600, 5, 15, 0, 0, 600, 602, 3, 56,
		28, 0, 601, 603, 7, 1, 0, 0, 602, 601, 1, 0, 0, 0, 602, 603, 1, 0, 0, 0,
		603, 51, 1, 0, 0, 0, 604, 609, 3, 54, 27, 0, 605, 606, 5, 134, 0, 0, 606,
		608, 3, 54, 27, 0, 607, 605, 1, 0, 0, 0, 608, 611, 1, 0, 0, 0, 609, 607,
		1, 0, 0, 0, 609, 610, 1, 0, 0, 0, 610, 53, 1, 0, 0, 0, 611, 609, 1, 0,
		0, 0, 612, 615, 3, 276, 138, 0, 613, 614, 5, 32, 0, 0, 614, 616, 3, 336,
		168, 0, 615, 613, 1, 0, 0, 0, 615, 616, 1, 0, 0, 0, 616, 622, 1, 0, 0,
		0, 617, 618, 3, 336, 168, 0, 618, 619, 5, 114, 0, 0, 619, 620, 3, 276,
		138, 0, 620, 622, 1, 0, 0, 0, 621, 612, 1, 0, 0, 0, 621, 617, 1, 0, 0,
		0, 622, 55, 1, 0, 0, 0, 623, 628, 3, 58, 29, 0, 624, 625, 5, 134, 0, 0,
		625, 627, 3, 58, 29, 0, 626, 624, 1, 0, 0, 0, 627, 630, 1, 0, 0, 0, 628,
		626, 1, 0, 0, 0, 628, 629, 1, 0, 0, 0, 629, 57, 1, 0, 0, 0, 630, 628, 1,
		0, 0, 0, 631, 643, 3, 336, 168, 0, 632, 643, 5, 124, 0, 0, 633, 634, 3,
		336, 168, 0, 634, 635, 5, 124, 0, 0, 635, 643, 1, 0, 0, 0, 636, 637, 5,
		124, 0, 0, 637, 643, 3, 336, 168, 0, 638, 639, 3, 336, 168, 0, 639, 640,
		5, 124, 0, 0, 640, 641, 3, 336, 168, 0, 641, 643, 1, 0, 0, 0, 642, 631,
		1, 0, 0, 0, 642, 632, 1, 0, 0, 0, 642, 633, 1, 0, 0, 0, 642, 636, 1, 0,
		0, 0, 642, 638, 1, 0, 0, 0, 643, 59, 1, 0, 0, 0, 644, 649, 3, 62, 31, 0,
		645, 646, 5, 134, 0, 0, 646, 648, 3, 62, 31, 0, 647, 645, 1, 0, 0, 0, 648,
		651, 1, 0, 0, 0, 649, 647, 1, 0, 0, 0, 649, 650, 1, 0, 0, 0, 650, 61, 1,
		0, 0, 0, 651, 649, 1, 0, 0, 0, 652, 653, 3, 336, 168, 0, 653, 654, 5, 114,
		0, 0, 654, 655, 3, 336, 168, 0, 655, 63, 1, 0, 0, 0, 656, 657, 5, 16, 0,
		0, 657, 658, 3, 66, 33, 0, 658, 65, 1, 0, 0, 0, 659, 664, 3, 68, 34, 0,
		660, 661, 5, 134, 0, 0, 661, 663, 3, 68, 34, 0, 662, 660, 1, 0, 0, 0, 663,
		666, 1, 0, 0, 0, 664, 662, 1, 0, 0, 0, 664, 665, 1, 0, 0, 0, 665, 67, 1,
		0, 0, 0, 666, 664, 1, 0, 0, 0, 667, 668, 3, 336, 168, 0, 668, 669, 5, 114,
		0, 0, 669, 670, 3, 276, 138, 0, 670, 677, 1, 0, 0, 0, 671, 674, 3, 276,
		138, 0, 672, 673, 5, 32, 0, 0, 673, 675, 3, 336, 168, 0, 674, 672, 1, 0,
		0, 0, 674, 675, 1, 0, 0, 0, 675, 677, 1, 0, 0, 0, 676, 667, 1, 0, 0, 0,
		676, 671, 1, 0, 0, 0, 677, 69, 1, 0, 0, 0, 678, 680, 5, 25, 0, 0, 679,
		681, 3, 72, 36, 0, 680, 679, 1, 0, 0, 0, 680, 681, 1, 0, 0, 0, 681, 682,
		1, 0, 0, 0, 682, 685, 3, 74, 37, 0, 683, 684, 5, 147, 0, 0, 684, 686, 3,
		80, 40, 0, 685, 683, 1, 0, 0, 0, 685, 686, 1, 0, 0, 0, 686, 71, 1, 0, 0,
		0, 687, 688, 5, 60, 0, 0, 688, 689, 3, 336, 168, 0, 689, 690, 5, 114, 0,
		0, 690, 691, 3, 276, 138, 0, 691, 73, 1, 0, 0, 0, 692, 697, 3, 76, 38,
		0, 693, 694, 5, 134, 0, 0, 694, 696, 3, 76, 38, 0, 695, 693, 1, 0, 0, 0,
		696, 699, 1, 0, 0, 0, 697, 695, 1, 0, 0, 0, 697, 698, 1, 0, 0, 0, 698,
		75, 1, 0, 0, 0, 699, 697, 1, 0, 0, 0, 700, 701, 3, 336, 168, 0, 701, 702,
		5, 114, 0, 0, 702, 703, 3, 78, 39, 0, 703, 710, 1, 0, 0, 0, 704, 707, 3,
		78, 39, 0, 705, 706, 5, 32, 0, 0, 706, 708, 3, 336, 168, 0, 707, 705, 1,
		0, 0, 0, 707, 708, 1, 0, 0, 0, 708, 710, 1, 0, 0, 0, 709, 700, 1, 0, 0,
		0, 709, 704, 1, 0, 0, 0, 710, 77, 1, 0, 0, 0, 711, 714, 3, 302, 151, 0,
		712, 714, 3, 276, 138, 0, 713, 711, 1, 0, 0, 0, 713, 712, 1, 0, 0, 0, 714,
		79, 1, 0, 0, 0, 715, 720, 3, 82, 41, 0, 716, 717, 5, 134, 0, 0, 717, 719,
		3, 82, 41, 0, 718, 716, 1, 0, 0, 0, 719, 722, 1, 0, 0, 0, 720, 718, 1,
		0, 0, 0, 720, 721, 1, 0, 0, 0, 721, 81, 1, 0, 0, 0, 722, 720, 1, 0, 0,
		0, 723, 726, 3, 276, 138, 0, 724, 725, 5, 32, 0, 0, 725, 727, 3, 336, 168,
		0, 726, 724, 1, 0, 0, 0, 726, 727, 1, 0, 0, 0, 727, 733, 1, 0, 0, 0, 728,
		729, 3, 336, 168, 0, 729, 730, 5, 114, 0, 0, 730, 731, 3, 276, 138, 0,
		731, 733, 1, 0, 0, 0, 732, 723, 1, 0, 0, 0, 732, 728, 1, 0, 0, 0, 733,
		83, 1, 0, 0, 0, 734, 735, 7, 2, 0, 0, 735, 736, 5, 147, 0, 0, 736, 737,
		3, 86, 43, 0, 737, 85, 1, 0, 0, 0, 738, 743, 3, 88, 44, 0, 739, 740, 5,
		134, 0, 0, 740, 742, 3, 88, 44, 0, 741, 739, 1, 0, 0, 0, 742, 745, 1, 0,
		0, 0, 743, 741, 1, 0, 0, 0, 743, 744, 1, 0, 0, 0, 744, 87, 1, 0, 0, 0,
		745, 743, 1, 0, 0, 0, 746, 748, 3, 276, 138, 0, 747, 749, 3, 90, 45, 0,
		748, 747, 1, 0, 0, 0, 748, 749, 1, 0, 0, 0, 749, 751, 1, 0, 0, 0, 750,
		752, 3, 92, 46, 0, 751, 750, 1, 0, 0, 0, 751, 752, 1, 0, 0, 0, 752, 89,
		1, 0, 0, 0, 753, 754, 7, 1, 0, 0, 754, 91, 1, 0, 0, 0, 755, 756, 5, 144,
		0, 0, 756, 760, 5, 145, 0, 0, 757, 758, 5, 144, 0, 0, 758, 760, 5, 146,
		0, 0, 759, 755, 1, 0, 0, 0, 759, 757, 1, 0, 0, 0, 760, 93, 1, 0, 0, 0,
		761, 762, 5, 22, 0, 0, 762, 763, 3, 276, 138, 0, 763, 764, 5, 147, 0, 0,
		764, 765, 3, 86, 43, 0, 765, 95, 1, 0, 0, 0, 766, 767, 5, 23, 0, 0, 767,
		772, 3, 98, 49, 0, 768, 769, 5, 134, 0, 0, 769, 771, 3, 98, 49, 0, 770,
		768, 1, 0, 0, 0, 771, 774, 1, 0, 0, 0, 772, 770, 1, 0, 0, 0, 772, 773,
		1, 0, 0, 0, 773, 97, 1, 0, 0, 0, 774, 772, 1, 0, 0, 0, 775, 776, 5, 150,
		0, 0, 776, 778, 3, 336, 168, 0, 777, 775, 1, 0, 0, 0, 777, 778, 1, 0, 0,
		0, 778, 779, 1, 0, 0, 0, 779, 780, 3, 276, 138, 0, 780, 781, 5, 147, 0,
		0, 781, 783, 3, 276, 138, 0, 782, 784, 7, 1, 0, 0, 783, 782, 1, 0, 0, 0,
		783, 784, 1, 0, 0, 0, 784, 789, 1, 0, 0, 0, 785, 786, 5, 149, 0, 0, 786,
		787, 5, 160, 0, 0, 787, 788, 5, 114, 0, 0, 788, 790, 3, 276, 138, 0, 789,
		785, 1, 0, 0, 0, 789, 790, 1, 0, 0, 0, 790, 99, 1, 0, 0, 0, 791, 792, 7,
		3, 0, 0, 792, 793, 3, 276, 138, 0, 793, 101, 1, 0, 0, 0, 794, 796, 5, 8,
		0, 0, 795, 797, 3, 104, 52, 0, 796, 795, 1, 0, 0, 0, 796, 797, 1, 0, 0,
		0, 797, 103, 1, 0, 0, 0, 798, 801, 3, 56, 28, 0, 799, 801, 5, 124, 0, 0,
		800, 798, 1, 0, 0, 0, 800, 799, 1, 0, 0, 0, 801, 105, 1, 0, 0, 0, 802,
		803, 5, 9, 0, 0, 803, 107, 1, 0, 0, 0, 804, 806, 5, 29, 0, 0, 805, 807,
		3, 110, 55, 0, 806, 805, 1, 0, 0, 0, 806, 807, 1, 0, 0, 0, 807, 809, 1,
		0, 0, 0, 808, 810, 3, 114, 57, 0, 809, 808, 1, 0, 0, 0, 809, 810, 1, 0,
		0, 0, 810, 811, 1, 0, 0, 0, 811, 812, 5, 136, 0, 0, 812, 813, 3, 22, 11,
		0, 813, 814, 5, 137, 0, 0, 814, 815, 5, 148, 0, 0, 815, 816, 3, 118, 59,
		0, 816, 829, 1, 0, 0, 0, 817, 819, 5, 29, 0, 0, 818, 820, 3, 110, 55, 0,
		819, 818, 1, 0, 0, 0, 819, 820, 1, 0, 0, 0, 820, 822, 1, 0, 0, 0, 821,
		823, 3, 114, 57, 0, 822, 821, 1, 0, 0, 0, 822, 823, 1, 0, 0, 0, 823, 824,
		1, 0, 0, 0, 824, 825, 3, 26, 13, 0, 825, 826, 5, 148, 0, 0, 826, 827, 3,
		118, 59, 0, 827, 829, 1, 0, 0, 0, 828, 804, 1, 0, 0, 0, 828, 817, 1, 0,
		0, 0, 829, 109, 1, 0, 0, 0, 830, 831, 5, 59, 0, 0, 831, 832, 5, 114, 0,
		0, 832, 833, 3, 112, 56, 0, 833, 111, 1, 0, 0, 0, 834, 835, 7, 4, 0, 0,
		835, 113, 1, 0, 0, 0, 836, 838, 3, 116, 58, 0, 837, 836, 1, 0, 0, 0, 838,
		839, 1, 0, 0, 0, 839, 837, 1, 0, 0, 0, 839, 840, 1, 0, 0, 0, 840, 115,
		1, 0, 0, 0, 841, 842, 5, 60, 0, 0, 842, 843, 3, 336, 168, 0, 843, 844,
		5, 114, 0, 0, 844, 845, 3, 276, 138, 0, 845, 117, 1, 0, 0, 0, 846, 851,
		3, 120, 60, 0, 847, 848, 5, 134, 0, 0, 848, 850, 3, 120, 60, 0, 849, 847,
		1, 0, 0, 0, 850, 853, 1, 0, 0, 0, 851, 849, 1, 0, 0, 0, 851, 852, 1, 0,
		0, 0, 852, 856, 1, 0, 0, 0, 853, 851, 1, 0, 0, 0, 854, 856, 3, 276, 138,
		0, 855, 846, 1, 0, 0, 0, 855, 854, 1, 0, 0, 0, 856, 119, 1, 0, 0, 0, 857,
		869, 3, 336, 168, 0, 858, 859, 5, 161, 0, 0, 859, 860, 5, 63, 0, 0, 860,
		861, 5, 135, 0, 0, 861, 862, 3, 336, 168, 0, 862, 863, 5, 113, 0, 0, 863,
		864, 5, 161, 0, 0, 864, 865, 5, 64, 0, 0, 865, 866, 5, 135, 0, 0, 866,
		867, 3, 336, 168, 0, 867, 869, 1, 0, 0, 0, 868, 857, 1, 0, 0, 0, 868, 858,
		1, 0, 0, 0, 869, 121, 1, 0, 0, 0, 870, 872, 5, 31, 0, 0, 871, 873, 3, 124,
		62, 0, 872, 871, 1, 0, 0, 0, 872, 873, 1, 0, 0, 0, 873, 874, 1, 0, 0, 0,
		874, 875, 3, 128, 64, 0, 875, 123, 1, 0, 0, 0, 876, 878, 3, 126, 63, 0,
		877, 876, 1, 0, 0, 0, 878, 879, 1, 0, 0, 0, 879, 877, 1, 0, 0, 0, 879,
		880, 1, 0, 0, 0, 880, 125, 1, 0, 0, 0, 881, 882, 5, 59, 0, 0, 882, 883,
		5, 114, 0, 0, 883, 891, 3, 336, 168, 0, 884, 885, 5, 162, 0, 0, 885, 886,
		5, 114, 0, 0, 886, 891, 3, 336, 168, 0, 887, 888, 5, 163, 0, 0, 888, 889,
		5, 114, 0, 0, 889, 891, 3, 334, 167, 0, 890, 881, 1, 0, 0, 0, 890, 884,
		1, 0, 0, 0, 890, 887, 1, 0, 0, 0, 891, 127, 1, 0, 0, 0, 892, 897, 3, 130,
		65, 0, 893, 894, 5, 134, 0, 0, 894, 896, 3, 130, 65, 0, 895, 893, 1, 0,
		0, 0, 896, 899, 1, 0, 0, 0, 897, 895, 1, 0, 0, 0, 897, 898, 1, 0, 0, 0,
		898, 129, 1, 0, 0, 0, 899, 897, 1, 0, 0, 0, 900, 901, 5, 136, 0, 0, 901,
		902, 3, 22, 11, 0, 902, 903, 5, 137, 0, 0, 903, 906, 1, 0, 0, 0, 904, 906,
		3, 26, 13, 0, 905, 900, 1, 0, 0, 0, 905, 904, 1, 0, 0, 0, 906, 131, 1,
		0, 0, 0, 907, 909, 5, 30, 0, 0, 908, 910, 3, 134, 67, 0, 909, 908, 1, 0,
		0, 0, 909, 910, 1, 0, 0, 0, 910, 911, 1, 0, 0, 0, 911, 912, 5, 136, 0,
		0, 912, 913, 3, 22, 11, 0, 913, 914, 5, 137, 0, 0, 914, 915, 5, 148, 0,
		0, 915, 916, 3, 136, 68, 0, 916, 926, 1, 0, 0, 0, 917, 919, 5, 30, 0, 0,
		918, 920, 3, 134, 67, 0, 919, 918, 1, 0, 0, 0, 919, 920, 1, 0, 0, 0, 920,
		921, 1, 0, 0, 0, 921, 922, 3, 26, 13, 0, 922, 923, 5, 148, 0, 0, 923, 924,
		3, 136, 68, 0, 924, 926, 1, 0, 0, 0, 925, 907, 1, 0, 0, 0, 925, 917, 1,
		0, 0, 0, 926, 133, 1, 0, 0, 0, 927, 928, 5, 59, 0, 0, 928, 929, 5, 114,
		0, 0, 929, 930, 3, 336, 168, 0, 930, 135, 1, 0, 0, 0, 931, 932, 3, 118,
		59, 0, 932, 137, 1, 0, 0, 0, 933, 935, 5, 17, 0, 0, 934, 936, 3, 140, 70,
		0, 935, 934, 1, 0, 0, 0, 935, 936, 1, 0, 0, 0, 936, 937, 1, 0, 0, 0, 937,
		939, 3, 276, 138, 0, 938, 940, 5, 149, 0, 0, 939, 938, 1, 0, 0, 0, 939,
		940, 1, 0, 0, 0, 940, 941, 1, 0, 0, 0, 941, 942, 3, 142, 71, 0, 942, 954,
		1, 0, 0, 0, 943, 945, 5, 18, 0, 0, 944, 946, 3, 140, 70, 0, 945, 944, 1,
		0, 0, 0, 945, 946, 1, 0, 0, 0, 946, 947, 1, 0, 0, 0, 947, 949, 3, 276,
		138, 0, 948, 950, 5, 149, 0, 0, 949, 948, 1, 0, 0, 0, 949, 950, 1, 0, 0,
		0, 950, 951, 1, 0, 0, 0, 951, 952, 3, 142, 71, 0, 952, 954, 1, 0, 0, 0,
		953, 933, 1, 0, 0, 0, 953, 943, 1, 0, 0, 0, 954, 139, 1, 0, 0, 0, 955,
		956, 5, 59, 0, 0, 956, 957, 5, 114, 0, 0, 957, 958, 3, 336, 168, 0, 958,
		141, 1, 0, 0, 0, 959, 961, 3, 144, 72, 0, 960, 959, 1, 0, 0, 0, 961, 962,
		1, 0, 0, 0, 962, 960, 1, 0, 0, 0, 962, 963, 1, 0, 0, 0, 963, 143, 1, 0,
		0, 0, 964, 973, 5, 197, 0, 0, 965, 973, 5, 198, 0, 0, 966, 973, 5, 124,
		0, 0, 967, 968, 3, 336, 168, 0, 968, 970, 5, 133, 0, 0, 969, 971, 3, 330,
		165, 0, 970, 969, 1, 0, 0, 0, 970, 971, 1, 0, 0, 0, 971, 973, 1, 0, 0,
		0, 972, 964, 1, 0, 0, 0, 972, 965, 1, 0, 0, 0, 972, 966, 1, 0, 0, 0, 972,
		967, 1, 0, 0, 0, 973, 145, 1, 0, 0, 0, 974, 975, 5, 19, 0, 0, 975, 976,
		3, 276, 138, 0, 976, 977, 5, 32, 0, 0, 977, 978, 5, 136, 0, 0, 978, 979,
		3, 148, 74, 0, 979, 981, 5, 137, 0, 0, 980, 982, 3, 152, 76, 0, 981, 980,
		1, 0, 0, 0, 981, 982, 1, 0, 0, 0, 982, 147, 1, 0, 0, 0, 983, 988, 3, 150,
		75, 0, 984, 985, 5, 134, 0, 0, 985, 987, 3, 150, 75, 0, 986, 984, 1, 0,
		0, 0, 987, 990, 1, 0, 0, 0, 988, 986, 1, 0, 0, 0, 988, 989, 1, 0, 0, 0,
		989, 149, 1, 0, 0, 0, 990, 988, 1, 0, 0, 0, 991, 992, 3, 336, 168, 0, 992,
		993, 5, 133, 0, 0, 993, 994, 3, 330, 165, 0, 994, 151, 1, 0, 0, 0, 995,
		996, 5, 149, 0, 0, 996, 997, 5, 136, 0, 0, 997, 1002, 3, 154, 77, 0, 998,
		999, 5, 134, 0, 0, 999, 1001, 3, 154, 77, 0, 1000, 998, 1, 0, 0, 0, 1001,
		1004, 1, 0, 0, 0, 1002, 1000, 1, 0, 0, 0, 1002, 1003, 1, 0, 0, 0, 1003,
		1005, 1, 0, 0, 0, 1004, 1002, 1, 0, 0, 0, 1005, 1006, 5, 137, 0, 0, 1006,
		153, 1, 0, 0, 0, 1007, 1008, 3, 336, 168, 0, 1008, 1009, 5, 114, 0, 0,
		1009, 1010, 3, 276, 138, 0, 1010, 155, 1, 0, 0, 0, 1011, 1013, 5, 33, 0,
		0, 1012, 1014, 3, 158, 79, 0, 1013, 1012, 1, 0, 0, 0, 1013, 1014, 1, 0,
		0, 0, 1014, 1016, 1, 0, 0, 0, 1015, 1017, 3, 160, 80, 0, 1016, 1015, 1,
		0, 0, 0, 1016, 1017, 1, 0, 0, 0, 1017, 1018, 1, 0, 0, 0, 1018, 1020, 3,
		162, 81, 0, 1019, 1021, 3, 166, 83, 0, 1020, 1019, 1, 0, 0, 0, 1020, 1021,
		1, 0, 0, 0, 1021, 157, 1, 0, 0, 0, 1022, 1023, 5, 59, 0, 0, 1023, 1024,
		5, 114, 0, 0, 1024, 1025, 3, 336, 168, 0, 1025, 159, 1, 0, 0, 0, 1026,
		1027, 5, 164, 0, 0, 1027, 1028, 5, 114, 0, 0, 1028, 1033, 3, 336, 168,
		0, 1029, 1030, 5, 165, 0, 0, 1030, 1031, 5, 114, 0, 0, 1031, 1033, 3, 336,
		168, 0, 1032, 1026, 1, 0, 0, 0, 1032, 1029, 1, 0, 0, 0, 1033, 161, 1, 0,
		0, 0, 1034, 1039, 3, 164, 82, 0, 1035, 1036, 5, 134, 0, 0, 1036, 1038,
		3, 164, 82, 0, 1037, 1035, 1, 0, 0, 0, 1038, 1041, 1, 0, 0, 0, 1039, 1037,
		1, 0, 0, 0, 1039, 1040, 1, 0, 0, 0, 1040, 163, 1, 0, 0, 0, 1041, 1039,
		1, 0, 0, 0, 1042, 1049, 3, 276, 138, 0, 1043, 1044, 5, 151, 0, 0, 1044,
		1045, 5, 155, 0, 0, 1045, 1046, 5, 136, 0, 0, 1046, 1047, 3, 330, 165,
		0, 1047, 1048, 5, 137, 0, 0, 1048, 1050, 1, 0, 0, 0, 1049, 1043, 1, 0,
		0, 0, 1049, 1050, 1, 0, 0, 0, 1050, 1063, 1, 0, 0, 0, 1051, 1052, 3, 336,
		168, 0, 1052, 1053, 5, 114, 0, 0, 1053, 1060, 3, 276, 138, 0, 1054, 1055,
		5, 151, 0, 0, 1055, 1056, 5, 155, 0, 0, 1056, 1057, 5, 136, 0, 0, 1057,
		1058, 3, 330, 165, 0, 1058, 1059, 5, 137, 0, 0, 1059, 1061, 1, 0, 0, 0,
		1060, 1054, 1, 0, 0, 0, 1060, 1061, 1, 0, 0, 0, 1061, 1063, 1, 0, 0, 0,
		1062, 1042, 1, 0, 0, 0, 1062, 1051, 1, 0, 0, 0, 1063, 165, 1, 0, 0, 0,
		1064, 1065, 5, 5, 0, 0, 1065, 1066, 3, 276, 138, 0, 1066, 167, 1, 0, 0,
		0, 1067, 1068, 5, 34, 0, 0, 1068, 1070, 3, 170, 85, 0, 1069, 1071, 3, 174,
		87, 0, 1070, 1069, 1, 0, 0, 0, 1070, 1071, 1, 0, 0, 0, 1071, 1072, 1, 0,
		0, 0, 1072, 1073, 5, 136, 0, 0, 1073, 1074, 3, 22, 11, 0, 1074, 1075, 5,
		137, 0, 0, 1075, 169, 1, 0, 0, 0, 1076, 1081, 3, 172, 86, 0, 1077, 1078,
		5, 134, 0, 0, 1078, 1080, 3, 172, 86, 0, 1079, 1077, 1, 0, 0, 0, 1080,
		1083, 1, 0, 0, 0, 1081, 1079, 1, 0, 0, 0, 1081, 1082, 1, 0, 0, 0, 1082,
		171, 1, 0, 0, 0, 1083, 1081, 1, 0, 0, 0, 1084, 1091, 3, 276, 138, 0, 1085,
		1086, 5, 151, 0, 0, 1086, 1087, 5, 155, 0, 0, 1087, 1088, 5, 136, 0, 0,
		1088, 1089, 3, 330, 165, 0, 1089, 1090, 5, 137, 0, 0, 1090, 1092, 1, 0,
		0, 0, 1091, 1085, 1, 0, 0, 0, 1091, 1092, 1, 0, 0, 0, 1092, 1095, 1, 0,
		0, 0, 1093, 1094, 5, 32, 0, 0, 1094, 1096, 3, 336, 168, 0, 1095, 1093,
		1, 0, 0, 0, 1095, 1096, 1, 0, 0, 0, 1096, 1109, 1, 0, 0, 0, 1097, 1098,
		3, 336, 168, 0, 1098, 1099, 5, 114, 0, 0, 1099, 1106, 3, 276, 138, 0, 1100,
		1101, 5, 151, 0, 0, 1101, 1102, 5, 155, 0, 0, 1102, 1103, 5, 136, 0, 0,
		1103, 1104, 3, 330, 165, 0, 1104, 1105, 5, 137, 0, 0, 1105, 1107, 1, 0,
		0, 0, 1106, 1100, 1, 0, 0, 0, 1106, 1107, 1, 0, 0, 0, 1107, 1109, 1, 0,
		0, 0, 1108, 1084, 1, 0, 0, 0, 1108, 1097, 1, 0, 0, 0, 1109, 173, 1, 0,
		0, 0, 1110, 1111, 5, 148, 0, 0, 1111, 1112, 3, 338, 169, 0, 1112, 175,
		1, 0, 0, 0, 1113, 1115, 5, 35, 0, 0, 1114, 1116, 3, 178, 89, 0, 1115, 1114,
		1, 0, 0, 0, 1115, 1116, 1, 0, 0, 0, 1116, 1117, 1, 0, 0, 0, 1117, 1118,
		3, 302, 151, 0, 1118, 177, 1, 0, 0, 0, 1119, 1120, 5, 60, 0, 0, 1120, 1121,
		3, 336, 168, 0, 1121, 1122, 5, 114, 0, 0, 1122, 1123, 3, 276, 138, 0, 1123,
		179, 1, 0, 0, 0, 1124, 1125, 5, 37, 0, 0, 1125, 1126, 5, 147, 0, 0, 1126,
		1132, 3, 338, 169, 0, 1127, 1128, 5, 149, 0, 0, 1128, 1129, 5, 136, 0,
		0, 1129, 1130, 3, 22, 11, 0, 1130, 1131, 5, 137, 0, 0, 1131, 1133, 1, 0,
		0, 0, 1132, 1127, 1, 0, 0, 0, 1132, 1133, 1, 0, 0, 0, 1133, 181, 1, 0,
		0, 0, 1134, 1136, 5, 38, 0, 0, 1135, 1137, 3, 184, 92, 0, 1136, 1135, 1,
		0, 0, 0, 1137, 1138, 1, 0, 0, 0, 1138, 1136, 1, 0, 0, 0, 1138, 1139, 1,
		0, 0, 0, 1139, 183, 1, 0, 0, 0, 1140, 1141, 5, 136, 0, 0, 1141, 1142, 3,
		22, 11, 0, 1142, 1143, 5, 137, 0, 0, 1143, 185, 1, 0, 0, 0, 1144, 1146,
		5, 39, 0, 0, 1145, 1147, 3, 188, 94, 0, 1146, 1145, 1, 0, 0, 0, 1146, 1147,
		1, 0, 0, 0, 1147, 1148, 1, 0, 0, 0, 1148, 1149, 5, 147, 0, 0, 1149, 1150,
		3, 276, 138, 0, 1150, 1151, 5, 136, 0, 0, 1151, 1152, 3, 22, 11, 0, 1152,
		1153, 5, 137, 0, 0, 1153, 187, 1, 0, 0, 0, 1154, 1155, 5, 60, 0, 0, 1155,
		1156, 3, 336, 168, 0, 1156, 1157, 5, 114, 0, 0, 1157, 1158, 3, 276, 138,
		0, 1158, 189, 1, 0, 0, 0, 1159, 1161, 5, 40, 0, 0, 1160, 1162, 3, 192,
		96, 0, 1161, 1160, 1, 0, 0, 0, 1161, 1162, 1, 0, 0, 0, 1162, 1164, 1, 0,
		0, 0, 1163, 1165, 3, 194, 97, 0, 1164, 1163, 1, 0, 0, 0, 1164, 1165, 1,
		0, 0, 0, 1165, 1166, 1, 0, 0, 0, 1166, 1167, 5, 149, 0, 0, 1167, 1168,
		5, 136, 0, 0, 1168, 1169, 3, 198, 99, 0, 1169, 1170, 5, 137, 0, 0, 1170,
		191, 1, 0, 0, 0, 1171, 1172, 5, 166, 0, 0, 1172, 1173, 5, 114, 0, 0, 1173,
		1174, 3, 336, 168, 0, 1174, 193, 1, 0, 0, 0, 1175, 1176, 5, 54, 0, 0, 1176,
		1177, 5, 136, 0, 0, 1177, 1182, 3, 196, 98, 0, 1178, 1179, 5, 134, 0, 0,
		1179, 1181, 3, 196, 98, 0, 1180, 1178, 1, 0, 0, 0, 1181, 1184, 1, 0, 0,
		0, 1182, 1180, 1, 0, 0, 0, 1182, 1183, 1, 0, 0, 0, 1183, 1185, 1, 0, 0,
		0, 1184, 1182, 1, 0, 0, 0, 1185, 1186, 5, 137, 0, 0, 1186, 195, 1, 0, 0,
		0, 1187, 1188, 3, 336, 168, 0, 1188, 1189, 5, 133, 0, 0, 1189, 1192, 3,
		330, 165, 0, 1190, 1191, 5, 114, 0, 0, 1191, 1193, 3, 276, 138, 0, 1192,
		1190, 1, 0, 0, 0, 1192, 1193, 1, 0, 0, 0, 1193, 197, 1, 0, 0, 0, 1194,
		1199, 3, 200, 100, 0, 1195, 1196, 5, 134, 0, 0, 1196, 1198, 3, 200, 100,
		0, 1197, 1195, 1, 0, 0, 0, 1198, 1201, 1, 0, 0, 0, 1199, 1197, 1, 0, 0,
		0, 1199, 1200, 1, 0, 0, 0, 1200, 199, 1, 0, 0, 0, 1201, 1199, 1, 0, 0,
		0, 1202, 1203, 5, 153, 0, 0, 1203, 1207, 3, 336, 168, 0, 1204, 1205, 5,
		167, 0, 0, 1205, 1206, 5, 114, 0, 0, 1206, 1208, 3, 336, 168, 0, 1207,
		1204, 1, 0, 0, 0, 1207, 1208, 1, 0, 0, 0, 1208, 1209, 1, 0, 0, 0, 1209,
		1210, 5, 133, 0, 0, 1210, 1211, 3, 276, 138, 0, 1211, 1212, 5, 128, 0,
		0, 1212, 1214, 5, 140, 0, 0, 1213, 1215, 3, 202, 101, 0, 1214, 1213, 1,
		0, 0, 0, 1215, 1216, 1, 0, 0, 0, 1216, 1214, 1, 0, 0, 0, 1216, 1217, 1,
		0, 0, 0, 1217, 1218, 1, 0, 0, 0, 1218, 1219, 5, 141, 0, 0, 1219, 201, 1,
		0, 0, 0, 1220, 1221, 3, 336, 168, 0, 1221, 1222, 5, 114, 0, 0, 1222, 1224,
		3, 276, 138, 0, 1223, 1225, 5, 132, 0, 0, 1224, 1223, 1, 0, 0, 0, 1224,
		1225, 1, 0, 0, 0, 1225, 203, 1, 0, 0, 0, 1226, 1228, 5, 41, 0, 0, 1227,
		1229, 3, 66, 33, 0, 1228, 1227, 1, 0, 0, 0, 1228, 1229, 1, 0, 0, 0, 1229,
		205, 1, 0, 0, 0, 1230, 1231, 5, 6, 0, 0, 1231, 1232, 3, 276, 138, 0, 1232,
		207, 1, 0, 0, 0, 1233, 1234, 5, 7, 0, 0, 1234, 1235, 3, 276, 138, 0, 1235,
		1236, 5, 150, 0, 0, 1236, 1237, 3, 336, 168, 0, 1237, 209, 1, 0, 0, 0,
		1238, 1239, 5, 26, 0, 0, 1239, 1240, 3, 212, 106, 0, 1240, 1242, 3, 216,
		108, 0, 1241, 1243, 3, 218, 109, 0, 1242, 1241, 1, 0, 0, 0, 1242, 1243,
		1, 0, 0, 0, 1243, 211, 1, 0, 0, 0, 1244, 1249, 3, 214, 107, 0, 1245, 1246,
		5, 134, 0, 0, 1246, 1248, 3, 214, 107, 0, 1247, 1245, 1, 0, 0, 0, 1248,
		1251, 1, 0, 0, 0, 1249, 1247, 1, 0, 0, 0, 1249, 1250, 1, 0, 0, 0, 1250,
		213, 1, 0, 0, 0, 1251, 1249, 1, 0, 0, 0, 1252, 1254, 3, 336, 168, 0, 1253,
		1252, 1, 0, 0, 0, 1253, 1254, 1, 0, 0, 0, 1254, 1256, 1, 0, 0, 0, 1255,
		1257, 5, 114, 0, 0, 1256, 1255, 1, 0, 0, 0, 1256, 1257, 1, 0, 0, 0, 1257,
		1258, 1, 0, 0, 0, 1258, 1262, 3, 78, 39, 0, 1259, 1260, 5, 154, 0, 0, 1260,
		1261, 5, 114, 0, 0, 1261, 1263, 3, 276, 138, 0, 1262, 1259, 1, 0, 0, 0,
		1262, 1263, 1, 0, 0, 0, 1263, 215, 1, 0, 0, 0, 1264, 1265, 5, 148, 0, 0,
		1265, 1271, 3, 276, 138, 0, 1266, 1267, 5, 152, 0, 0, 1267, 1268, 3, 276,
		138, 0, 1268, 1269, 5, 151, 0, 0, 1269, 1270, 3, 276, 138, 0, 1270, 1272,
		1, 0, 0, 0, 1271, 1266, 1, 0, 0, 0, 1271, 1272, 1, 0, 0, 0, 1272, 1273,
		1, 0, 0, 0, 1273, 1274, 5, 153, 0, 0, 1274, 1277, 3, 276, 138, 0, 1275,
		1276, 5, 147, 0, 0, 1276, 1278, 3, 80, 40, 0, 1277, 1275, 1, 0, 0, 0, 1277,
		1278, 1, 0, 0, 0, 1278, 217, 1, 0, 0, 0, 1279, 1280, 5, 59, 0, 0, 1280,
		1281, 5, 114, 0, 0, 1281, 1282, 3, 336, 168, 0, 1282, 219, 1, 0, 0, 0,
		1283, 1285, 5, 3, 0, 0, 1284, 1286, 3, 222, 111, 0, 1285, 1284, 1, 0, 0,
		0, 1285, 1286, 1, 0, 0, 0, 1286, 1292, 1, 0, 0, 0, 1287, 1288, 5, 81, 0,
		0, 1288, 1289, 5, 136, 0, 0, 1289, 1290, 3, 40, 20, 0, 1290, 1291, 5, 137,
		0, 0, 1291, 1293, 1, 0, 0, 0, 1292, 1287, 1, 0, 0, 0, 1292, 1293, 1, 0,
		0, 0, 1293, 1294, 1, 0, 0, 0, 1294, 1295, 5, 1, 0, 0, 1295, 1298, 3, 276,
		138, 0, 1296, 1297, 5, 11, 0, 0, 1297, 1299, 3, 52, 26, 0, 1298, 1296,
		1, 0, 0, 0, 1298, 1299, 1, 0, 0, 0, 1299, 221, 1, 0, 0, 0, 1300, 1301,
		5, 162, 0, 0, 1301, 1302, 5, 114, 0, 0, 1302, 1307, 3, 336, 168, 0, 1303,
		1304, 5, 168, 0, 0, 1304, 1305, 5, 114, 0, 0, 1305, 1307, 3, 336, 168,
		0, 1306, 1300, 1, 0, 0, 0, 1306, 1303, 1, 0, 0, 0, 1307, 223, 1, 0, 0,
		0, 1308, 1309, 5, 10, 0, 0, 1309, 225, 1, 0, 0, 0, 1310, 1311, 5, 44, 0,
		0, 1311, 1313, 3, 336, 168, 0, 1312, 1314, 3, 228, 114, 0, 1313, 1312,
		1, 0, 0, 0, 1313, 1314, 1, 0, 0, 0, 1314, 227, 1, 0, 0, 0, 1315, 1316,
		5, 149, 0, 0, 1316, 1317, 5, 136, 0, 0, 1317, 1322, 3, 230, 115, 0, 1318,
		1319, 5, 134, 0, 0, 1319, 1321, 3, 230, 115, 0, 1320, 1318, 1, 0, 0, 0,
		1321, 1324, 1, 0, 0, 0, 1322, 1320, 1, 0, 0, 0, 1322, 1323, 1, 0, 0, 0,
		1323, 1325, 1, 0, 0, 0, 1324, 1322, 1, 0, 0, 0, 1325, 1326, 5, 137, 0,
		0, 1326, 229, 1, 0, 0, 0, 1327, 1328, 3, 336, 168, 0, 1328, 1329, 5, 114,
		0, 0, 1329, 1330, 3, 276, 138, 0, 1330, 231, 1, 0, 0, 0, 1331, 1335, 5,
		45, 0, 0, 1332, 1333, 5, 169, 0, 0, 1333, 1334, 5, 114, 0, 0, 1334, 1336,
		3, 334, 167, 0, 1335, 1332, 1, 0, 0, 0, 1335, 1336, 1, 0, 0, 0, 1336, 233,
		1, 0, 0, 0, 1337, 1338, 5, 36, 0, 0, 1338, 1339, 3, 302, 151, 0, 1339,
		235, 1, 0, 0, 0, 1340, 1341, 5, 32, 0, 0, 1341, 1342, 3, 336, 168, 0, 1342,
		237, 1, 0, 0, 0, 1343, 1348, 3, 240, 120, 0, 1344, 1348, 3, 242, 121, 0,
		1345, 1348, 3, 250, 125, 0, 1346, 1348, 3, 252, 126, 0, 1347, 1343, 1,
		0, 0, 0, 1347, 1344, 1, 0, 0, 0, 1347, 1345, 1, 0, 0, 0, 1347, 1346, 1,
		0, 0, 0, 1348, 239, 1, 0, 0, 0, 1349, 1350, 5, 47, 0, 0, 1350, 1351, 3,
		336, 168, 0, 1351, 1352, 5, 128, 0, 0, 1352, 1353, 3, 336, 168, 0, 1353,
		1354, 5, 149, 0, 0, 1354, 1355, 3, 26, 13, 0, 1355, 1356, 5, 148, 0, 0,
		1356, 1357, 3, 336, 168, 0, 1357, 241, 1, 0, 0, 0, 1358, 1359, 5, 48, 0,
		0, 1359, 1362, 3, 244, 122, 0, 1360, 1361, 5, 11, 0, 0, 1361, 1363, 3,
		52, 26, 0, 1362, 1360, 1, 0, 0, 0, 1362, 1363, 1, 0, 0, 0, 1363, 1366,
		1, 0, 0, 0, 1364, 1365, 5, 1, 0, 0, 1365, 1367, 3, 276, 138, 0, 1366, 1364,
		1, 0, 0, 0, 1366, 1367, 1, 0, 0, 0, 1367, 243, 1, 0, 0, 0, 1368, 1370,
		3, 246, 123, 0, 1369, 1368, 1, 0, 0, 0, 1370, 1371, 1, 0, 0, 0, 1371, 1369,
		1, 0, 0, 0, 1371, 1372, 1, 0, 0, 0, 1372, 245, 1, 0, 0, 0, 1373, 1374,
		5, 136, 0, 0, 1374, 1377, 3, 336, 168, 0, 1375, 1376, 5, 133, 0, 0, 1376,
		1378, 3, 336, 168, 0, 1377, 1375, 1, 0, 0, 0, 1377, 1378, 1, 0, 0, 0, 1378,
		1379, 1, 0, 0, 0, 1379, 1381, 5, 137, 0, 0, 1380, 1382, 3, 248, 124, 0,
		1381, 1380, 1, 0, 0, 0, 1381, 1382, 1, 0, 0, 0, 1382, 247, 1, 0, 0, 0,
		1383, 1384, 5, 123, 0, 0, 1384, 1386, 5, 138, 0, 0, 1385, 1387, 3, 336,
		168, 0, 1386, 1385, 1, 0, 0, 0, 1386, 1387, 1, 0, 0, 0, 1387, 1390, 1,
		0, 0, 0, 1388, 1389, 5, 133, 0, 0, 1389, 1391, 3, 336, 168, 0, 1390, 1388,
		1, 0, 0, 0, 1390, 1391, 1, 0, 0, 0, 1391, 1392, 1, 0, 0, 0, 1392, 1393,
		5, 139, 0, 0, 1393, 1394, 5, 128, 0, 0, 1394, 1409, 3, 246, 123, 0, 1395,
		1396, 5, 116, 0, 0, 1396, 1397, 5, 123, 0, 0, 1397, 1399, 5, 138, 0, 0,
		1398, 1400, 3, 336, 168, 0, 1399, 1398, 1, 0, 0, 0, 1399, 1400, 1, 0, 0,
		0, 1400, 1403, 1, 0, 0, 0, 1401, 1402, 5, 133, 0, 0, 1402, 1404, 3, 336,
		168, 0, 1403, 1401, 1, 0, 0, 0, 1403, 1404, 1, 0, 0, 0, 1404, 1405, 1,
		0, 0, 0, 1405, 1406, 5, 139, 0, 0, 1406, 1407, 5, 123, 0, 0, 1407, 1409,
		3, 246, 123, 0, 1408, 1383, 1, 0, 0, 0, 1408, 1395, 1, 0, 0, 0, 1409, 249,
		1, 0, 0, 0, 1410, 1411, 5, 49, 0, 0, 1411, 1414, 3, 244, 122, 0, 1412,
		1413, 5, 11, 0, 0, 1413, 1415, 3, 52, 26, 0, 1414, 1412, 1, 0, 0, 0, 1414,
		1415, 1, 0, 0, 0, 1415, 251, 1, 0, 0, 0, 1416, 1417, 5, 50, 0, 0, 1417,
		1418, 3, 254, 127, 0, 1418, 253, 1, 0, 0, 0, 1419, 1422, 7, 5, 0, 0, 1420,
		1421, 5, 32, 0, 0, 1421, 1423, 3, 336, 168, 0, 1422, 1420, 1, 0, 0, 0,
		1422, 1423, 1, 0, 0, 0, 1423, 255, 1, 0, 0, 0, 1424, 1425, 5, 172, 0, 0,
		1425, 1426, 5, 136, 0, 0, 1426, 1427, 3, 258, 129, 0, 1427, 1428, 5, 137,
		0, 0, 1428, 1429, 5, 138, 0, 0, 1429, 1430, 3, 262, 131, 0, 1430, 1431,
		5, 139, 0, 0, 1431, 257, 1, 0, 0, 0, 1432, 1437, 3, 260, 130, 0, 1433,
		1434, 5, 134, 0, 0, 1434, 1436, 3, 260, 130, 0, 1435, 1433, 1, 0, 0, 0,
		1436, 1439, 1, 0, 0, 0, 1437, 1435, 1, 0, 0, 0, 1437, 1438, 1, 0, 0, 0,
		1438, 259, 1, 0, 0, 0, 1439, 1437, 1, 0, 0, 0, 1440, 1441, 3, 336, 168,
		0, 1441, 1442, 5, 133, 0, 0, 1442, 1443, 3, 330, 165, 0, 1443, 261, 1,
		0, 0, 0, 1444, 1449, 3, 332, 166, 0, 1445, 1446, 5, 134, 0, 0, 1446, 1448,
		3, 332, 166, 0, 1447, 1445, 1, 0, 0, 0, 1448, 1451, 1, 0, 0, 0, 1449, 1447,
		1, 0, 0, 0, 1449, 1450, 1, 0, 0, 0, 1450, 1453, 1, 0, 0, 0, 1451, 1449,
		1, 0, 0, 0, 1452, 1444, 1, 0, 0, 0, 1452, 1453, 1, 0, 0, 0, 1453, 263,
		1, 0, 0, 0, 1454, 1455, 5, 46, 0, 0, 1455, 1456, 5, 136, 0, 0, 1456, 1457,
		3, 258, 129, 0, 1457, 1458, 5, 137, 0, 0, 1458, 1459, 5, 138, 0, 0, 1459,
		1464, 3, 266, 133, 0, 1460, 1461, 5, 134, 0, 0, 1461, 1463, 3, 266, 133,
		0, 1462, 1460, 1, 0, 0, 0, 1463, 1466, 1, 0, 0, 0, 1464, 1462, 1, 0, 0,
		0, 1464, 1465, 1, 0, 0, 0, 1465, 1467, 1, 0, 0, 0, 1466, 1464, 1, 0, 0,
		0, 1467, 1469, 5, 139, 0, 0, 1468, 1470, 3, 268, 134, 0, 1469, 1468, 1,
		0, 0, 0, 1469, 1470, 1, 0, 0, 0, 1470, 265, 1, 0, 0, 0, 1471, 1472, 7,
		6, 0, 0, 1472, 267, 1, 0, 0, 0, 1473, 1474, 5, 149, 0, 0, 1474, 1475, 5,
		136, 0, 0, 1475, 1480, 3, 270, 135, 0, 1476, 1477, 5, 134, 0, 0, 1477,
		1479, 3, 270, 135, 0, 1478, 1476, 1, 0, 0, 0, 1479, 1482, 1, 0, 0, 0, 1480,
		1478, 1, 0, 0, 0, 1480, 1481, 1, 0, 0, 0, 1481, 1483, 1, 0, 0, 0, 1482,
		1480, 1, 0, 0, 0, 1483, 1484, 5, 137, 0, 0, 1484, 269, 1, 0, 0, 0, 1485,
		1486, 3, 336, 168, 0, 1486, 1487, 5, 114, 0, 0, 1487, 1488, 3, 276, 138,
		0, 1488, 271, 1, 0, 0, 0, 1489, 1494, 3, 274, 137, 0, 1490, 1491, 5, 134,
		0, 0, 1491, 1493, 3, 274, 137, 0, 1492, 1490, 1, 0, 0, 0, 1493, 1496, 1,
		0, 0, 0, 1494, 1492, 1, 0, 0, 0, 1494, 1495, 1, 0, 0, 0, 1495, 273, 1,
		0, 0, 0, 1496, 1494, 1, 0, 0, 0, 1497, 1498, 3, 336, 168, 0, 1498, 1499,
		5, 114, 0, 0, 1499, 1500, 3, 276, 138, 0, 1500, 1503, 1, 0, 0, 0, 1501,
		1503, 3, 276, 138, 0, 1502, 1497, 1, 0, 0, 0, 1502, 1501, 1, 0, 0, 0, 1503,
		275, 1, 0, 0, 0, 1504, 1505, 3, 278, 139, 0, 1505, 277, 1, 0, 0, 0, 1506,
		1511, 3, 280, 140, 0, 1507, 1508, 5, 77, 0, 0, 1508, 1510, 3, 280, 140,
		0, 1509, 1507, 1, 0, 0, 0, 1510, 1513, 1, 0, 0, 0, 1511, 1509, 1, 0, 0,
		0, 1511, 1512, 1, 0, 0, 0, 1512, 279, 1, 0, 0, 0, 1513, 1511, 1, 0, 0,
		0, 1514, 1519, 3, 282, 141, 0, 1515, 1516, 5, 76, 0, 0, 1516, 1518, 3,
		282, 141, 0, 1517, 1515, 1, 0, 0, 0, 1518, 1521, 1, 0, 0, 0, 1519, 1517,
		1, 0, 0, 0, 1519, 1520, 1, 0, 0, 0, 1520, 281, 1, 0, 0, 0, 1521, 1519,
		1, 0, 0, 0, 1522, 1523, 5, 78, 0, 0, 1523, 1526, 3, 282, 141, 0, 1524,
		1526, 3, 284, 142, 0, 1525, 1522, 1, 0, 0, 0, 1525, 1524, 1, 0, 0, 0, 1526,
		283, 1, 0, 0, 0, 1527, 1528, 3, 290, 145, 0, 1528, 1529, 3, 286, 143, 0,
		1529, 1530, 3, 290, 145, 0, 1530, 1581, 1, 0, 0, 0, 1531, 1532, 3, 290,
		145, 0, 1532, 1533, 5, 79, 0, 0, 1533, 1534, 5, 136, 0, 0, 1534, 1535,
		3, 290, 145, 0, 1535, 1536, 5, 127, 0, 0, 1536, 1537, 3, 290, 145, 0, 1537,
		1538, 5, 137, 0, 0, 1538, 1581, 1, 0, 0, 0, 1539, 1540, 3, 290, 145, 0,
		1540, 1541, 5, 80, 0, 0, 1541, 1542, 5, 136, 0, 0, 1542, 1543, 3, 290,
		145, 0, 1543, 1544, 5, 127, 0, 0, 1544, 1545, 3, 290, 145, 0, 1545, 1546,
		5, 137, 0, 0, 1546, 1581, 1, 0, 0, 0, 1547, 1548, 3, 290, 145, 0, 1548,
		1549, 5, 81, 0, 0, 1549, 1550, 5, 136, 0, 0, 1550, 1551, 3, 340, 170, 0,
		1551, 1552, 5, 137, 0, 0, 1552, 1581, 1, 0, 0, 0, 1553, 1554, 3, 290, 145,
		0, 1554, 1555, 5, 81, 0, 0, 1555, 1556, 3, 26, 13, 0, 1556, 1581, 1, 0,
		0, 0, 1557, 1558, 3, 290, 145, 0, 1558, 1559, 5, 82, 0, 0, 1559, 1560,
		5, 136, 0, 0, 1560, 1561, 3, 340, 170, 0, 1561, 1562, 5, 137, 0, 0, 1562,
		1581, 1, 0, 0, 0, 1563, 1564, 3, 290, 145, 0, 1564, 1565, 5, 85, 0, 0,
		1565, 1566, 5, 136, 0, 0, 1566, 1567, 3, 340, 170, 0, 1567, 1568, 5, 137,
		0, 0, 1568, 1581, 1, 0, 0, 0, 1569, 1570, 3, 290, 145, 0, 1570, 1571, 5,
		86, 0, 0, 1571, 1572, 5, 136, 0, 0, 1572, 1573, 3, 340, 170, 0, 1573, 1574,
		5, 137, 0, 0, 1574, 1581, 1, 0, 0, 0, 1575, 1576, 3, 290, 145, 0, 1576,
		1577, 3, 288, 144, 0, 1577, 1578, 3, 290, 145, 0, 1578, 1581, 1, 0, 0,
		0, 1579, 1581, 3, 290, 145, 0, 1580, 1527, 1, 0, 0, 0, 1580, 1531, 1, 0,
		0, 0, 1580, 1539, 1, 0, 0, 0, 1580, 1547, 1, 0, 0, 0, 1580, 1553, 1, 0,
		0, 0, 1580, 1557, 1, 0, 0, 0, 1580, 1563, 1, 0, 0, 0, 1580, 1569, 1, 0,
		0, 0, 1580, 1575, 1, 0, 0, 0, 1580, 1579, 1, 0, 0, 0, 1581, 285, 1, 0,
		0, 0, 1582, 1583, 7, 7, 0, 0, 1583, 287, 1, 0, 0, 0, 1584, 1585, 7, 8,
		0, 0, 1585, 289, 1, 0, 0, 0, 1586, 1591, 3, 292, 146, 0, 1587, 1588, 7,
		9, 0, 0, 1588, 1590, 3, 292, 146, 0, 1589, 1587, 1, 0, 0, 0, 1590, 1593,
		1, 0, 0, 0, 1591, 1589, 1, 0, 0, 0, 1591, 1592, 1, 0, 0, 0, 1592, 291,
		1, 0, 0, 0, 1593, 1591, 1, 0, 0, 0, 1594, 1599, 3, 294, 147, 0, 1595, 1596,
		7, 10, 0, 0, 1596, 1598, 3, 294, 147, 0, 1597, 1595, 1, 0, 0, 0, 1598,
		1601, 1, 0, 0, 0, 1599, 1597, 1, 0, 0, 0, 1599, 1600, 1, 0, 0, 0, 1600,
		293, 1, 0, 0, 0, 1601, 1599, 1, 0, 0, 0, 1602, 1603, 5, 123, 0, 0, 1603,
		1608, 3, 294, 147, 0, 1604, 1605, 5, 122, 0, 0, 1605, 1608, 3, 294, 147,
		0, 1606, 1608, 3, 296, 148, 0, 1607, 1602, 1, 0, 0, 0, 1607, 1604, 1, 0,
		0, 0, 1607, 1606, 1, 0, 0, 0, 1608, 295, 1, 0, 0, 0, 1609, 1613, 3, 300,
		150, 0, 1610, 1612, 3, 298, 149, 0, 1611, 1610, 1, 0, 0, 0, 1612, 1615,
		1, 0, 0, 0, 1613, 1611, 1, 0, 0, 0, 1613, 1614, 1, 0, 0, 0, 1614, 297,
		1, 0, 0, 0, 1615, 1613, 1, 0, 0, 0, 1616, 1617, 5, 135, 0, 0, 1617, 1627,
		3, 336, 168, 0, 1618, 1619, 5, 135, 0, 0, 1619, 1627, 3, 302, 151, 0, 1620,
		1621, 5, 138, 0, 0, 1621, 1622, 3, 276, 138, 0, 1622, 1623, 5, 139, 0,
		0, 1623, 1627, 1, 0, 0, 0, 1624, 1625, 5, 130, 0, 0, 1625, 1627, 3, 336,
		168, 0, 1626, 1616, 1, 0, 0, 0, 1626, 1618, 1, 0, 0, 0, 1626, 1620, 1,
		0, 0, 0, 1626, 1624, 1, 0, 0, 0, 1627, 299, 1, 0, 0, 0, 1628, 1648, 3,
		332, 166, 0, 1629, 1648, 3, 336, 168, 0, 1630, 1648, 5, 206, 0, 0, 1631,
		1648, 5, 207, 0, 0, 1632, 1648, 3, 302, 151, 0, 1633, 1634, 5, 136, 0,
		0, 1634, 1635, 3, 276, 138, 0, 1635, 1636, 5, 137, 0, 0, 1636, 1648, 1,
		0, 0, 0, 1637, 1638, 5, 136, 0, 0, 1638, 1639, 3, 22, 11, 0, 1639, 1640,
		5, 137, 0, 0, 1640, 1648, 1, 0, 0, 0, 1641, 1648, 3, 310, 155, 0, 1642,
		1648, 3, 314, 157, 0, 1643, 1648, 3, 316, 158, 0, 1644, 1648, 3, 318, 159,
		0, 1645, 1648, 3, 320, 160, 0, 1646, 1648, 5, 124, 0, 0, 1647, 1628, 1,
		0, 0, 0, 1647, 1629, 1, 0, 0, 0, 1647, 1630, 1, 0, 0, 0, 1647, 1631, 1,
		0, 0, 0, 1647, 1632, 1, 0, 0, 0, 1647, 1633, 1, 0, 0, 0, 1647, 1637, 1,
		0, 0, 0, 1647, 1641, 1, 0, 0, 0, 1647, 1642, 1, 0, 0, 0, 1647, 1643, 1,
		0, 0, 0, 1647, 1644, 1, 0, 0, 0, 1647, 1645, 1, 0, 0, 0, 1647, 1646, 1,
		0, 0, 0, 1648, 301, 1, 0, 0, 0, 1649, 1650, 3, 336, 168, 0, 1650, 1652,
		5, 136, 0, 0, 1651, 1653, 3, 306, 153, 0, 1652, 1651, 1, 0, 0, 0, 1652,
		1653, 1, 0, 0, 0, 1653, 1654, 1, 0, 0, 0, 1654, 1655, 5, 137, 0, 0, 1655,
		1658, 1, 0, 0, 0, 1656, 1658, 3, 304, 152, 0, 1657, 1649, 1, 0, 0, 0, 1657,
		1656, 1, 0, 0, 0, 1658, 303, 1, 0, 0, 0, 1659, 1660, 5, 155, 0, 0, 1660,
		1661, 5, 136, 0, 0, 1661, 1662, 3, 330, 165, 0, 1662, 1663, 5, 137, 0,
		0, 1663, 1681, 1, 0, 0, 0, 1664, 1665, 5, 156, 0, 0, 1665, 1666, 5, 136,
		0, 0, 1666, 1667, 3, 306, 153, 0, 1667, 1668, 5, 137, 0, 0, 1668, 1681,
		1, 0, 0, 0, 1669, 1670, 5, 157, 0, 0, 1670, 1672, 5, 136, 0, 0, 1671, 1673,
		3, 306, 153, 0, 1672, 1671, 1, 0, 0, 0, 1672, 1673, 1, 0, 0, 0, 1673, 1674,
		1, 0, 0, 0, 1674, 1681, 5, 137, 0, 0, 1675, 1676, 5, 158, 0, 0, 1676, 1677,
		5, 136, 0, 0, 1677, 1678, 3, 306, 153, 0, 1678, 1679, 5, 137, 0, 0, 1679,
		1681, 1, 0, 0, 0, 1680, 1659, 1, 0, 0, 0, 1680, 1664, 1, 0, 0, 0, 1680,
		1669, 1, 0, 0, 0, 1680, 1675, 1, 0, 0, 0, 1681, 305, 1, 0, 0, 0, 1682,
		1687, 3, 308, 154, 0, 1683, 1684, 5, 134, 0, 0, 1684, 1686, 3, 308, 154,
		0, 1685, 1683, 1, 0, 0, 0, 1686, 1689, 1, 0, 0, 0, 1687, 1685, 1, 0, 0,
		0, 1687, 1688, 1, 0, 0, 0, 1688, 307, 1, 0, 0, 0, 1689, 1687, 1, 0, 0,
		0, 1690, 1697, 3, 276, 138, 0, 1691, 1692, 3, 336, 168, 0, 1692, 1693,
		5, 114, 0, 0, 1693, 1694, 3, 276, 138, 0, 1694, 1697, 1, 0, 0, 0, 1695,
		1697, 5, 124, 0, 0, 1696, 1690, 1, 0, 0, 0, 1696, 1691, 1, 0, 0, 0, 1696,
		1695, 1, 0, 0, 0, 1697, 309, 1, 0, 0, 0, 1698, 1699, 5, 173, 0, 0, 1699,
		1700, 5, 136, 0, 0, 1700, 1705, 3, 312, 156, 0, 1701, 1702, 5, 134, 0,
		0, 1702, 1704, 3, 312, 156, 0, 1703, 1701, 1, 0, 0, 0, 1704, 1707, 1, 0,
		0, 0, 1705, 1703, 1, 0, 0, 0, 1705, 1706, 1, 0, 0, 0, 1706, 1710, 1, 0,
		0, 0, 1707, 1705, 1, 0, 0, 0, 1708, 1709, 5, 134, 0, 0, 1709, 1711, 3,
		276, 138, 0, 1710, 1708, 1, 0, 0, 0, 1710, 1711, 1, 0, 0, 0, 1711, 1712,
		1, 0, 0, 0, 1712, 1713, 5, 137, 0, 0, 1713, 311, 1, 0, 0, 0, 1714, 1715,
		3, 276, 138, 0, 1715, 1716, 5, 134, 0, 0, 1716, 1717, 3, 276, 138, 0, 1717,
		313, 1, 0, 0, 0, 1718, 1719, 5, 174, 0, 0, 1719, 1720, 5, 136, 0, 0, 1720,
		1721, 3, 276, 138, 0, 1721, 1722, 5, 134, 0, 0, 1722, 1723, 3, 276, 138,
		0, 1723, 1724, 5, 134, 0, 0, 1724, 1725, 3, 276, 138, 0, 1725, 1726, 5,
		137, 0, 0, 1726, 1737, 1, 0, 0, 0, 1727, 1728, 5, 175, 0, 0, 1728, 1729,
		5, 136, 0, 0, 1729, 1730, 3, 276, 138, 0, 1730, 1731, 5, 134, 0, 0, 1731,
		1732, 3, 276, 138, 0, 1732, 1733, 5, 134, 0, 0, 1733, 1734, 3, 276, 138,
		0, 1734, 1735, 5, 137, 0, 0, 1735, 1737, 1, 0, 0, 0, 1736, 1718, 1, 0,
		0, 0, 1736, 1727, 1, 0, 0, 0, 1737, 315, 1, 0, 0, 0, 1738, 1739, 5, 176,
		0, 0, 1739, 1740, 5, 136, 0, 0, 1740, 1741, 3, 22, 11, 0, 1741, 1742, 5,
		137, 0, 0, 1742, 317, 1, 0, 0, 0, 1743, 1744, 5, 177, 0, 0, 1744, 1746,
		5, 136, 0, 0, 1745, 1747, 3, 340, 170, 0, 1746, 1745, 1, 0, 0, 0, 1746,
		1747, 1, 0, 0, 0, 1747, 1748, 1, 0, 0, 0, 1748, 1755, 5, 137, 0, 0, 1749,
		1751, 5, 138, 0, 0, 1750, 1752, 3, 340, 170, 0, 1751, 1750, 1, 0, 0, 0,
		1751, 1752, 1, 0, 0, 0, 1752, 1753, 1, 0, 0, 0, 1753, 1755, 5, 139, 0,
		0, 1754, 1743, 1, 0, 0, 0, 1754, 1749, 1, 0, 0, 0, 1755, 319, 1, 0, 0,
		0, 1756, 1758, 5, 140, 0, 0, 1757, 1759, 3, 322, 161, 0, 1758, 1757, 1,
		0, 0, 0, 1758, 1759, 1, 0, 0, 0, 1759, 1760, 1, 0, 0, 0, 1760, 1761, 5,
		141, 0, 0, 1761, 321, 1, 0, 0, 0, 1762, 1767, 3, 324, 162, 0, 1763, 1764,
		5, 134, 0, 0, 1764, 1766, 3, 324, 162, 0, 1765, 1763, 1, 0, 0, 0, 1766,
		1769, 1, 0, 0, 0, 1767, 1765, 1, 0, 0, 0, 1767, 1768, 1, 0, 0, 0, 1768,
		323, 1, 0, 0, 0, 1769, 1767, 1, 0, 0, 0, 1770, 1771, 3, 276, 138, 0, 1771,
		1772, 5, 133, 0, 0, 1772, 1773, 3, 276, 138, 0, 1773, 1782, 1, 0, 0, 0,
		1774, 1775, 3, 336, 168, 0, 1775, 1776, 5, 133, 0, 0, 1776, 1777, 3, 276,
		138, 0, 1777, 1782, 1, 0, 0, 0, 1778, 1779, 5, 197, 0, 0, 1779, 1780, 5,
		133, 0, 0, 1780, 1782, 3, 276, 138, 0, 1781, 1770, 1, 0, 0, 0, 1781, 1774,
		1, 0, 0, 0, 1781, 1778, 1, 0, 0, 0, 1782, 325, 1, 0, 0, 0, 1783, 1788,
		3, 328, 164, 0, 1784, 1785, 5, 134, 0, 0, 1785, 1787, 3, 328, 164, 0, 1786,
		1784, 1, 0, 0, 0, 1787, 1790, 1, 0, 0, 0, 1788, 1786, 1, 0, 0, 0, 1788,
		1789, 1, 0, 0, 0, 1789, 327, 1, 0, 0, 0, 1790, 1788, 1, 0, 0, 0, 1791,
		1792, 3, 336, 168, 0, 1792, 1793, 5, 133, 0, 0, 1793, 1796, 3, 330, 165,
		0, 1794, 1795, 5, 114, 0, 0, 1795, 1797, 3, 276, 138, 0, 1796, 1794, 1,
		0, 0, 0, 1796, 1797, 1, 0, 0, 0, 1797, 329, 1, 0, 0, 0, 1798, 1811, 5,
		186, 0, 0, 1799, 1811, 5, 187, 0, 0, 1800, 1811, 5, 188, 0, 0, 1801, 1811,
		5, 189, 0, 0, 1802, 1811, 5, 190, 0, 0, 1803, 1811, 5, 191, 0, 0, 1804,
		1811, 5, 192, 0, 0, 1805, 1811, 5, 193, 0, 0, 1806, 1811, 5, 194, 0, 0,
		1807, 1811, 5, 195, 0, 0, 1808, 1811, 5, 196, 0, 0, 1809, 1811, 3, 336,
		168, 0, 1810, 1798, 1, 0, 0, 0, 1810, 1799, 1, 0, 0, 0, 1810, 1800, 1,
		0, 0, 0, 1810, 1801, 1, 0, 0, 0, 1810, 1802, 1, 0, 0, 0, 1810, 1803, 1,
		0, 0, 0, 1810, 1804, 1, 0, 0, 0, 1810, 1805, 1, 0, 0, 0, 1810, 1806, 1,
		0, 0, 0, 1810, 1807, 1, 0, 0, 0, 1810, 1808, 1, 0, 0, 0, 1810, 1809, 1,
		0, 0, 0, 1811, 331, 1, 0, 0, 0, 1812, 1828, 5, 197, 0, 0, 1813, 1828, 5,
		198, 0, 0, 1814, 1828, 5, 199, 0, 0, 1815, 1828, 5, 203, 0, 0, 1816, 1828,
		5, 202, 0, 0, 1817, 1828, 5, 201, 0, 0, 1818, 1828, 5, 204, 0, 0, 1819,
		1828, 5, 200, 0, 0, 1820, 1828, 3, 334, 167, 0, 1821, 1828, 5, 180, 0,
		0, 1822, 1828, 5, 181, 0, 0, 1823, 1828, 5, 182, 0, 0, 1824, 1828, 5, 183,
		0, 0, 1825, 1828, 5, 185, 0, 0, 1826, 1828, 5, 184, 0, 0, 1827, 1812, 1,
		0, 0, 0, 1827, 1813, 1, 0, 0, 0, 1827, 1814, 1, 0, 0, 0, 1827, 1815, 1,
		0, 0, 0, 1827, 1816, 1, 0, 0, 0, 1827, 1817, 1, 0, 0, 0, 1827, 1818, 1,
		0, 0, 0, 1827, 1819, 1, 0, 0, 0, 1827, 1820, 1, 0, 0, 0, 1827, 1821, 1,
		0, 0, 0, 1827, 1822, 1, 0, 0, 0, 1827, 1823, 1, 0, 0, 0, 1827, 1824, 1,
		0, 0, 0, 1827, 1825, 1, 0, 0, 0, 1827, 1826, 1, 0, 0, 0, 1828, 333, 1,
		0, 0, 0, 1829, 1830, 7, 11, 0, 0, 1830, 335, 1, 0, 0, 0, 1831, 1832, 7,
		12, 0, 0, 1832, 337, 1, 0, 0, 0, 1833, 1838, 3, 336, 168, 0, 1834, 1835,
		5, 134, 0, 0, 1835, 1837, 3, 336, 168, 0, 1836, 1834, 1, 0, 0, 0, 1837,
		1840, 1, 0, 0, 0, 1838, 1836, 1, 0, 0, 0, 1838, 1839, 1, 0, 0, 0, 1839,
		339, 1, 0, 0, 0, 1840, 1838, 1, 0, 0, 0, 1841, 1846, 3, 276, 138, 0, 1842,
		1843, 5, 134, 0, 0, 1843, 1845, 3, 276, 138, 0, 1844, 1842, 1, 0, 0, 0,
		1845, 1848, 1, 0, 0, 0, 1846, 1844, 1, 0, 0, 0, 1846, 1847, 1, 0, 0, 0,
		1847, 341, 1, 0, 0, 0, 1848, 1846, 1, 0, 0, 0, 172, 345, 349, 355, 359,
		363, 367, 371, 375, 377, 396, 408, 431, 457, 465, 472, 495, 500, 512, 557,
		564, 571, 584, 602, 609, 615, 621, 628, 642, 649, 664, 674, 676, 680, 685,
		697, 707, 709, 713, 720, 726, 732, 743, 748, 751, 759, 772, 777, 783, 789,
		796, 800, 806, 809, 819, 822, 828, 839, 851, 855, 868, 872, 879, 890, 897,
		905, 909, 919, 925, 935, 939, 945, 949, 953, 962, 970, 972, 981, 988, 1002,
		1013, 1016, 1020, 1032, 1039, 1049, 1060, 1062, 1070, 1081, 1091, 1095,
		1106, 1108, 1115, 1132, 1138, 1146, 1161, 1164, 1182, 1192, 1199, 1207,
		1216, 1224, 1228, 1242, 1249, 1253, 1256, 1262, 1271, 1277, 1285, 1292,
		1298, 1306, 1313, 1322, 1335, 1347, 1362, 1366, 1371, 1377, 1381, 1386,
		1390, 1399, 1403, 1408, 1414, 1422, 1437, 1449, 1452, 1464, 1469, 1480,
		1494, 1502, 1511, 1519, 1525, 1580, 1591, 1599, 1607, 1613, 1626, 1647,
		1652, 1657, 1672, 1680, 1687, 1696, 1705, 1710, 1736, 1746, 1751, 1754,
		1758, 1767, 1781, 1788, 1796, 1810, 1827, 1838, 1846,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// KQLParserInit initializes any static state used to implement KQLParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewKQLParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func KQLParserInit() {
	staticData := &KQLParserParserStaticData
	staticData.once.Do(kqlparserParserInit)
}

// NewKQLParser produces a new parser instance for the optional input antlr.TokenStream.
func NewKQLParser(input antlr.TokenStream) *KQLParser {
	KQLParserInit()
	this := new(KQLParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &KQLParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "KQLParser.g4"

	return this
}

// KQLParser tokens.
const (
	KQLParserEOF                  = antlr.TokenEOF
	KQLParserWHERE                = 1
	KQLParserSEARCH               = 2
	KQLParserFIND                 = 3
	KQLParserTAKE                 = 4
	KQLParserLIMIT                = 5
	KQLParserSAMPLE               = 6
	KQLParserSAMPLE_DISTINCT      = 7
	KQLParserDISTINCT             = 8
	KQLParserCOUNT                = 9
	KQLParserGETSCHEMA            = 10
	KQLParserPROJECT              = 11
	KQLParserPROJECT_AWAY         = 12
	KQLParserPROJECT_KEEP         = 13
	KQLParserPROJECT_RENAME       = 14
	KQLParserPROJECT_REORDER      = 15
	KQLParserEXTEND               = 16
	KQLParserPARSE                = 17
	KQLParserPARSE_WHERE          = 18
	KQLParserPARSE_KV             = 19
	KQLParserSORT                 = 20
	KQLParserORDER                = 21
	KQLParserTOP                  = 22
	KQLParserTOP_NESTED           = 23
	KQLParserTOP_HITTERS          = 24
	KQLParserSUMMARIZE            = 25
	KQLParserMAKE_SERIES          = 26
	KQLParserMAKE_LIST            = 27
	KQLParserMAKE_SET             = 28
	KQLParserJOIN                 = 29
	KQLParserLOOKUP               = 30
	KQLParserUNION                = 31
	KQLParserAS                   = 32
	KQLParserMV_EXPAND            = 33
	KQLParserMV_APPLY             = 34
	KQLParserEVALUATE             = 35
	KQLParserINVOKE               = 36
	KQLParserFACET                = 37
	KQLParserFORK                 = 38
	KQLParserPARTITION            = 39
	KQLParserSCAN                 = 40
	KQLParserSERIALIZE            = 41
	KQLParserRANGE                = 42
	KQLParserPRINT                = 43
	KQLParserRENDER               = 44
	KQLParserCONSUME              = 45
	KQLParserEXTERNALDATA         = 46
	KQLParserMAKE_GRAPH           = 47
	KQLParserGRAPH_MATCH          = 48
	KQLParserGRAPH_SHORTEST_PATHS = 49
	KQLParserGRAPH_TO_TABLE       = 50
	KQLParserLET                  = 51
	KQLParserSET                  = 52
	KQLParserALIAS                = 53
	KQLParserDECLARE              = 54
	KQLParserPATTERN              = 55
	KQLParserRESTRICT             = 56
	KQLParserACCESS               = 57
	KQLParserMATERIALIZE          = 58
	KQLParserKIND                 = 59
	KQLParserHINT_DOT             = 60
	KQLParserINNER                = 61
	KQLParserOUTER                = 62
	KQLParserLEFT                 = 63
	KQLParserRIGHT                = 64
	KQLParserFULL                 = 65
	KQLParserLEFTSEMI             = 66
	KQLParserRIGHTSEMI            = 67
	KQLParserLEFTANTI             = 68
	KQLParserRIGHTANTI            = 69
	KQLParserLEFTOUTER            = 70
	KQLParserRIGHTOUTER           = 71
	KQLParserFULLOUTER            = 72
	KQLParserANTI                 = 73
	KQLParserSEMI                 = 74
	KQLParserINNERUNIQUE          = 75
	KQLParserAND                  = 76
	KQLParserOR                   = 77
	KQLParserNOT                  = 78
	KQLParserBETWEEN              = 79
	KQLParserNOT_BETWEEN          = 80
	KQLParserIN                   = 81
	KQLParserNOT_IN               = 82
	KQLParserIN_CS                = 83
	KQLParserNOT_IN_CS            = 84
	KQLParserHAS_ANY              = 85
	KQLParserHAS_ALL              = 86
	KQLParserCONTAINS             = 87
	KQLParserNOT_CONTAINS         = 88
	KQLParserCONTAINS_CS          = 89
	KQLParserNOT_CONTAINS_CS      = 90
	KQLParserHAS                  = 91
	KQLParserNOT_HAS              = 92
	KQLParserHAS_CS               = 93
	KQLParserNOT_HAS_CS           = 94
	KQLParserHASPREFIX            = 95
	KQLParserNOT_HASPREFIX        = 96
	KQLParserHASPREFIX_CS         = 97
	KQLParserNOT_HASPREFIX_CS     = 98
	KQLParserHASSUFFIX            = 99
	KQLParserNOT_HASSUFFIX        = 100
	KQLParserHASSUFFIX_CS         = 101
	KQLParserNOT_HASSUFFIX_CS     = 102
	KQLParserSTARTSWITH           = 103
	KQLParserNOT_STARTSWITH       = 104
	KQLParserSTARTSWITH_CS        = 105
	KQLParserNOT_STARTSWITH_CS    = 106
	KQLParserENDSWITH             = 107
	KQLParserNOT_ENDSWITH         = 108
	KQLParserENDSWITH_CS          = 109
	KQLParserNOT_ENDSWITH_CS      = 110
	KQLParserMATCHES_REGEX        = 111
	KQLParserMATCHES              = 112
	KQLParserEQ                   = 113
	KQLParserASSIGN               = 114
	KQLParserNEQ                  = 115
	KQLParserLT                   = 116
	KQLParserGT                   = 117
	KQLParserLTE                  = 118
	KQLParserGTE                  = 119
	KQLParserEQTILDE              = 120
	KQLParserNEQTILDE             = 121
	KQLParserPLUS                 = 122
	KQLParserMINUS                = 123
	KQLParserSTAR                 = 124
	KQLParserSLASH                = 125
	KQLParserPERCENT              = 126
	KQLParserDOTDOT               = 127
	KQLParserARROW                = 128
	KQLParserQUESTION             = 129
	KQLParserQUESTIONDOT          = 130
	KQLParserPIPE                 = 131
	KQLParserSEMICOLON            = 132
	KQLParserCOLON                = 133
	KQLParserCOMMA                = 134
	KQLParserDOT                  = 135
	KQLParserLPAREN               = 136
	KQLParserRPAREN               = 137
	KQLParserLBRACKET             = 138
	KQLParserRBRACKET             = 139
	KQLParserLBRACE               = 140
	KQLParserRBRACE               = 141
	KQLParserASC                  = 142
	KQLParserDESC                 = 143
	KQLParserNULLS                = 144
	KQLParserFIRST                = 145
	KQLParserLAST                 = 146
	KQLParserBY                   = 147
	KQLParserON                   = 148
	KQLParserWITH                 = 149
	KQLParserOF                   = 150
	KQLParserTO                   = 151
	KQLParserFROM                 = 152
	KQLParserSTEP                 = 153
	KQLParserDEFAULT              = 154
	KQLParserTYPEOF               = 155
	KQLParserPACK                 = 156
	KQLParserPACK_ALL             = 157
	KQLParserBAG_PACK             = 158
	KQLParserVIEW                 = 159
	KQLParserOTHERS               = 160
	KQLParserDOLLAR               = 161
	KQLParserWITH_SOURCE          = 162
	KQLParserIS_FUZZY             = 163
	KQLParserBAG_EXPANSION        = 164
	KQLParserWITH_ITEMINDEX       = 165
	KQLParserWITH_MATCH_ID        = 166
	KQLParserOUTPUT               = 167
	KQLParserDATA_SCOPE           = 168
	KQLParserDECODEBLOCKS         = 169
	KQLParserNODES                = 170
	KQLParserEDGES                = 171
	KQLParserDATATABLE            = 172
	KQLParserCASE                 = 173
	KQLParserIFF                  = 174
	KQLParserIIF                  = 175
	KQLParserTOSCALAR             = 176
	KQLParserPACK_ARRAY           = 177
	KQLParserTRUE                 = 178
	KQLParserFALSE                = 179
	KQLParserNULL                 = 180
	KQLParserDATETIME_LITERAL     = 181
	KQLParserTIMESPAN_LITERAL     = 182
	KQLParserTIMESPAN_SHORT       = 183
	KQLParserDYNAMIC_LITERAL      = 184
	KQLParserGUID_LITERAL         = 185
	KQLParserTYPE_BOOL            = 186
	KQLParserTYPE_DATETIME        = 187
	KQLParserTYPE_DECIMAL         = 188
	KQLParserTYPE_DOUBLE          = 189
	KQLParserTYPE_DYNAMIC         = 190
	KQLParserTYPE_GUID            = 191
	KQLParserTYPE_INT             = 192
	KQLParserTYPE_LONG            = 193
	KQLParserTYPE_REAL            = 194
	KQLParserTYPE_STRING          = 195
	KQLParserTYPE_TIMESPAN        = 196
	KQLParserSTRING_LITERAL       = 197
	KQLParserVERBATIM_STRING      = 198
	KQLParserMULTILINE_STRING     = 199
	KQLParserHEX_NUMBER           = 200
	KQLParserREAL_NUMBER          = 201
	KQLParserLONG_NUMBER          = 202
	KQLParserINT_NUMBER           = 203
	KQLParserDECIMAL_NUMBER       = 204
	KQLParserIDENTIFIER           = 205
	KQLParserQUOTED_IDENTIFIER    = 206
	KQLParserCLIENT_PARAMETER     = 207
	KQLParserLINE_COMMENT         = 208
	KQLParserBLOCK_COMMENT        = 209
	KQLParserWS                   = 210
	KQLParserERROR_CHAR           = 211
)

// KQLParser rules.
const (
	KQLParserRULE_query                      = 0
	KQLParserRULE_statement                  = 1
	KQLParserRULE_letStatement               = 2
	KQLParserRULE_setStatement               = 3
	KQLParserRULE_aliasStatement             = 4
	KQLParserRULE_declareStatement           = 5
	KQLParserRULE_patternStatement           = 6
	KQLParserRULE_restrictStatement          = 7
	KQLParserRULE_viewExpression             = 8
	KQLParserRULE_patternDefinition          = 9
	KQLParserRULE_patternParam               = 10
	KQLParserRULE_tabularExpression          = 11
	KQLParserRULE_tabularSource              = 12
	KQLParserRULE_tableName                  = 13
	KQLParserRULE_databaseTableName          = 14
	KQLParserRULE_materializeExpression      = 15
	KQLParserRULE_tabularOperator            = 16
	KQLParserRULE_whereOperator              = 17
	KQLParserRULE_searchOperator             = 18
	KQLParserRULE_searchKind                 = 19
	KQLParserRULE_tableList                  = 20
	KQLParserRULE_projectOperator            = 21
	KQLParserRULE_projectAwayOperator        = 22
	KQLParserRULE_projectKeepOperator        = 23
	KQLParserRULE_projectRenameOperator      = 24
	KQLParserRULE_projectReorderOperator     = 25
	KQLParserRULE_projectItemList            = 26
	KQLParserRULE_projectItem                = 27
	KQLParserRULE_identifierOrWildcardList   = 28
	KQLParserRULE_identifierOrWildcard       = 29
	KQLParserRULE_renameList                 = 30
	KQLParserRULE_renameItem                 = 31
	KQLParserRULE_extendOperator             = 32
	KQLParserRULE_extendItemList             = 33
	KQLParserRULE_extendItem                 = 34
	KQLParserRULE_summarizeOperator          = 35
	KQLParserRULE_summarizeHints             = 36
	KQLParserRULE_aggregationList            = 37
	KQLParserRULE_aggregationItem            = 38
	KQLParserRULE_aggregationFunction        = 39
	KQLParserRULE_groupByList                = 40
	KQLParserRULE_groupByItem                = 41
	KQLParserRULE_sortOperator               = 42
	KQLParserRULE_sortList                   = 43
	KQLParserRULE_sortItem                   = 44
	KQLParserRULE_sortDirection              = 45
	KQLParserRULE_nullsPosition              = 46
	KQLParserRULE_topOperator                = 47
	KQLParserRULE_topNestedOperator          = 48
	KQLParserRULE_topNestedClause            = 49
	KQLParserRULE_takeOperator               = 50
	KQLParserRULE_distinctOperator           = 51
	KQLParserRULE_distinctColumns            = 52
	KQLParserRULE_countOperator              = 53
	KQLParserRULE_joinOperator               = 54
	KQLParserRULE_joinKind                   = 55
	KQLParserRULE_joinFlavor                 = 56
	KQLParserRULE_joinHints                  = 57
	KQLParserRULE_joinHint                   = 58
	KQLParserRULE_joinCondition              = 59
	KQLParserRULE_joinAttribute              = 60
	KQLParserRULE_unionOperator              = 61
	KQLParserRULE_unionParameters            = 62
	KQLParserRULE_unionParameter             = 63
	KQLParserRULE_unionTables                = 64
	KQLParserRULE_unionTable                 = 65
	KQLParserRULE_lookupOperator             = 66
	KQLParserRULE_lookupKind                 = 67
	KQLParserRULE_lookupCondition            = 68
	KQLParserRULE_parseOperator              = 69
	KQLParserRULE_parseKind                  = 70
	KQLParserRULE_parsePattern               = 71
	KQLParserRULE_parsePatternItem           = 72
	KQLParserRULE_parseKvOperator            = 73
	KQLParserRULE_kvPairList                 = 74
	KQLParserRULE_kvPair                     = 75
	KQLParserRULE_parseKvParameters          = 76
	KQLParserRULE_parseKvParam               = 77
	KQLParserRULE_mvExpandOperator           = 78
	KQLParserRULE_mvExpandKind               = 79
	KQLParserRULE_mvExpandParams             = 80
	KQLParserRULE_mvExpandItemList           = 81
	KQLParserRULE_mvExpandItem               = 82
	KQLParserRULE_limitClause                = 83
	KQLParserRULE_mvApplyOperator            = 84
	KQLParserRULE_mvApplyItemList            = 85
	KQLParserRULE_mvApplyItem                = 86
	KQLParserRULE_mvApplyOnClause            = 87
	KQLParserRULE_evaluateOperator           = 88
	KQLParserRULE_evaluateHints              = 89
	KQLParserRULE_facetOperator              = 90
	KQLParserRULE_forkOperator               = 91
	KQLParserRULE_forkBranch                 = 92
	KQLParserRULE_partitionOperator          = 93
	KQLParserRULE_partitionHints             = 94
	KQLParserRULE_scanOperator               = 95
	KQLParserRULE_scanParams                 = 96
	KQLParserRULE_scanDeclare                = 97
	KQLParserRULE_scanDeclareItem            = 98
	KQLParserRULE_scanStepList               = 99
	KQLParserRULE_scanStep                   = 100
	KQLParserRULE_scanAction                 = 101
	KQLParserRULE_serializeOperator          = 102
	KQLParserRULE_sampleOperator             = 103
	KQLParserRULE_sampleDistinctOperator     = 104
	KQLParserRULE_makeSeriesOperator         = 105
	KQLParserRULE_makeSeriesItemList         = 106
	KQLParserRULE_makeSeriesItem             = 107
	KQLParserRULE_makeSeriesOnClause         = 108
	KQLParserRULE_makeSeriesParams           = 109
	KQLParserRULE_findOperator               = 110
	KQLParserRULE_findParams                 = 111
	KQLParserRULE_getschemaOperator          = 112
	KQLParserRULE_renderOperator             = 113
	KQLParserRULE_renderProperties           = 114
	KQLParserRULE_renderProperty             = 115
	KQLParserRULE_consumeOperator            = 116
	KQLParserRULE_invokeOperator             = 117
	KQLParserRULE_asOperator                 = 118
	KQLParserRULE_graphOperator              = 119
	KQLParserRULE_makeGraphOperator          = 120
	KQLParserRULE_graphMatchOperator         = 121
	KQLParserRULE_graphPattern               = 122
	KQLParserRULE_graphPatternElement        = 123
	KQLParserRULE_graphEdge                  = 124
	KQLParserRULE_graphShortestPathsOperator = 125
	KQLParserRULE_graphToTableOperator       = 126
	KQLParserRULE_graphToTableParams         = 127
	KQLParserRULE_datatable                  = 128
	KQLParserRULE_datatableSchema            = 129
	KQLParserRULE_datatableColumn            = 130
	KQLParserRULE_datatableRows              = 131
	KQLParserRULE_externalData               = 132
	KQLParserRULE_externalDataUri            = 133
	KQLParserRULE_externalDataOptions        = 134
	KQLParserRULE_externalDataOption         = 135
	KQLParserRULE_printArgList               = 136
	KQLParserRULE_printArg                   = 137
	KQLParserRULE_expression                 = 138
	KQLParserRULE_orExpression               = 139
	KQLParserRULE_andExpression              = 140
	KQLParserRULE_notExpression              = 141
	KQLParserRULE_comparisonExpression       = 142
	KQLParserRULE_comparisonOperator         = 143
	KQLParserRULE_stringOperator             = 144
	KQLParserRULE_additiveExpression         = 145
	KQLParserRULE_multiplicativeExpression   = 146
	KQLParserRULE_unaryExpression            = 147
	KQLParserRULE_postfixExpression          = 148
	KQLParserRULE_postfixOperator            = 149
	KQLParserRULE_primaryExpression          = 150
	KQLParserRULE_functionCall               = 151
	KQLParserRULE_builtinFunction            = 152
	KQLParserRULE_argumentList               = 153
	KQLParserRULE_argument                   = 154
	KQLParserRULE_caseExpression             = 155
	KQLParserRULE_caseBranch                 = 156
	KQLParserRULE_iffExpression              = 157
	KQLParserRULE_toScalarExpression         = 158
	KQLParserRULE_arrayExpression            = 159
	KQLParserRULE_objectExpression           = 160
	KQLParserRULE_objectPropertyList         = 161
	KQLParserRULE_objectProperty             = 162
	KQLParserRULE_functionParameters         = 163
	KQLParserRULE_functionParameter          = 164
	KQLParserRULE_typeSpecifier              = 165
	KQLParserRULE_literal                    = 166
	KQLParserRULE_booleanLiteral             = 167
	KQLParserRULE_identifier                 = 168
	KQLParserRULE_identifierList             = 169
	KQLParserRULE_expressionList             = 170
)

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	TabularExpression() ITabularExpressionContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) EOF() antlr.TerminalNode {
	return s.GetToken(KQLParserEOF, 0)
}

func (s *QueryContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *QueryContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *QueryContext) TabularExpression() ITabularExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabularExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabularExpressionContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (s *QueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, KQLParserRULE_query)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(345)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(342)
				p.Statement()
			}

		}
		p.SetState(347)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-717147641897974389) != 0) || ((int64((_la-136)) & ^0x3f) == 0 && ((int64(1)<<(_la-136))&2304730372174248129) != 0) || _la == KQLParserIDENTIFIER || _la == KQLParserQUOTED_IDENTIFIER {
		{
			p.SetState(348)
			p.TabularExpression()
		}

	}
	{
		p.SetState(351)
		p.Match(KQLParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LetStatement() ILetStatementContext
	SEMICOLON() antlr.TerminalNode
	SetStatement() ISetStatementContext
	AliasStatement() IAliasStatementContext
	DeclareStatement() IDeclareStatementContext
	PatternStatement() IPatternStatementContext
	RestrictStatement() IRestrictStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) LetStatement() ILetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetStatementContext)
}

func (s *StatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KQLParserSEMICOLON, 0)
}

func (s *StatementContext) SetStatement() ISetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatementContext)
}

func (s *StatementContext) AliasStatement() IAliasStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasStatementContext)
}

func (s *StatementContext) DeclareStatement() IDeclareStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclareStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclareStatementContext)
}

func (s *StatementContext) PatternStatement() IPatternStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternStatementContext)
}

func (s *StatementContext) RestrictStatement() IRestrictStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestrictStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestrictStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, KQLParserRULE_statement)
	var _la int

	p.SetState(377)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KQLParserLET:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(353)
			p.LetStatement()
		}
		p.SetState(355)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserSEMICOLON {
			{
				p.SetState(354)
				p.Match(KQLParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case KQLParserSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(357)
			p.SetStatement()
		}
		p.SetState(359)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserSEMICOLON {
			{
				p.SetState(358)
				p.Match(KQLParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case KQLParserALIAS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(361)
			p.AliasStatement()
		}
		p.SetState(363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserSEMICOLON {
			{
				p.SetState(362)
				p.Match(KQLParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case KQLParserDECLARE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(365)
			p.DeclareStatement()
		}
		p.SetState(367)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserSEMICOLON {
			{
				p.SetState(366)
				p.Match(KQLParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case KQLParserPATTERN:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(369)
			p.PatternStatement()
		}
		p.SetState(371)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserSEMICOLON {
			{
				p.SetState(370)
				p.Match(KQLParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case KQLParserRESTRICT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(373)
			p.RestrictStatement()
		}
		p.SetState(375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserSEMICOLON {
			{
				p.SetState(374)
				p.Match(KQLParserSEMICOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILetStatementContext is an interface to support dynamic dispatch.
type ILetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LET() antlr.TerminalNode
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext
	LBRACE() antlr.TerminalNode
	TabularExpression() ITabularExpressionContext
	RBRACE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	FunctionParameters() IFunctionParametersContext
	ViewExpression() IViewExpressionContext

	// IsLetStatementContext differentiates from other interfaces.
	IsLetStatementContext()
}

type LetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetStatementContext() *LetStatementContext {
	var p = new(LetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_letStatement
	return p
}

func InitEmptyLetStatementContext(p *LetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_letStatement
}

func (*LetStatementContext) IsLetStatementContext() {}

func NewLetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetStatementContext {
	var p = new(LetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_letStatement

	return p
}

func (s *LetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LetStatementContext) LET() antlr.TerminalNode {
	return s.GetToken(KQLParserLET, 0)
}

func (s *LetStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LetStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *LetStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LetStatementContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(KQLParserLBRACE, 0)
}

func (s *LetStatementContext) TabularExpression() ITabularExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabularExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabularExpressionContext)
}

func (s *LetStatementContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(KQLParserRBRACE, 0)
}

func (s *LetStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *LetStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *LetStatementContext) FunctionParameters() IFunctionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionParametersContext)
}

func (s *LetStatementContext) ViewExpression() IViewExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewExpressionContext)
}

func (s *LetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterLetStatement(s)
	}
}

func (s *LetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitLetStatement(s)
	}
}

func (s *LetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitLetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) LetStatement() (localctx ILetStatementContext) {
	localctx = NewLetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, KQLParserRULE_letStatement)
	var _la int

	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(379)
			p.Match(KQLParserLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(380)
			p.Identifier()
		}
		{
			p.SetState(381)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(382)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(384)
			p.Match(KQLParserLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(385)
			p.Identifier()
		}
		{
			p.SetState(386)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(387)
			p.Match(KQLParserLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(388)
			p.TabularExpression()
		}
		{
			p.SetState(389)
			p.Match(KQLParserRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(391)
			p.Match(KQLParserLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(392)
			p.Identifier()
		}
		{
			p.SetState(393)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(394)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(396)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-861298014345919093) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&-9187360625863417885) != 0) {
			{
				p.SetState(395)
				p.FunctionParameters()
			}

		}
		{
			p.SetState(398)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(399)
			p.Match(KQLParserLBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(400)
			p.TabularExpression()
		}
		{
			p.SetState(401)
			p.Match(KQLParserRBRACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(403)
			p.Match(KQLParserLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(404)
			p.Identifier()
		}
		{
			p.SetState(405)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(406)
			p.ViewExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetStatementContext is an interface to support dynamic dispatch.
type ISetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	Identifier() IIdentifierContext
	Expression() IExpressionContext
	ASSIGN() antlr.TerminalNode
	EQ() antlr.TerminalNode

	// IsSetStatementContext differentiates from other interfaces.
	IsSetStatementContext()
}

type SetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementContext() *SetStatementContext {
	var p = new(SetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_setStatement
	return p
}

func InitEmptySetStatementContext(p *SetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_setStatement
}

func (*SetStatementContext) IsSetStatementContext() {}

func NewSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementContext {
	var p = new(SetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_setStatement

	return p
}

func (s *SetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(KQLParserSET, 0)
}

func (s *SetStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *SetStatementContext) EQ() antlr.TerminalNode {
	return s.GetToken(KQLParserEQ, 0)
}

func (s *SetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterSetStatement(s)
	}
}

func (s *SetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitSetStatement(s)
	}
}

func (s *SetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitSetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) SetStatement() (localctx ISetStatementContext) {
	localctx = NewSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, KQLParserRULE_setStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(410)
		p.Match(KQLParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(411)
		p.Identifier()
	}
	{
		p.SetState(412)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KQLParserEQ || _la == KQLParserASSIGN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(413)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasStatementContext is an interface to support dynamic dispatch.
type IAliasStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALIAS() antlr.TerminalNode
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsAliasStatementContext differentiates from other interfaces.
	IsAliasStatementContext()
}

type AliasStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasStatementContext() *AliasStatementContext {
	var p = new(AliasStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_aliasStatement
	return p
}

func InitEmptyAliasStatementContext(p *AliasStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_aliasStatement
}

func (*AliasStatementContext) IsAliasStatementContext() {}

func NewAliasStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasStatementContext {
	var p = new(AliasStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_aliasStatement

	return p
}

func (s *AliasStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasStatementContext) ALIAS() antlr.TerminalNode {
	return s.GetToken(KQLParserALIAS, 0)
}

func (s *AliasStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AliasStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *AliasStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AliasStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterAliasStatement(s)
	}
}

func (s *AliasStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitAliasStatement(s)
	}
}

func (s *AliasStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitAliasStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) AliasStatement() (localctx IAliasStatementContext) {
	localctx = NewAliasStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, KQLParserRULE_aliasStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(415)
		p.Match(KQLParserALIAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(416)
		p.Identifier()
	}
	{
		p.SetState(417)
		p.Match(KQLParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(418)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclareStatementContext is an interface to support dynamic dispatch.
type IDeclareStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	PATTERN() antlr.TerminalNode
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	PatternDefinition() IPatternDefinitionContext
	COLON() antlr.TerminalNode
	TypeSpecifier() ITypeSpecifierContext

	// IsDeclareStatementContext differentiates from other interfaces.
	IsDeclareStatementContext()
}

type DeclareStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclareStatementContext() *DeclareStatementContext {
	var p = new(DeclareStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_declareStatement
	return p
}

func InitEmptyDeclareStatementContext(p *DeclareStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_declareStatement
}

func (*DeclareStatementContext) IsDeclareStatementContext() {}

func NewDeclareStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclareStatementContext {
	var p = new(DeclareStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_declareStatement

	return p
}

func (s *DeclareStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclareStatementContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(KQLParserDECLARE, 0)
}

func (s *DeclareStatementContext) PATTERN() antlr.TerminalNode {
	return s.GetToken(KQLParserPATTERN, 0)
}

func (s *DeclareStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DeclareStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *DeclareStatementContext) PatternDefinition() IPatternDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternDefinitionContext)
}

func (s *DeclareStatementContext) COLON() antlr.TerminalNode {
	return s.GetToken(KQLParserCOLON, 0)
}

func (s *DeclareStatementContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *DeclareStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclareStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclareStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterDeclareStatement(s)
	}
}

func (s *DeclareStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitDeclareStatement(s)
	}
}

func (s *DeclareStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitDeclareStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) DeclareStatement() (localctx IDeclareStatementContext) {
	localctx = NewDeclareStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, KQLParserRULE_declareStatement)
	p.SetState(431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(420)
			p.Match(KQLParserDECLARE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(421)
			p.Match(KQLParserPATTERN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(422)
			p.Identifier()
		}
		{
			p.SetState(423)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(424)
			p.PatternDefinition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(426)
			p.Match(KQLParserDECLARE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(427)
			p.Identifier()
		}
		{
			p.SetState(428)
			p.Match(KQLParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(429)
			p.TypeSpecifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternStatementContext is an interface to support dynamic dispatch.
type IPatternStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PATTERN() antlr.TerminalNode
	Identifier() IIdentifierContext
	PatternDefinition() IPatternDefinitionContext

	// IsPatternStatementContext differentiates from other interfaces.
	IsPatternStatementContext()
}

type PatternStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternStatementContext() *PatternStatementContext {
	var p = new(PatternStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_patternStatement
	return p
}

func InitEmptyPatternStatementContext(p *PatternStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_patternStatement
}

func (*PatternStatementContext) IsPatternStatementContext() {}

func NewPatternStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternStatementContext {
	var p = new(PatternStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_patternStatement

	return p
}

func (s *PatternStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternStatementContext) PATTERN() antlr.TerminalNode {
	return s.GetToken(KQLParserPATTERN, 0)
}

func (s *PatternStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PatternStatementContext) PatternDefinition() IPatternDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternDefinitionContext)
}

func (s *PatternStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterPatternStatement(s)
	}
}

func (s *PatternStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitPatternStatement(s)
	}
}

func (s *PatternStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitPatternStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) PatternStatement() (localctx IPatternStatementContext) {
	localctx = NewPatternStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, KQLParserRULE_patternStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(433)
		p.Match(KQLParserPATTERN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(434)
		p.Identifier()
	}
	{
		p.SetState(435)
		p.PatternDefinition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRestrictStatementContext is an interface to support dynamic dispatch.
type IRestrictStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESTRICT() antlr.TerminalNode
	ACCESS() antlr.TerminalNode
	TO() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	RPAREN() antlr.TerminalNode

	// IsRestrictStatementContext differentiates from other interfaces.
	IsRestrictStatementContext()
}

type RestrictStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRestrictStatementContext() *RestrictStatementContext {
	var p = new(RestrictStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_restrictStatement
	return p
}

func InitEmptyRestrictStatementContext(p *RestrictStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_restrictStatement
}

func (*RestrictStatementContext) IsRestrictStatementContext() {}

func NewRestrictStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RestrictStatementContext {
	var p = new(RestrictStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_restrictStatement

	return p
}

func (s *RestrictStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RestrictStatementContext) RESTRICT() antlr.TerminalNode {
	return s.GetToken(KQLParserRESTRICT, 0)
}

func (s *RestrictStatementContext) ACCESS() antlr.TerminalNode {
	return s.GetToken(KQLParserACCESS, 0)
}

func (s *RestrictStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(KQLParserTO, 0)
}

func (s *RestrictStatementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *RestrictStatementContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *RestrictStatementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *RestrictStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestrictStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RestrictStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterRestrictStatement(s)
	}
}

func (s *RestrictStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitRestrictStatement(s)
	}
}

func (s *RestrictStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitRestrictStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) RestrictStatement() (localctx IRestrictStatementContext) {
	localctx = NewRestrictStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, KQLParserRULE_restrictStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(437)
		p.Match(KQLParserRESTRICT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(438)
		p.Match(KQLParserACCESS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(439)
		p.Match(KQLParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(440)
		p.Match(KQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(441)
		p.IdentifierList()
	}
	{
		p.SetState(442)
		p.Match(KQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IViewExpressionContext is an interface to support dynamic dispatch.
type IViewExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VIEW() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	TabularExpression() ITabularExpressionContext
	RBRACE() antlr.TerminalNode

	// IsViewExpressionContext differentiates from other interfaces.
	IsViewExpressionContext()
}

type ViewExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewExpressionContext() *ViewExpressionContext {
	var p = new(ViewExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_viewExpression
	return p
}

func InitEmptyViewExpressionContext(p *ViewExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_viewExpression
}

func (*ViewExpressionContext) IsViewExpressionContext() {}

func NewViewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewExpressionContext {
	var p = new(ViewExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_viewExpression

	return p
}

func (s *ViewExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewExpressionContext) VIEW() antlr.TerminalNode {
	return s.GetToken(KQLParserVIEW, 0)
}

func (s *ViewExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *ViewExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *ViewExpressionContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(KQLParserLBRACE, 0)
}

func (s *ViewExpressionContext) TabularExpression() ITabularExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabularExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabularExpressionContext)
}

func (s *ViewExpressionContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(KQLParserRBRACE, 0)
}

func (s *ViewExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterViewExpression(s)
	}
}

func (s *ViewExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitViewExpression(s)
	}
}

func (s *ViewExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitViewExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ViewExpression() (localctx IViewExpressionContext) {
	localctx = NewViewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, KQLParserRULE_viewExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(444)
		p.Match(KQLParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(445)
		p.Match(KQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(446)
		p.Match(KQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(447)
		p.Match(KQLParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(448)
		p.TabularExpression()
	}
	{
		p.SetState(449)
		p.Match(KQLParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternDefinitionContext is an interface to support dynamic dispatch.
type IPatternDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllPatternParam() []IPatternParamContext
	PatternParam(i int) IPatternParamContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPatternDefinitionContext differentiates from other interfaces.
	IsPatternDefinitionContext()
}

type PatternDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternDefinitionContext() *PatternDefinitionContext {
	var p = new(PatternDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_patternDefinition
	return p
}

func InitEmptyPatternDefinitionContext(p *PatternDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_patternDefinition
}

func (*PatternDefinitionContext) IsPatternDefinitionContext() {}

func NewPatternDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternDefinitionContext {
	var p = new(PatternDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_patternDefinition

	return p
}

func (s *PatternDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternDefinitionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *PatternDefinitionContext) AllPatternParam() []IPatternParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPatternParamContext); ok {
			len++
		}
	}

	tst := make([]IPatternParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPatternParamContext); ok {
			tst[i] = t.(IPatternParamContext)
			i++
		}
	}

	return tst
}

func (s *PatternDefinitionContext) PatternParam(i int) IPatternParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPatternParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPatternParamContext)
}

func (s *PatternDefinitionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *PatternDefinitionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *PatternDefinitionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *PatternDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterPatternDefinition(s)
	}
}

func (s *PatternDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitPatternDefinition(s)
	}
}

func (s *PatternDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitPatternDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) PatternDefinition() (localctx IPatternDefinitionContext) {
	localctx = NewPatternDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, KQLParserRULE_patternDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		p.Match(KQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(452)
		p.PatternParam()
	}
	p.SetState(457)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(453)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(454)
			p.PatternParam()
		}

		p.SetState(459)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(460)
		p.Match(KQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPatternParamContext is an interface to support dynamic dispatch.
type IPatternParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	TypeSpecifier() ITypeSpecifierContext

	// IsPatternParamContext differentiates from other interfaces.
	IsPatternParamContext()
}

type PatternParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPatternParamContext() *PatternParamContext {
	var p = new(PatternParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_patternParam
	return p
}

func InitEmptyPatternParamContext(p *PatternParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_patternParam
}

func (*PatternParamContext) IsPatternParamContext() {}

func NewPatternParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PatternParamContext {
	var p = new(PatternParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_patternParam

	return p
}

func (s *PatternParamContext) GetParser() antlr.Parser { return s.parser }

func (s *PatternParamContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PatternParamContext) COLON() antlr.TerminalNode {
	return s.GetToken(KQLParserCOLON, 0)
}

func (s *PatternParamContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *PatternParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PatternParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PatternParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterPatternParam(s)
	}
}

func (s *PatternParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitPatternParam(s)
	}
}

func (s *PatternParamContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitPatternParam(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) PatternParam() (localctx IPatternParamContext) {
	localctx = NewPatternParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, KQLParserRULE_patternParam)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(462)
		p.Identifier()
	}
	p.SetState(465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserCOLON {
		{
			p.SetState(463)
			p.Match(KQLParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(464)
			p.TypeSpecifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITabularExpressionContext is an interface to support dynamic dispatch.
type ITabularExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TabularSource() ITabularSourceContext
	AllPIPE() []antlr.TerminalNode
	PIPE(i int) antlr.TerminalNode
	AllTabularOperator() []ITabularOperatorContext
	TabularOperator(i int) ITabularOperatorContext

	// IsTabularExpressionContext differentiates from other interfaces.
	IsTabularExpressionContext()
}

type TabularExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTabularExpressionContext() *TabularExpressionContext {
	var p = new(TabularExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_tabularExpression
	return p
}

func InitEmptyTabularExpressionContext(p *TabularExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_tabularExpression
}

func (*TabularExpressionContext) IsTabularExpressionContext() {}

func NewTabularExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabularExpressionContext {
	var p = new(TabularExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_tabularExpression

	return p
}

func (s *TabularExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TabularExpressionContext) TabularSource() ITabularSourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabularSourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabularSourceContext)
}

func (s *TabularExpressionContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(KQLParserPIPE)
}

func (s *TabularExpressionContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserPIPE, i)
}

func (s *TabularExpressionContext) AllTabularOperator() []ITabularOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITabularOperatorContext); ok {
			len++
		}
	}

	tst := make([]ITabularOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITabularOperatorContext); ok {
			tst[i] = t.(ITabularOperatorContext)
			i++
		}
	}

	return tst
}

func (s *TabularExpressionContext) TabularOperator(i int) ITabularOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabularOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabularOperatorContext)
}

func (s *TabularExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabularExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TabularExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterTabularExpression(s)
	}
}

func (s *TabularExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitTabularExpression(s)
	}
}

func (s *TabularExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitTabularExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) TabularExpression() (localctx ITabularExpressionContext) {
	localctx = NewTabularExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, KQLParserRULE_tabularExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(467)
		p.TabularSource()
	}
	p.SetState(472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserPIPE {
		{
			p.SetState(468)
			p.Match(KQLParserPIPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(469)
			p.TabularOperator()
		}

		p.SetState(474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITabularSourceContext is an interface to support dynamic dispatch.
type ITabularSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableName() ITableNameContext
	FunctionCall() IFunctionCallContext
	LPAREN() antlr.TerminalNode
	TabularExpression() ITabularExpressionContext
	RPAREN() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	Identifier() IIdentifierContext
	FROM() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	TO() antlr.TerminalNode
	STEP() antlr.TerminalNode
	PRINT() antlr.TerminalNode
	PrintArgList() IPrintArgListContext
	Datatable() IDatatableContext
	ExternalData() IExternalDataContext
	MaterializeExpression() IMaterializeExpressionContext

	// IsTabularSourceContext differentiates from other interfaces.
	IsTabularSourceContext()
}

type TabularSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTabularSourceContext() *TabularSourceContext {
	var p = new(TabularSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_tabularSource
	return p
}

func InitEmptyTabularSourceContext(p *TabularSourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_tabularSource
}

func (*TabularSourceContext) IsTabularSourceContext() {}

func NewTabularSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabularSourceContext {
	var p = new(TabularSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_tabularSource

	return p
}

func (s *TabularSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *TabularSourceContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TabularSourceContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *TabularSourceContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *TabularSourceContext) TabularExpression() ITabularExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabularExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabularExpressionContext)
}

func (s *TabularSourceContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *TabularSourceContext) RANGE() antlr.TerminalNode {
	return s.GetToken(KQLParserRANGE, 0)
}

func (s *TabularSourceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TabularSourceContext) FROM() antlr.TerminalNode {
	return s.GetToken(KQLParserFROM, 0)
}

func (s *TabularSourceContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TabularSourceContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TabularSourceContext) TO() antlr.TerminalNode {
	return s.GetToken(KQLParserTO, 0)
}

func (s *TabularSourceContext) STEP() antlr.TerminalNode {
	return s.GetToken(KQLParserSTEP, 0)
}

func (s *TabularSourceContext) PRINT() antlr.TerminalNode {
	return s.GetToken(KQLParserPRINT, 0)
}

func (s *TabularSourceContext) PrintArgList() IPrintArgListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrintArgListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrintArgListContext)
}

func (s *TabularSourceContext) Datatable() IDatatableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatatableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatatableContext)
}

func (s *TabularSourceContext) ExternalData() IExternalDataContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternalDataContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternalDataContext)
}

func (s *TabularSourceContext) MaterializeExpression() IMaterializeExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializeExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializeExpressionContext)
}

func (s *TabularSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabularSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TabularSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterTabularSource(s)
	}
}

func (s *TabularSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitTabularSource(s)
	}
}

func (s *TabularSourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitTabularSource(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) TabularSource() (localctx ITabularSourceContext) {
	localctx = NewTabularSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, KQLParserRULE_tabularSource)
	p.SetState(495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 15, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(475)
			p.TableName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(476)
			p.FunctionCall()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(477)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(478)
			p.TabularExpression()
		}
		{
			p.SetState(479)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(481)
			p.Match(KQLParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(482)
			p.Identifier()
		}
		{
			p.SetState(483)
			p.Match(KQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(484)
			p.Expression()
		}
		{
			p.SetState(485)
			p.Match(KQLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(486)
			p.Expression()
		}
		{
			p.SetState(487)
			p.Match(KQLParserSTEP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(488)
			p.Expression()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(490)
			p.Match(KQLParserPRINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(491)
			p.PrintArgList()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(492)
			p.Datatable()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(493)
			p.ExternalData()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(494)
			p.MaterializeExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DatabaseTableName() IDatabaseTableNameContext
	Identifier() IIdentifierContext
	QUOTED_IDENTIFIER() antlr.TerminalNode

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_tableName
	return p
}

func InitEmptyTableNameContext(p *TableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_tableName
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) DatabaseTableName() IDatabaseTableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatabaseTableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatabaseTableNameContext)
}

func (s *TableNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableNameContext) QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KQLParserQUOTED_IDENTIFIER, 0)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) TableName() (localctx ITableNameContext) {
	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, KQLParserRULE_tableName)
	p.SetState(500)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(497)
			p.DatabaseTableName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(498)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(499)
			p.Match(KQLParserQUOTED_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatabaseTableNameContext is an interface to support dynamic dispatch.
type IDatabaseTableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode

	// IsDatabaseTableNameContext differentiates from other interfaces.
	IsDatabaseTableNameContext()
}

type DatabaseTableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatabaseTableNameContext() *DatabaseTableNameContext {
	var p = new(DatabaseTableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_databaseTableName
	return p
}

func InitEmptyDatabaseTableNameContext(p *DatabaseTableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_databaseTableName
}

func (*DatabaseTableNameContext) IsDatabaseTableNameContext() {}

func NewDatabaseTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatabaseTableNameContext {
	var p = new(DatabaseTableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_databaseTableName

	return p
}

func (s *DatabaseTableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DatabaseTableNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DatabaseTableNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DatabaseTableNameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(KQLParserDOT)
}

func (s *DatabaseTableNameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserDOT, i)
}

func (s *DatabaseTableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatabaseTableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatabaseTableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterDatabaseTableName(s)
	}
}

func (s *DatabaseTableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitDatabaseTableName(s)
	}
}

func (s *DatabaseTableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitDatabaseTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) DatabaseTableName() (localctx IDatabaseTableNameContext) {
	localctx = NewDatabaseTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, KQLParserRULE_databaseTableName)
	p.SetState(512)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(502)
			p.Identifier()
		}
		{
			p.SetState(503)
			p.Match(KQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(504)
			p.Identifier()
		}
		{
			p.SetState(505)
			p.Match(KQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(506)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(508)
			p.Identifier()
		}
		{
			p.SetState(509)
			p.Match(KQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(510)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializeExpressionContext is an interface to support dynamic dispatch.
type IMaterializeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MATERIALIZE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	TabularExpression() ITabularExpressionContext
	RPAREN() antlr.TerminalNode

	// IsMaterializeExpressionContext differentiates from other interfaces.
	IsMaterializeExpressionContext()
}

type MaterializeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaterializeExpressionContext() *MaterializeExpressionContext {
	var p = new(MaterializeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_materializeExpression
	return p
}

func InitEmptyMaterializeExpressionContext(p *MaterializeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_materializeExpression
}

func (*MaterializeExpressionContext) IsMaterializeExpressionContext() {}

func NewMaterializeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializeExpressionContext {
	var p = new(MaterializeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_materializeExpression

	return p
}

func (s *MaterializeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializeExpressionContext) MATERIALIZE() antlr.TerminalNode {
	return s.GetToken(KQLParserMATERIALIZE, 0)
}

func (s *MaterializeExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *MaterializeExpressionContext) TabularExpression() ITabularExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabularExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabularExpressionContext)
}

func (s *MaterializeExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *MaterializeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaterializeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterMaterializeExpression(s)
	}
}

func (s *MaterializeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitMaterializeExpression(s)
	}
}

func (s *MaterializeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitMaterializeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) MaterializeExpression() (localctx IMaterializeExpressionContext) {
	localctx = NewMaterializeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, KQLParserRULE_materializeExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(514)
		p.Match(KQLParserMATERIALIZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(515)
		p.Match(KQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(516)
		p.TabularExpression()
	}
	{
		p.SetState(517)
		p.Match(KQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITabularOperatorContext is an interface to support dynamic dispatch.
type ITabularOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WhereOperator() IWhereOperatorContext
	SearchOperator() ISearchOperatorContext
	ProjectOperator() IProjectOperatorContext
	ProjectAwayOperator() IProjectAwayOperatorContext
	ProjectKeepOperator() IProjectKeepOperatorContext
	ProjectRenameOperator() IProjectRenameOperatorContext
	ProjectReorderOperator() IProjectReorderOperatorContext
	ExtendOperator() IExtendOperatorContext
	SummarizeOperator() ISummarizeOperatorContext
	SortOperator() ISortOperatorContext
	TopOperator() ITopOperatorContext
	TopNestedOperator() ITopNestedOperatorContext
	TakeOperator() ITakeOperatorContext
	DistinctOperator() IDistinctOperatorContext
	CountOperator() ICountOperatorContext
	JoinOperator() IJoinOperatorContext
	UnionOperator() IUnionOperatorContext
	LookupOperator() ILookupOperatorContext
	ParseOperator() IParseOperatorContext
	ParseKvOperator() IParseKvOperatorContext
	MvExpandOperator() IMvExpandOperatorContext
	MvApplyOperator() IMvApplyOperatorContext
	EvaluateOperator() IEvaluateOperatorContext
	FacetOperator() IFacetOperatorContext
	ForkOperator() IForkOperatorContext
	PartitionOperator() IPartitionOperatorContext
	ScanOperator() IScanOperatorContext
	SerializeOperator() ISerializeOperatorContext
	SampleOperator() ISampleOperatorContext
	SampleDistinctOperator() ISampleDistinctOperatorContext
	MakeSeriesOperator() IMakeSeriesOperatorContext
	FindOperator() IFindOperatorContext
	GetschemaOperator() IGetschemaOperatorContext
	RenderOperator() IRenderOperatorContext
	ConsumeOperator() IConsumeOperatorContext
	InvokeOperator() IInvokeOperatorContext
	AsOperator() IAsOperatorContext
	GraphOperator() IGraphOperatorContext

	// IsTabularOperatorContext differentiates from other interfaces.
	IsTabularOperatorContext()
}

type TabularOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTabularOperatorContext() *TabularOperatorContext {
	var p = new(TabularOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_tabularOperator
	return p
}

func InitEmptyTabularOperatorContext(p *TabularOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_tabularOperator
}

func (*TabularOperatorContext) IsTabularOperatorContext() {}

func NewTabularOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabularOperatorContext {
	var p = new(TabularOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_tabularOperator

	return p
}

func (s *TabularOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *TabularOperatorContext) WhereOperator() IWhereOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereOperatorContext)
}

func (s *TabularOperatorContext) SearchOperator() ISearchOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchOperatorContext)
}

func (s *TabularOperatorContext) ProjectOperator() IProjectOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectOperatorContext)
}

func (s *TabularOperatorContext) ProjectAwayOperator() IProjectAwayOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectAwayOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectAwayOperatorContext)
}

func (s *TabularOperatorContext) ProjectKeepOperator() IProjectKeepOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectKeepOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectKeepOperatorContext)
}

func (s *TabularOperatorContext) ProjectRenameOperator() IProjectRenameOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectRenameOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectRenameOperatorContext)
}

func (s *TabularOperatorContext) ProjectReorderOperator() IProjectReorderOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectReorderOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectReorderOperatorContext)
}

func (s *TabularOperatorContext) ExtendOperator() IExtendOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtendOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtendOperatorContext)
}

func (s *TabularOperatorContext) SummarizeOperator() ISummarizeOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISummarizeOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISummarizeOperatorContext)
}

func (s *TabularOperatorContext) SortOperator() ISortOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortOperatorContext)
}

func (s *TabularOperatorContext) TopOperator() ITopOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopOperatorContext)
}

func (s *TabularOperatorContext) TopNestedOperator() ITopNestedOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopNestedOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopNestedOperatorContext)
}

func (s *TabularOperatorContext) TakeOperator() ITakeOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITakeOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITakeOperatorContext)
}

func (s *TabularOperatorContext) DistinctOperator() IDistinctOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinctOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinctOperatorContext)
}

func (s *TabularOperatorContext) CountOperator() ICountOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICountOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICountOperatorContext)
}

func (s *TabularOperatorContext) JoinOperator() IJoinOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinOperatorContext)
}

func (s *TabularOperatorContext) UnionOperator() IUnionOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionOperatorContext)
}

func (s *TabularOperatorContext) LookupOperator() ILookupOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILookupOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILookupOperatorContext)
}

func (s *TabularOperatorContext) ParseOperator() IParseOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParseOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParseOperatorContext)
}

func (s *TabularOperatorContext) ParseKvOperator() IParseKvOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParseKvOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParseKvOperatorContext)
}

func (s *TabularOperatorContext) MvExpandOperator() IMvExpandOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvExpandOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvExpandOperatorContext)
}

func (s *TabularOperatorContext) MvApplyOperator() IMvApplyOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvApplyOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvApplyOperatorContext)
}

func (s *TabularOperatorContext) EvaluateOperator() IEvaluateOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvaluateOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvaluateOperatorContext)
}

func (s *TabularOperatorContext) FacetOperator() IFacetOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFacetOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFacetOperatorContext)
}

func (s *TabularOperatorContext) ForkOperator() IForkOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForkOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForkOperatorContext)
}

func (s *TabularOperatorContext) PartitionOperator() IPartitionOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOperatorContext)
}

func (s *TabularOperatorContext) ScanOperator() IScanOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScanOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScanOperatorContext)
}

func (s *TabularOperatorContext) SerializeOperator() ISerializeOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISerializeOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISerializeOperatorContext)
}

func (s *TabularOperatorContext) SampleOperator() ISampleOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleOperatorContext)
}

func (s *TabularOperatorContext) SampleDistinctOperator() ISampleDistinctOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleDistinctOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleDistinctOperatorContext)
}

func (s *TabularOperatorContext) MakeSeriesOperator() IMakeSeriesOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMakeSeriesOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMakeSeriesOperatorContext)
}

func (s *TabularOperatorContext) FindOperator() IFindOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFindOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFindOperatorContext)
}

func (s *TabularOperatorContext) GetschemaOperator() IGetschemaOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGetschemaOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGetschemaOperatorContext)
}

func (s *TabularOperatorContext) RenderOperator() IRenderOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenderOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenderOperatorContext)
}

func (s *TabularOperatorContext) ConsumeOperator() IConsumeOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConsumeOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConsumeOperatorContext)
}

func (s *TabularOperatorContext) InvokeOperator() IInvokeOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvokeOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvokeOperatorContext)
}

func (s *TabularOperatorContext) AsOperator() IAsOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsOperatorContext)
}

func (s *TabularOperatorContext) GraphOperator() IGraphOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphOperatorContext)
}

func (s *TabularOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabularOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TabularOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterTabularOperator(s)
	}
}

func (s *TabularOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitTabularOperator(s)
	}
}

func (s *TabularOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitTabularOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) TabularOperator() (localctx ITabularOperatorContext) {
	localctx = NewTabularOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, KQLParserRULE_tabularOperator)
	p.SetState(557)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KQLParserWHERE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(519)
			p.WhereOperator()
		}

	case KQLParserSEARCH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(520)
			p.SearchOperator()
		}

	case KQLParserPROJECT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(521)
			p.ProjectOperator()
		}

	case KQLParserPROJECT_AWAY:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(522)
			p.ProjectAwayOperator()
		}

	case KQLParserPROJECT_KEEP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(523)
			p.ProjectKeepOperator()
		}

	case KQLParserPROJECT_RENAME:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(524)
			p.ProjectRenameOperator()
		}

	case KQLParserPROJECT_REORDER:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(525)
			p.ProjectReorderOperator()
		}

	case KQLParserEXTEND:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(526)
			p.ExtendOperator()
		}

	case KQLParserSUMMARIZE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(527)
			p.SummarizeOperator()
		}

	case KQLParserSORT, KQLParserORDER:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(528)
			p.SortOperator()
		}

	case KQLParserTOP:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(529)
			p.TopOperator()
		}

	case KQLParserTOP_NESTED:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(530)
			p.TopNestedOperator()
		}

	case KQLParserTAKE, KQLParserLIMIT:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(531)
			p.TakeOperator()
		}

	case KQLParserDISTINCT:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(532)
			p.DistinctOperator()
		}

	case KQLParserCOUNT:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(533)
			p.CountOperator()
		}

	case KQLParserJOIN:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(534)
			p.JoinOperator()
		}

	case KQLParserUNION:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(535)
			p.UnionOperator()
		}

	case KQLParserLOOKUP:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(536)
			p.LookupOperator()
		}

	case KQLParserPARSE, KQLParserPARSE_WHERE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(537)
			p.ParseOperator()
		}

	case KQLParserPARSE_KV:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(538)
			p.ParseKvOperator()
		}

	case KQLParserMV_EXPAND:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(539)
			p.MvExpandOperator()
		}

	case KQLParserMV_APPLY:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(540)
			p.MvApplyOperator()
		}

	case KQLParserEVALUATE:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(541)
			p.EvaluateOperator()
		}

	case KQLParserFACET:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(542)
			p.FacetOperator()
		}

	case KQLParserFORK:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(543)
			p.ForkOperator()
		}

	case KQLParserPARTITION:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(544)
			p.PartitionOperator()
		}

	case KQLParserSCAN:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(545)
			p.ScanOperator()
		}

	case KQLParserSERIALIZE:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(546)
			p.SerializeOperator()
		}

	case KQLParserSAMPLE:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(547)
			p.SampleOperator()
		}

	case KQLParserSAMPLE_DISTINCT:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(548)
			p.SampleDistinctOperator()
		}

	case KQLParserMAKE_SERIES:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(549)
			p.MakeSeriesOperator()
		}

	case KQLParserFIND:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(550)
			p.FindOperator()
		}

	case KQLParserGETSCHEMA:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(551)
			p.GetschemaOperator()
		}

	case KQLParserRENDER:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(552)
			p.RenderOperator()
		}

	case KQLParserCONSUME:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(553)
			p.ConsumeOperator()
		}

	case KQLParserINVOKE:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(554)
			p.InvokeOperator()
		}

	case KQLParserAS:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(555)
			p.AsOperator()
		}

	case KQLParserMAKE_GRAPH, KQLParserGRAPH_MATCH, KQLParserGRAPH_SHORTEST_PATHS, KQLParserGRAPH_TO_TABLE:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(556)
			p.GraphOperator()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereOperatorContext is an interface to support dynamic dispatch.
type IWhereOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsWhereOperatorContext differentiates from other interfaces.
	IsWhereOperatorContext()
}

type WhereOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereOperatorContext() *WhereOperatorContext {
	var p = new(WhereOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_whereOperator
	return p
}

func InitEmptyWhereOperatorContext(p *WhereOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_whereOperator
}

func (*WhereOperatorContext) IsWhereOperatorContext() {}

func NewWhereOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereOperatorContext {
	var p = new(WhereOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_whereOperator

	return p
}

func (s *WhereOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereOperatorContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KQLParserWHERE, 0)
}

func (s *WhereOperatorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhereOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterWhereOperator(s)
	}
}

func (s *WhereOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitWhereOperator(s)
	}
}

func (s *WhereOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitWhereOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) WhereOperator() (localctx IWhereOperatorContext) {
	localctx = NewWhereOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, KQLParserRULE_whereOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(559)
		p.Match(KQLParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(560)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISearchOperatorContext is an interface to support dynamic dispatch.
type ISearchOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEARCH() antlr.TerminalNode
	Expression() IExpressionContext
	SearchKind() ISearchKindContext
	IN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	TableList() ITableListContext
	RPAREN() antlr.TerminalNode

	// IsSearchOperatorContext differentiates from other interfaces.
	IsSearchOperatorContext()
}

type SearchOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchOperatorContext() *SearchOperatorContext {
	var p = new(SearchOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_searchOperator
	return p
}

func InitEmptySearchOperatorContext(p *SearchOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_searchOperator
}

func (*SearchOperatorContext) IsSearchOperatorContext() {}

func NewSearchOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchOperatorContext {
	var p = new(SearchOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_searchOperator

	return p
}

func (s *SearchOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchOperatorContext) SEARCH() antlr.TerminalNode {
	return s.GetToken(KQLParserSEARCH, 0)
}

func (s *SearchOperatorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchOperatorContext) SearchKind() ISearchKindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchKindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchKindContext)
}

func (s *SearchOperatorContext) IN() antlr.TerminalNode {
	return s.GetToken(KQLParserIN, 0)
}

func (s *SearchOperatorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *SearchOperatorContext) TableList() ITableListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableListContext)
}

func (s *SearchOperatorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *SearchOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterSearchOperator(s)
	}
}

func (s *SearchOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitSearchOperator(s)
	}
}

func (s *SearchOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitSearchOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) SearchOperator() (localctx ISearchOperatorContext) {
	localctx = NewSearchOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, KQLParserRULE_searchOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(562)
		p.Match(KQLParserSEARCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(564)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 19, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(563)
			p.SearchKind()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(571)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserIN {
		{
			p.SetState(566)
			p.Match(KQLParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(567)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(568)
			p.TableList()
		}
		{
			p.SetState(569)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(573)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISearchKindContext is an interface to support dynamic dispatch.
type ISearchKindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KIND() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsSearchKindContext differentiates from other interfaces.
	IsSearchKindContext()
}

type SearchKindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchKindContext() *SearchKindContext {
	var p = new(SearchKindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_searchKind
	return p
}

func InitEmptySearchKindContext(p *SearchKindContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_searchKind
}

func (*SearchKindContext) IsSearchKindContext() {}

func NewSearchKindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchKindContext {
	var p = new(SearchKindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_searchKind

	return p
}

func (s *SearchKindContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchKindContext) KIND() antlr.TerminalNode {
	return s.GetToken(KQLParserKIND, 0)
}

func (s *SearchKindContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *SearchKindContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SearchKindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchKindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchKindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterSearchKind(s)
	}
}

func (s *SearchKindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitSearchKind(s)
	}
}

func (s *SearchKindContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitSearchKind(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) SearchKind() (localctx ISearchKindContext) {
	localctx = NewSearchKindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, KQLParserRULE_searchKind)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(575)
		p.Match(KQLParserKIND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(576)
		p.Match(KQLParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(577)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableListContext is an interface to support dynamic dispatch.
type ITableListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableName() []ITableNameContext
	TableName(i int) ITableNameContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTableListContext differentiates from other interfaces.
	IsTableListContext()
}

type TableListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableListContext() *TableListContext {
	var p = new(TableListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_tableList
	return p
}

func InitEmptyTableListContext(p *TableListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_tableList
}

func (*TableListContext) IsTableListContext() {}

func NewTableListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableListContext {
	var p = new(TableListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_tableList

	return p
}

func (s *TableListContext) GetParser() antlr.Parser { return s.parser }

func (s *TableListContext) AllTableName() []ITableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableNameContext); ok {
			len++
		}
	}

	tst := make([]ITableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableNameContext); ok {
			tst[i] = t.(ITableNameContext)
			i++
		}
	}

	return tst
}

func (s *TableListContext) TableName(i int) ITableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *TableListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *TableListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *TableListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterTableList(s)
	}
}

func (s *TableListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitTableList(s)
	}
}

func (s *TableListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitTableList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) TableList() (localctx ITableListContext) {
	localctx = NewTableListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, KQLParserRULE_tableList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(579)
		p.TableName()
	}
	p.SetState(584)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(580)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(581)
			p.TableName()
		}

		p.SetState(586)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProjectOperatorContext is an interface to support dynamic dispatch.
type IProjectOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROJECT() antlr.TerminalNode
	ProjectItemList() IProjectItemListContext

	// IsProjectOperatorContext differentiates from other interfaces.
	IsProjectOperatorContext()
}

type ProjectOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectOperatorContext() *ProjectOperatorContext {
	var p = new(ProjectOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_projectOperator
	return p
}

func InitEmptyProjectOperatorContext(p *ProjectOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_projectOperator
}

func (*ProjectOperatorContext) IsProjectOperatorContext() {}

func NewProjectOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectOperatorContext {
	var p = new(ProjectOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_projectOperator

	return p
}

func (s *ProjectOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectOperatorContext) PROJECT() antlr.TerminalNode {
	return s.GetToken(KQLParserPROJECT, 0)
}

func (s *ProjectOperatorContext) ProjectItemList() IProjectItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectItemListContext)
}

func (s *ProjectOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterProjectOperator(s)
	}
}

func (s *ProjectOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitProjectOperator(s)
	}
}

func (s *ProjectOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitProjectOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ProjectOperator() (localctx IProjectOperatorContext) {
	localctx = NewProjectOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, KQLParserRULE_projectOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(587)
		p.Match(KQLParserPROJECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(588)
		p.ProjectItemList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProjectAwayOperatorContext is an interface to support dynamic dispatch.
type IProjectAwayOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROJECT_AWAY() antlr.TerminalNode
	IdentifierOrWildcardList() IIdentifierOrWildcardListContext

	// IsProjectAwayOperatorContext differentiates from other interfaces.
	IsProjectAwayOperatorContext()
}

type ProjectAwayOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectAwayOperatorContext() *ProjectAwayOperatorContext {
	var p = new(ProjectAwayOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_projectAwayOperator
	return p
}

func InitEmptyProjectAwayOperatorContext(p *ProjectAwayOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_projectAwayOperator
}

func (*ProjectAwayOperatorContext) IsProjectAwayOperatorContext() {}

func NewProjectAwayOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectAwayOperatorContext {
	var p = new(ProjectAwayOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_projectAwayOperator

	return p
}

func (s *ProjectAwayOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectAwayOperatorContext) PROJECT_AWAY() antlr.TerminalNode {
	return s.GetToken(KQLParserPROJECT_AWAY, 0)
}

func (s *ProjectAwayOperatorContext) IdentifierOrWildcardList() IIdentifierOrWildcardListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrWildcardListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrWildcardListContext)
}

func (s *ProjectAwayOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectAwayOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectAwayOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterProjectAwayOperator(s)
	}
}

func (s *ProjectAwayOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitProjectAwayOperator(s)
	}
}

func (s *ProjectAwayOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitProjectAwayOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ProjectAwayOperator() (localctx IProjectAwayOperatorContext) {
	localctx = NewProjectAwayOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, KQLParserRULE_projectAwayOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(590)
		p.Match(KQLParserPROJECT_AWAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(591)
		p.IdentifierOrWildcardList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProjectKeepOperatorContext is an interface to support dynamic dispatch.
type IProjectKeepOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROJECT_KEEP() antlr.TerminalNode
	IdentifierOrWildcardList() IIdentifierOrWildcardListContext

	// IsProjectKeepOperatorContext differentiates from other interfaces.
	IsProjectKeepOperatorContext()
}

type ProjectKeepOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectKeepOperatorContext() *ProjectKeepOperatorContext {
	var p = new(ProjectKeepOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_projectKeepOperator
	return p
}

func InitEmptyProjectKeepOperatorContext(p *ProjectKeepOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_projectKeepOperator
}

func (*ProjectKeepOperatorContext) IsProjectKeepOperatorContext() {}

func NewProjectKeepOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectKeepOperatorContext {
	var p = new(ProjectKeepOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_projectKeepOperator

	return p
}

func (s *ProjectKeepOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectKeepOperatorContext) PROJECT_KEEP() antlr.TerminalNode {
	return s.GetToken(KQLParserPROJECT_KEEP, 0)
}

func (s *ProjectKeepOperatorContext) IdentifierOrWildcardList() IIdentifierOrWildcardListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrWildcardListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrWildcardListContext)
}

func (s *ProjectKeepOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectKeepOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectKeepOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterProjectKeepOperator(s)
	}
}

func (s *ProjectKeepOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitProjectKeepOperator(s)
	}
}

func (s *ProjectKeepOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitProjectKeepOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ProjectKeepOperator() (localctx IProjectKeepOperatorContext) {
	localctx = NewProjectKeepOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, KQLParserRULE_projectKeepOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(593)
		p.Match(KQLParserPROJECT_KEEP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(594)
		p.IdentifierOrWildcardList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProjectRenameOperatorContext is an interface to support dynamic dispatch.
type IProjectRenameOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROJECT_RENAME() antlr.TerminalNode
	RenameList() IRenameListContext

	// IsProjectRenameOperatorContext differentiates from other interfaces.
	IsProjectRenameOperatorContext()
}

type ProjectRenameOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectRenameOperatorContext() *ProjectRenameOperatorContext {
	var p = new(ProjectRenameOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_projectRenameOperator
	return p
}

func InitEmptyProjectRenameOperatorContext(p *ProjectRenameOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_projectRenameOperator
}

func (*ProjectRenameOperatorContext) IsProjectRenameOperatorContext() {}

func NewProjectRenameOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectRenameOperatorContext {
	var p = new(ProjectRenameOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_projectRenameOperator

	return p
}

func (s *ProjectRenameOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectRenameOperatorContext) PROJECT_RENAME() antlr.TerminalNode {
	return s.GetToken(KQLParserPROJECT_RENAME, 0)
}

func (s *ProjectRenameOperatorContext) RenameList() IRenameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameListContext)
}

func (s *ProjectRenameOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectRenameOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectRenameOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterProjectRenameOperator(s)
	}
}

func (s *ProjectRenameOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitProjectRenameOperator(s)
	}
}

func (s *ProjectRenameOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitProjectRenameOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ProjectRenameOperator() (localctx IProjectRenameOperatorContext) {
	localctx = NewProjectRenameOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, KQLParserRULE_projectRenameOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(596)
		p.Match(KQLParserPROJECT_RENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(597)
		p.RenameList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProjectReorderOperatorContext is an interface to support dynamic dispatch.
type IProjectReorderOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROJECT_REORDER() antlr.TerminalNode
	IdentifierOrWildcardList() IIdentifierOrWildcardListContext
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsProjectReorderOperatorContext differentiates from other interfaces.
	IsProjectReorderOperatorContext()
}

type ProjectReorderOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectReorderOperatorContext() *ProjectReorderOperatorContext {
	var p = new(ProjectReorderOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_projectReorderOperator
	return p
}

func InitEmptyProjectReorderOperatorContext(p *ProjectReorderOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_projectReorderOperator
}

func (*ProjectReorderOperatorContext) IsProjectReorderOperatorContext() {}

func NewProjectReorderOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectReorderOperatorContext {
	var p = new(ProjectReorderOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_projectReorderOperator

	return p
}

func (s *ProjectReorderOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectReorderOperatorContext) PROJECT_REORDER() antlr.TerminalNode {
	return s.GetToken(KQLParserPROJECT_REORDER, 0)
}

func (s *ProjectReorderOperatorContext) IdentifierOrWildcardList() IIdentifierOrWildcardListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrWildcardListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrWildcardListContext)
}

func (s *ProjectReorderOperatorContext) ASC() antlr.TerminalNode {
	return s.GetToken(KQLParserASC, 0)
}

func (s *ProjectReorderOperatorContext) DESC() antlr.TerminalNode {
	return s.GetToken(KQLParserDESC, 0)
}

func (s *ProjectReorderOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectReorderOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectReorderOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterProjectReorderOperator(s)
	}
}

func (s *ProjectReorderOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitProjectReorderOperator(s)
	}
}

func (s *ProjectReorderOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitProjectReorderOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ProjectReorderOperator() (localctx IProjectReorderOperatorContext) {
	localctx = NewProjectReorderOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, KQLParserRULE_projectReorderOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(599)
		p.Match(KQLParserPROJECT_REORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(600)
		p.IdentifierOrWildcardList()
	}
	p.SetState(602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserASC || _la == KQLParserDESC {
		{
			p.SetState(601)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KQLParserASC || _la == KQLParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProjectItemListContext is an interface to support dynamic dispatch.
type IProjectItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProjectItem() []IProjectItemContext
	ProjectItem(i int) IProjectItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsProjectItemListContext differentiates from other interfaces.
	IsProjectItemListContext()
}

type ProjectItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectItemListContext() *ProjectItemListContext {
	var p = new(ProjectItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_projectItemList
	return p
}

func InitEmptyProjectItemListContext(p *ProjectItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_projectItemList
}

func (*ProjectItemListContext) IsProjectItemListContext() {}

func NewProjectItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectItemListContext {
	var p = new(ProjectItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_projectItemList

	return p
}

func (s *ProjectItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectItemListContext) AllProjectItem() []IProjectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProjectItemContext); ok {
			len++
		}
	}

	tst := make([]IProjectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProjectItemContext); ok {
			tst[i] = t.(IProjectItemContext)
			i++
		}
	}

	return tst
}

func (s *ProjectItemListContext) ProjectItem(i int) IProjectItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectItemContext)
}

func (s *ProjectItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *ProjectItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *ProjectItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterProjectItemList(s)
	}
}

func (s *ProjectItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitProjectItemList(s)
	}
}

func (s *ProjectItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitProjectItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ProjectItemList() (localctx IProjectItemListContext) {
	localctx = NewProjectItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, KQLParserRULE_projectItemList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(604)
		p.ProjectItem()
	}
	p.SetState(609)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(605)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(606)
			p.ProjectItem()
		}

		p.SetState(611)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProjectItemContext is an interface to support dynamic dispatch.
type IProjectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode

	// IsProjectItemContext differentiates from other interfaces.
	IsProjectItemContext()
}

type ProjectItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProjectItemContext() *ProjectItemContext {
	var p = new(ProjectItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_projectItem
	return p
}

func InitEmptyProjectItemContext(p *ProjectItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_projectItem
}

func (*ProjectItemContext) IsProjectItemContext() {}

func NewProjectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProjectItemContext {
	var p = new(ProjectItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_projectItem

	return p
}

func (s *ProjectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ProjectItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ProjectItemContext) AS() antlr.TerminalNode {
	return s.GetToken(KQLParserAS, 0)
}

func (s *ProjectItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProjectItemContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *ProjectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProjectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProjectItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterProjectItem(s)
	}
}

func (s *ProjectItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitProjectItem(s)
	}
}

func (s *ProjectItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitProjectItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ProjectItem() (localctx IProjectItemContext) {
	localctx = NewProjectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, KQLParserRULE_projectItem)
	var _la int

	p.SetState(621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(612)
			p.Expression()
		}
		p.SetState(615)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserAS {
			{
				p.SetState(613)
				p.Match(KQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(614)
				p.Identifier()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(617)
			p.Identifier()
		}
		{
			p.SetState(618)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(619)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrWildcardListContext is an interface to support dynamic dispatch.
type IIdentifierOrWildcardListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrWildcard() []IIdentifierOrWildcardContext
	IdentifierOrWildcard(i int) IIdentifierOrWildcardContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifierOrWildcardListContext differentiates from other interfaces.
	IsIdentifierOrWildcardListContext()
}

type IdentifierOrWildcardListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrWildcardListContext() *IdentifierOrWildcardListContext {
	var p = new(IdentifierOrWildcardListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_identifierOrWildcardList
	return p
}

func InitEmptyIdentifierOrWildcardListContext(p *IdentifierOrWildcardListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_identifierOrWildcardList
}

func (*IdentifierOrWildcardListContext) IsIdentifierOrWildcardListContext() {}

func NewIdentifierOrWildcardListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrWildcardListContext {
	var p = new(IdentifierOrWildcardListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_identifierOrWildcardList

	return p
}

func (s *IdentifierOrWildcardListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrWildcardListContext) AllIdentifierOrWildcard() []IIdentifierOrWildcardContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrWildcardContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrWildcardContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrWildcardContext); ok {
			tst[i] = t.(IIdentifierOrWildcardContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierOrWildcardListContext) IdentifierOrWildcard(i int) IIdentifierOrWildcardContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrWildcardContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrWildcardContext)
}

func (s *IdentifierOrWildcardListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *IdentifierOrWildcardListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *IdentifierOrWildcardListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrWildcardListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrWildcardListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterIdentifierOrWildcardList(s)
	}
}

func (s *IdentifierOrWildcardListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitIdentifierOrWildcardList(s)
	}
}

func (s *IdentifierOrWildcardListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitIdentifierOrWildcardList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) IdentifierOrWildcardList() (localctx IIdentifierOrWildcardListContext) {
	localctx = NewIdentifierOrWildcardListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, KQLParserRULE_identifierOrWildcardList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(623)
		p.IdentifierOrWildcard()
	}
	p.SetState(628)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(624)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(625)
			p.IdentifierOrWildcard()
		}

		p.SetState(630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrWildcardContext is an interface to support dynamic dispatch.
type IIdentifierOrWildcardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	STAR() antlr.TerminalNode

	// IsIdentifierOrWildcardContext differentiates from other interfaces.
	IsIdentifierOrWildcardContext()
}

type IdentifierOrWildcardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrWildcardContext() *IdentifierOrWildcardContext {
	var p = new(IdentifierOrWildcardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_identifierOrWildcard
	return p
}

func InitEmptyIdentifierOrWildcardContext(p *IdentifierOrWildcardContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_identifierOrWildcard
}

func (*IdentifierOrWildcardContext) IsIdentifierOrWildcardContext() {}

func NewIdentifierOrWildcardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrWildcardContext {
	var p = new(IdentifierOrWildcardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_identifierOrWildcard

	return p
}

func (s *IdentifierOrWildcardContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrWildcardContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierOrWildcardContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrWildcardContext) STAR() antlr.TerminalNode {
	return s.GetToken(KQLParserSTAR, 0)
}

func (s *IdentifierOrWildcardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrWildcardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrWildcardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterIdentifierOrWildcard(s)
	}
}

func (s *IdentifierOrWildcardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitIdentifierOrWildcard(s)
	}
}

func (s *IdentifierOrWildcardContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitIdentifierOrWildcard(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) IdentifierOrWildcard() (localctx IIdentifierOrWildcardContext) {
	localctx = NewIdentifierOrWildcardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, KQLParserRULE_identifierOrWildcard)
	p.SetState(642)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(631)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(632)
			p.Match(KQLParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(633)
			p.Identifier()
		}
		{
			p.SetState(634)
			p.Match(KQLParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(636)
			p.Match(KQLParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(637)
			p.Identifier()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(638)
			p.Identifier()
		}
		{
			p.SetState(639)
			p.Match(KQLParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(640)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameListContext is an interface to support dynamic dispatch.
type IRenameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRenameItem() []IRenameItemContext
	RenameItem(i int) IRenameItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRenameListContext differentiates from other interfaces.
	IsRenameListContext()
}

type RenameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameListContext() *RenameListContext {
	var p = new(RenameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_renameList
	return p
}

func InitEmptyRenameListContext(p *RenameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_renameList
}

func (*RenameListContext) IsRenameListContext() {}

func NewRenameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameListContext {
	var p = new(RenameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_renameList

	return p
}

func (s *RenameListContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameListContext) AllRenameItem() []IRenameItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRenameItemContext); ok {
			len++
		}
	}

	tst := make([]IRenameItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRenameItemContext); ok {
			tst[i] = t.(IRenameItemContext)
			i++
		}
	}

	return tst
}

func (s *RenameListContext) RenameItem(i int) IRenameItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameItemContext)
}

func (s *RenameListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *RenameListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *RenameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterRenameList(s)
	}
}

func (s *RenameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitRenameList(s)
	}
}

func (s *RenameListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitRenameList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) RenameList() (localctx IRenameListContext) {
	localctx = NewRenameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, KQLParserRULE_renameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(644)
		p.RenameItem()
	}
	p.SetState(649)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(645)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(646)
			p.RenameItem()
		}

		p.SetState(651)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameItemContext is an interface to support dynamic dispatch.
type IRenameItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	ASSIGN() antlr.TerminalNode

	// IsRenameItemContext differentiates from other interfaces.
	IsRenameItemContext()
}

type RenameItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameItemContext() *RenameItemContext {
	var p = new(RenameItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_renameItem
	return p
}

func InitEmptyRenameItemContext(p *RenameItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_renameItem
}

func (*RenameItemContext) IsRenameItemContext() {}

func NewRenameItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameItemContext {
	var p = new(RenameItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_renameItem

	return p
}

func (s *RenameItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameItemContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RenameItemContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenameItemContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *RenameItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterRenameItem(s)
	}
}

func (s *RenameItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitRenameItem(s)
	}
}

func (s *RenameItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitRenameItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) RenameItem() (localctx IRenameItemContext) {
	localctx = NewRenameItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, KQLParserRULE_renameItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(652)
		p.Identifier()
	}
	{
		p.SetState(653)
		p.Match(KQLParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(654)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtendOperatorContext is an interface to support dynamic dispatch.
type IExtendOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTEND() antlr.TerminalNode
	ExtendItemList() IExtendItemListContext

	// IsExtendOperatorContext differentiates from other interfaces.
	IsExtendOperatorContext()
}

type ExtendOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendOperatorContext() *ExtendOperatorContext {
	var p = new(ExtendOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_extendOperator
	return p
}

func InitEmptyExtendOperatorContext(p *ExtendOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_extendOperator
}

func (*ExtendOperatorContext) IsExtendOperatorContext() {}

func NewExtendOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendOperatorContext {
	var p = new(ExtendOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_extendOperator

	return p
}

func (s *ExtendOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendOperatorContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(KQLParserEXTEND, 0)
}

func (s *ExtendOperatorContext) ExtendItemList() IExtendItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtendItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtendItemListContext)
}

func (s *ExtendOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterExtendOperator(s)
	}
}

func (s *ExtendOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitExtendOperator(s)
	}
}

func (s *ExtendOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitExtendOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ExtendOperator() (localctx IExtendOperatorContext) {
	localctx = NewExtendOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, KQLParserRULE_extendOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		p.Match(KQLParserEXTEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(657)
		p.ExtendItemList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtendItemListContext is an interface to support dynamic dispatch.
type IExtendItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExtendItem() []IExtendItemContext
	ExtendItem(i int) IExtendItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExtendItemListContext differentiates from other interfaces.
	IsExtendItemListContext()
}

type ExtendItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendItemListContext() *ExtendItemListContext {
	var p = new(ExtendItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_extendItemList
	return p
}

func InitEmptyExtendItemListContext(p *ExtendItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_extendItemList
}

func (*ExtendItemListContext) IsExtendItemListContext() {}

func NewExtendItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendItemListContext {
	var p = new(ExtendItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_extendItemList

	return p
}

func (s *ExtendItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendItemListContext) AllExtendItem() []IExtendItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExtendItemContext); ok {
			len++
		}
	}

	tst := make([]IExtendItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExtendItemContext); ok {
			tst[i] = t.(IExtendItemContext)
			i++
		}
	}

	return tst
}

func (s *ExtendItemListContext) ExtendItem(i int) IExtendItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtendItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtendItemContext)
}

func (s *ExtendItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *ExtendItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *ExtendItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterExtendItemList(s)
	}
}

func (s *ExtendItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitExtendItemList(s)
	}
}

func (s *ExtendItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitExtendItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ExtendItemList() (localctx IExtendItemListContext) {
	localctx = NewExtendItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, KQLParserRULE_extendItemList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(659)
		p.ExtendItem()
	}
	p.SetState(664)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(660)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(661)
			p.ExtendItem()
		}

		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtendItemContext is an interface to support dynamic dispatch.
type IExtendItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext
	AS() antlr.TerminalNode

	// IsExtendItemContext differentiates from other interfaces.
	IsExtendItemContext()
}

type ExtendItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendItemContext() *ExtendItemContext {
	var p = new(ExtendItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_extendItem
	return p
}

func InitEmptyExtendItemContext(p *ExtendItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_extendItem
}

func (*ExtendItemContext) IsExtendItemContext() {}

func NewExtendItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendItemContext {
	var p = new(ExtendItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_extendItem

	return p
}

func (s *ExtendItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtendItemContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *ExtendItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExtendItemContext) AS() antlr.TerminalNode {
	return s.GetToken(KQLParserAS, 0)
}

func (s *ExtendItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterExtendItem(s)
	}
}

func (s *ExtendItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitExtendItem(s)
	}
}

func (s *ExtendItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitExtendItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ExtendItem() (localctx IExtendItemContext) {
	localctx = NewExtendItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, KQLParserRULE_extendItem)
	var _la int

	p.SetState(676)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(667)
			p.Identifier()
		}
		{
			p.SetState(668)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(669)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(671)
			p.Expression()
		}
		p.SetState(674)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserAS {
			{
				p.SetState(672)
				p.Match(KQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(673)
				p.Identifier()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISummarizeOperatorContext is an interface to support dynamic dispatch.
type ISummarizeOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUMMARIZE() antlr.TerminalNode
	AggregationList() IAggregationListContext
	SummarizeHints() ISummarizeHintsContext
	BY() antlr.TerminalNode
	GroupByList() IGroupByListContext

	// IsSummarizeOperatorContext differentiates from other interfaces.
	IsSummarizeOperatorContext()
}

type SummarizeOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySummarizeOperatorContext() *SummarizeOperatorContext {
	var p = new(SummarizeOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_summarizeOperator
	return p
}

func InitEmptySummarizeOperatorContext(p *SummarizeOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_summarizeOperator
}

func (*SummarizeOperatorContext) IsSummarizeOperatorContext() {}

func NewSummarizeOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SummarizeOperatorContext {
	var p = new(SummarizeOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_summarizeOperator

	return p
}

func (s *SummarizeOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *SummarizeOperatorContext) SUMMARIZE() antlr.TerminalNode {
	return s.GetToken(KQLParserSUMMARIZE, 0)
}

func (s *SummarizeOperatorContext) AggregationList() IAggregationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregationListContext)
}

func (s *SummarizeOperatorContext) SummarizeHints() ISummarizeHintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISummarizeHintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISummarizeHintsContext)
}

func (s *SummarizeOperatorContext) BY() antlr.TerminalNode {
	return s.GetToken(KQLParserBY, 0)
}

func (s *SummarizeOperatorContext) GroupByList() IGroupByListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByListContext)
}

func (s *SummarizeOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SummarizeOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SummarizeOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterSummarizeOperator(s)
	}
}

func (s *SummarizeOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitSummarizeOperator(s)
	}
}

func (s *SummarizeOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitSummarizeOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) SummarizeOperator() (localctx ISummarizeOperatorContext) {
	localctx = NewSummarizeOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, KQLParserRULE_summarizeOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(678)
		p.Match(KQLParserSUMMARIZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserHINT_DOT {
		{
			p.SetState(679)
			p.SummarizeHints()
		}

	}
	{
		p.SetState(682)
		p.AggregationList()
	}
	p.SetState(685)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserBY {
		{
			p.SetState(683)
			p.Match(KQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(684)
			p.GroupByList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISummarizeHintsContext is an interface to support dynamic dispatch.
type ISummarizeHintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HINT_DOT() antlr.TerminalNode
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsSummarizeHintsContext differentiates from other interfaces.
	IsSummarizeHintsContext()
}

type SummarizeHintsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySummarizeHintsContext() *SummarizeHintsContext {
	var p = new(SummarizeHintsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_summarizeHints
	return p
}

func InitEmptySummarizeHintsContext(p *SummarizeHintsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_summarizeHints
}

func (*SummarizeHintsContext) IsSummarizeHintsContext() {}

func NewSummarizeHintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SummarizeHintsContext {
	var p = new(SummarizeHintsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_summarizeHints

	return p
}

func (s *SummarizeHintsContext) GetParser() antlr.Parser { return s.parser }

func (s *SummarizeHintsContext) HINT_DOT() antlr.TerminalNode {
	return s.GetToken(KQLParserHINT_DOT, 0)
}

func (s *SummarizeHintsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SummarizeHintsContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *SummarizeHintsContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SummarizeHintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SummarizeHintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SummarizeHintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterSummarizeHints(s)
	}
}

func (s *SummarizeHintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitSummarizeHints(s)
	}
}

func (s *SummarizeHintsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitSummarizeHints(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) SummarizeHints() (localctx ISummarizeHintsContext) {
	localctx = NewSummarizeHintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, KQLParserRULE_summarizeHints)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(687)
		p.Match(KQLParserHINT_DOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(688)
		p.Identifier()
	}
	{
		p.SetState(689)
		p.Match(KQLParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(690)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggregationListContext is an interface to support dynamic dispatch.
type IAggregationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAggregationItem() []IAggregationItemContext
	AggregationItem(i int) IAggregationItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsAggregationListContext differentiates from other interfaces.
	IsAggregationListContext()
}

type AggregationListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregationListContext() *AggregationListContext {
	var p = new(AggregationListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_aggregationList
	return p
}

func InitEmptyAggregationListContext(p *AggregationListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_aggregationList
}

func (*AggregationListContext) IsAggregationListContext() {}

func NewAggregationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregationListContext {
	var p = new(AggregationListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_aggregationList

	return p
}

func (s *AggregationListContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregationListContext) AllAggregationItem() []IAggregationItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAggregationItemContext); ok {
			len++
		}
	}

	tst := make([]IAggregationItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAggregationItemContext); ok {
			tst[i] = t.(IAggregationItemContext)
			i++
		}
	}

	return tst
}

func (s *AggregationListContext) AggregationItem(i int) IAggregationItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregationItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregationItemContext)
}

func (s *AggregationListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *AggregationListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *AggregationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterAggregationList(s)
	}
}

func (s *AggregationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitAggregationList(s)
	}
}

func (s *AggregationListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitAggregationList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) AggregationList() (localctx IAggregationListContext) {
	localctx = NewAggregationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, KQLParserRULE_aggregationList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(692)
		p.AggregationItem()
	}
	p.SetState(697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(693)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(694)
			p.AggregationItem()
		}

		p.SetState(699)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggregationItemContext is an interface to support dynamic dispatch.
type IAggregationItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	AggregationFunction() IAggregationFunctionContext
	AS() antlr.TerminalNode

	// IsAggregationItemContext differentiates from other interfaces.
	IsAggregationItemContext()
}

type AggregationItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregationItemContext() *AggregationItemContext {
	var p = new(AggregationItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_aggregationItem
	return p
}

func InitEmptyAggregationItemContext(p *AggregationItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_aggregationItem
}

func (*AggregationItemContext) IsAggregationItemContext() {}

func NewAggregationItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregationItemContext {
	var p = new(AggregationItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_aggregationItem

	return p
}

func (s *AggregationItemContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregationItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AggregationItemContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *AggregationItemContext) AggregationFunction() IAggregationFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregationFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregationFunctionContext)
}

func (s *AggregationItemContext) AS() antlr.TerminalNode {
	return s.GetToken(KQLParserAS, 0)
}

func (s *AggregationItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregationItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterAggregationItem(s)
	}
}

func (s *AggregationItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitAggregationItem(s)
	}
}

func (s *AggregationItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitAggregationItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) AggregationItem() (localctx IAggregationItemContext) {
	localctx = NewAggregationItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, KQLParserRULE_aggregationItem)
	var _la int

	p.SetState(709)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(700)
			p.Identifier()
		}
		{
			p.SetState(701)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(702)
			p.AggregationFunction()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(704)
			p.AggregationFunction()
		}
		p.SetState(707)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserAS {
			{
				p.SetState(705)
				p.Match(KQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(706)
				p.Identifier()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggregationFunctionContext is an interface to support dynamic dispatch.
type IAggregationFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionCall() IFunctionCallContext
	Expression() IExpressionContext

	// IsAggregationFunctionContext differentiates from other interfaces.
	IsAggregationFunctionContext()
}

type AggregationFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregationFunctionContext() *AggregationFunctionContext {
	var p = new(AggregationFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_aggregationFunction
	return p
}

func InitEmptyAggregationFunctionContext(p *AggregationFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_aggregationFunction
}

func (*AggregationFunctionContext) IsAggregationFunctionContext() {}

func NewAggregationFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregationFunctionContext {
	var p = new(AggregationFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_aggregationFunction

	return p
}

func (s *AggregationFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregationFunctionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *AggregationFunctionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AggregationFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregationFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterAggregationFunction(s)
	}
}

func (s *AggregationFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitAggregationFunction(s)
	}
}

func (s *AggregationFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitAggregationFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) AggregationFunction() (localctx IAggregationFunctionContext) {
	localctx = NewAggregationFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, KQLParserRULE_aggregationFunction)
	p.SetState(713)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(711)
			p.FunctionCall()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(712)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByListContext is an interface to support dynamic dispatch.
type IGroupByListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGroupByItem() []IGroupByItemContext
	GroupByItem(i int) IGroupByItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsGroupByListContext differentiates from other interfaces.
	IsGroupByListContext()
}

type GroupByListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByListContext() *GroupByListContext {
	var p = new(GroupByListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_groupByList
	return p
}

func InitEmptyGroupByListContext(p *GroupByListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_groupByList
}

func (*GroupByListContext) IsGroupByListContext() {}

func NewGroupByListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByListContext {
	var p = new(GroupByListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_groupByList

	return p
}

func (s *GroupByListContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByListContext) AllGroupByItem() []IGroupByItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupByItemContext); ok {
			len++
		}
	}

	tst := make([]IGroupByItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupByItemContext); ok {
			tst[i] = t.(IGroupByItemContext)
			i++
		}
	}

	return tst
}

func (s *GroupByListContext) GroupByItem(i int) IGroupByItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByItemContext)
}

func (s *GroupByListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *GroupByListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *GroupByListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterGroupByList(s)
	}
}

func (s *GroupByListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitGroupByList(s)
	}
}

func (s *GroupByListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitGroupByList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) GroupByList() (localctx IGroupByListContext) {
	localctx = NewGroupByListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, KQLParserRULE_groupByList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(715)
		p.GroupByItem()
	}
	p.SetState(720)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(716)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(717)
			p.GroupByItem()
		}

		p.SetState(722)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByItemContext is an interface to support dynamic dispatch.
type IGroupByItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode

	// IsGroupByItemContext differentiates from other interfaces.
	IsGroupByItemContext()
}

type GroupByItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByItemContext() *GroupByItemContext {
	var p = new(GroupByItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_groupByItem
	return p
}

func InitEmptyGroupByItemContext(p *GroupByItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_groupByItem
}

func (*GroupByItemContext) IsGroupByItemContext() {}

func NewGroupByItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByItemContext {
	var p = new(GroupByItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_groupByItem

	return p
}

func (s *GroupByItemContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupByItemContext) AS() antlr.TerminalNode {
	return s.GetToken(KQLParserAS, 0)
}

func (s *GroupByItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GroupByItemContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *GroupByItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterGroupByItem(s)
	}
}

func (s *GroupByItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitGroupByItem(s)
	}
}

func (s *GroupByItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitGroupByItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) GroupByItem() (localctx IGroupByItemContext) {
	localctx = NewGroupByItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, KQLParserRULE_groupByItem)
	var _la int

	p.SetState(732)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(723)
			p.Expression()
		}
		p.SetState(726)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserAS {
			{
				p.SetState(724)
				p.Match(KQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(725)
				p.Identifier()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(728)
			p.Identifier()
		}
		{
			p.SetState(729)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(730)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortOperatorContext is an interface to support dynamic dispatch.
type ISortOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BY() antlr.TerminalNode
	SortList() ISortListContext
	SORT() antlr.TerminalNode
	ORDER() antlr.TerminalNode

	// IsSortOperatorContext differentiates from other interfaces.
	IsSortOperatorContext()
}

type SortOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortOperatorContext() *SortOperatorContext {
	var p = new(SortOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_sortOperator
	return p
}

func InitEmptySortOperatorContext(p *SortOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_sortOperator
}

func (*SortOperatorContext) IsSortOperatorContext() {}

func NewSortOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortOperatorContext {
	var p = new(SortOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_sortOperator

	return p
}

func (s *SortOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *SortOperatorContext) BY() antlr.TerminalNode {
	return s.GetToken(KQLParserBY, 0)
}

func (s *SortOperatorContext) SortList() ISortListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortListContext)
}

func (s *SortOperatorContext) SORT() antlr.TerminalNode {
	return s.GetToken(KQLParserSORT, 0)
}

func (s *SortOperatorContext) ORDER() antlr.TerminalNode {
	return s.GetToken(KQLParserORDER, 0)
}

func (s *SortOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterSortOperator(s)
	}
}

func (s *SortOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitSortOperator(s)
	}
}

func (s *SortOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitSortOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) SortOperator() (localctx ISortOperatorContext) {
	localctx = NewSortOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, KQLParserRULE_sortOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(734)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KQLParserSORT || _la == KQLParserORDER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(735)
		p.Match(KQLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(736)
		p.SortList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortListContext is an interface to support dynamic dispatch.
type ISortListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsSortListContext differentiates from other interfaces.
	IsSortListContext()
}

type SortListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortListContext() *SortListContext {
	var p = new(SortListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_sortList
	return p
}

func InitEmptySortListContext(p *SortListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_sortList
}

func (*SortListContext) IsSortListContext() {}

func NewSortListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortListContext {
	var p = new(SortListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_sortList

	return p
}

func (s *SortListContext) GetParser() antlr.Parser { return s.parser }

func (s *SortListContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *SortListContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *SortListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *SortListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *SortListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterSortList(s)
	}
}

func (s *SortListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitSortList(s)
	}
}

func (s *SortListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitSortList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) SortList() (localctx ISortListContext) {
	localctx = NewSortListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, KQLParserRULE_sortList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		p.SortItem()
	}
	p.SetState(743)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(739)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(740)
			p.SortItem()
		}

		p.SetState(745)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	SortDirection() ISortDirectionContext
	NullsPosition() INullsPositionContext

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_sortItem
	return p
}

func InitEmptySortItemContext(p *SortItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_sortItem
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) SortDirection() ISortDirectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortDirectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortDirectionContext)
}

func (s *SortItemContext) NullsPosition() INullsPositionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullsPositionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullsPositionContext)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (s *SortItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitSortItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, KQLParserRULE_sortItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(746)
		p.Expression()
	}
	p.SetState(748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserASC || _la == KQLParserDESC {
		{
			p.SetState(747)
			p.SortDirection()
		}

	}
	p.SetState(751)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserNULLS {
		{
			p.SetState(750)
			p.NullsPosition()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortDirectionContext is an interface to support dynamic dispatch.
type ISortDirectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsSortDirectionContext differentiates from other interfaces.
	IsSortDirectionContext()
}

type SortDirectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortDirectionContext() *SortDirectionContext {
	var p = new(SortDirectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_sortDirection
	return p
}

func InitEmptySortDirectionContext(p *SortDirectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_sortDirection
}

func (*SortDirectionContext) IsSortDirectionContext() {}

func NewSortDirectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortDirectionContext {
	var p = new(SortDirectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_sortDirection

	return p
}

func (s *SortDirectionContext) GetParser() antlr.Parser { return s.parser }

func (s *SortDirectionContext) ASC() antlr.TerminalNode {
	return s.GetToken(KQLParserASC, 0)
}

func (s *SortDirectionContext) DESC() antlr.TerminalNode {
	return s.GetToken(KQLParserDESC, 0)
}

func (s *SortDirectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortDirectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortDirectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterSortDirection(s)
	}
}

func (s *SortDirectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitSortDirection(s)
	}
}

func (s *SortDirectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitSortDirection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) SortDirection() (localctx ISortDirectionContext) {
	localctx = NewSortDirectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, KQLParserRULE_sortDirection)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(753)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KQLParserASC || _la == KQLParserDESC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullsPositionContext is an interface to support dynamic dispatch.
type INullsPositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULLS() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode

	// IsNullsPositionContext differentiates from other interfaces.
	IsNullsPositionContext()
}

type NullsPositionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullsPositionContext() *NullsPositionContext {
	var p = new(NullsPositionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_nullsPosition
	return p
}

func InitEmptyNullsPositionContext(p *NullsPositionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_nullsPosition
}

func (*NullsPositionContext) IsNullsPositionContext() {}

func NewNullsPositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullsPositionContext {
	var p = new(NullsPositionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_nullsPosition

	return p
}

func (s *NullsPositionContext) GetParser() antlr.Parser { return s.parser }

func (s *NullsPositionContext) NULLS() antlr.TerminalNode {
	return s.GetToken(KQLParserNULLS, 0)
}

func (s *NullsPositionContext) FIRST() antlr.TerminalNode {
	return s.GetToken(KQLParserFIRST, 0)
}

func (s *NullsPositionContext) LAST() antlr.TerminalNode {
	return s.GetToken(KQLParserLAST, 0)
}

func (s *NullsPositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullsPositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullsPositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterNullsPosition(s)
	}
}

func (s *NullsPositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitNullsPosition(s)
	}
}

func (s *NullsPositionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitNullsPosition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) NullsPosition() (localctx INullsPositionContext) {
	localctx = NewNullsPositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, KQLParserRULE_nullsPosition)
	p.SetState(759)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(755)
			p.Match(KQLParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(756)
			p.Match(KQLParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(757)
			p.Match(KQLParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(758)
			p.Match(KQLParserLAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopOperatorContext is an interface to support dynamic dispatch.
type ITopOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TOP() antlr.TerminalNode
	Expression() IExpressionContext
	BY() antlr.TerminalNode
	SortList() ISortListContext

	// IsTopOperatorContext differentiates from other interfaces.
	IsTopOperatorContext()
}

type TopOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopOperatorContext() *TopOperatorContext {
	var p = new(TopOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_topOperator
	return p
}

func InitEmptyTopOperatorContext(p *TopOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_topOperator
}

func (*TopOperatorContext) IsTopOperatorContext() {}

func NewTopOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopOperatorContext {
	var p = new(TopOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_topOperator

	return p
}

func (s *TopOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *TopOperatorContext) TOP() antlr.TerminalNode {
	return s.GetToken(KQLParserTOP, 0)
}

func (s *TopOperatorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TopOperatorContext) BY() antlr.TerminalNode {
	return s.GetToken(KQLParserBY, 0)
}

func (s *TopOperatorContext) SortList() ISortListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortListContext)
}

func (s *TopOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterTopOperator(s)
	}
}

func (s *TopOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitTopOperator(s)
	}
}

func (s *TopOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitTopOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) TopOperator() (localctx ITopOperatorContext) {
	localctx = NewTopOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, KQLParserRULE_topOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(761)
		p.Match(KQLParserTOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(762)
		p.Expression()
	}
	{
		p.SetState(763)
		p.Match(KQLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(764)
		p.SortList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopNestedOperatorContext is an interface to support dynamic dispatch.
type ITopNestedOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TOP_NESTED() antlr.TerminalNode
	AllTopNestedClause() []ITopNestedClauseContext
	TopNestedClause(i int) ITopNestedClauseContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsTopNestedOperatorContext differentiates from other interfaces.
	IsTopNestedOperatorContext()
}

type TopNestedOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopNestedOperatorContext() *TopNestedOperatorContext {
	var p = new(TopNestedOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_topNestedOperator
	return p
}

func InitEmptyTopNestedOperatorContext(p *TopNestedOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_topNestedOperator
}

func (*TopNestedOperatorContext) IsTopNestedOperatorContext() {}

func NewTopNestedOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopNestedOperatorContext {
	var p = new(TopNestedOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_topNestedOperator

	return p
}

func (s *TopNestedOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *TopNestedOperatorContext) TOP_NESTED() antlr.TerminalNode {
	return s.GetToken(KQLParserTOP_NESTED, 0)
}

func (s *TopNestedOperatorContext) AllTopNestedClause() []ITopNestedClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITopNestedClauseContext); ok {
			len++
		}
	}

	tst := make([]ITopNestedClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITopNestedClauseContext); ok {
			tst[i] = t.(ITopNestedClauseContext)
			i++
		}
	}

	return tst
}

func (s *TopNestedOperatorContext) TopNestedClause(i int) ITopNestedClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITopNestedClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITopNestedClauseContext)
}

func (s *TopNestedOperatorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *TopNestedOperatorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *TopNestedOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopNestedOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopNestedOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterTopNestedOperator(s)
	}
}

func (s *TopNestedOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitTopNestedOperator(s)
	}
}

func (s *TopNestedOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitTopNestedOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) TopNestedOperator() (localctx ITopNestedOperatorContext) {
	localctx = NewTopNestedOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, KQLParserRULE_topNestedOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(766)
		p.Match(KQLParserTOP_NESTED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(767)
		p.TopNestedClause()
	}
	p.SetState(772)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(768)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(769)
			p.TopNestedClause()
		}

		p.SetState(774)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITopNestedClauseContext is an interface to support dynamic dispatch.
type ITopNestedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	BY() antlr.TerminalNode
	OF() antlr.TerminalNode
	Identifier() IIdentifierContext
	WITH() antlr.TerminalNode
	OTHERS() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode

	// IsTopNestedClauseContext differentiates from other interfaces.
	IsTopNestedClauseContext()
}

type TopNestedClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTopNestedClauseContext() *TopNestedClauseContext {
	var p = new(TopNestedClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_topNestedClause
	return p
}

func InitEmptyTopNestedClauseContext(p *TopNestedClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_topNestedClause
}

func (*TopNestedClauseContext) IsTopNestedClauseContext() {}

func NewTopNestedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TopNestedClauseContext {
	var p = new(TopNestedClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_topNestedClause

	return p
}

func (s *TopNestedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TopNestedClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TopNestedClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TopNestedClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(KQLParserBY, 0)
}

func (s *TopNestedClauseContext) OF() antlr.TerminalNode {
	return s.GetToken(KQLParserOF, 0)
}

func (s *TopNestedClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TopNestedClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(KQLParserWITH, 0)
}

func (s *TopNestedClauseContext) OTHERS() antlr.TerminalNode {
	return s.GetToken(KQLParserOTHERS, 0)
}

func (s *TopNestedClauseContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *TopNestedClauseContext) ASC() antlr.TerminalNode {
	return s.GetToken(KQLParserASC, 0)
}

func (s *TopNestedClauseContext) DESC() antlr.TerminalNode {
	return s.GetToken(KQLParserDESC, 0)
}

func (s *TopNestedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TopNestedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TopNestedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterTopNestedClause(s)
	}
}

func (s *TopNestedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitTopNestedClause(s)
	}
}

func (s *TopNestedClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitTopNestedClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) TopNestedClause() (localctx ITopNestedClauseContext) {
	localctx = NewTopNestedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, KQLParserRULE_topNestedClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(777)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(775)
			p.Match(KQLParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(776)
			p.Identifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(779)
		p.Expression()
	}
	{
		p.SetState(780)
		p.Match(KQLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(781)
		p.Expression()
	}
	p.SetState(783)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserASC || _la == KQLParserDESC {
		{
			p.SetState(782)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KQLParserASC || _la == KQLParserDESC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(789)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserWITH {
		{
			p.SetState(785)
			p.Match(KQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(786)
			p.Match(KQLParserOTHERS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(787)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(788)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITakeOperatorContext is an interface to support dynamic dispatch.
type ITakeOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	TAKE() antlr.TerminalNode
	LIMIT() antlr.TerminalNode

	// IsTakeOperatorContext differentiates from other interfaces.
	IsTakeOperatorContext()
}

type TakeOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTakeOperatorContext() *TakeOperatorContext {
	var p = new(TakeOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_takeOperator
	return p
}

func InitEmptyTakeOperatorContext(p *TakeOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_takeOperator
}

func (*TakeOperatorContext) IsTakeOperatorContext() {}

func NewTakeOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TakeOperatorContext {
	var p = new(TakeOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_takeOperator

	return p
}

func (s *TakeOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *TakeOperatorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TakeOperatorContext) TAKE() antlr.TerminalNode {
	return s.GetToken(KQLParserTAKE, 0)
}

func (s *TakeOperatorContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(KQLParserLIMIT, 0)
}

func (s *TakeOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TakeOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TakeOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterTakeOperator(s)
	}
}

func (s *TakeOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitTakeOperator(s)
	}
}

func (s *TakeOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitTakeOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) TakeOperator() (localctx ITakeOperatorContext) {
	localctx = NewTakeOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, KQLParserRULE_takeOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(791)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KQLParserTAKE || _la == KQLParserLIMIT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(792)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistinctOperatorContext is an interface to support dynamic dispatch.
type IDistinctOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTINCT() antlr.TerminalNode
	DistinctColumns() IDistinctColumnsContext

	// IsDistinctOperatorContext differentiates from other interfaces.
	IsDistinctOperatorContext()
}

type DistinctOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistinctOperatorContext() *DistinctOperatorContext {
	var p = new(DistinctOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_distinctOperator
	return p
}

func InitEmptyDistinctOperatorContext(p *DistinctOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_distinctOperator
}

func (*DistinctOperatorContext) IsDistinctOperatorContext() {}

func NewDistinctOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistinctOperatorContext {
	var p = new(DistinctOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_distinctOperator

	return p
}

func (s *DistinctOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *DistinctOperatorContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(KQLParserDISTINCT, 0)
}

func (s *DistinctOperatorContext) DistinctColumns() IDistinctColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistinctColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistinctColumnsContext)
}

func (s *DistinctOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistinctOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterDistinctOperator(s)
	}
}

func (s *DistinctOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitDistinctOperator(s)
	}
}

func (s *DistinctOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitDistinctOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) DistinctOperator() (localctx IDistinctOperatorContext) {
	localctx = NewDistinctOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, KQLParserRULE_distinctOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(794)
		p.Match(KQLParserDISTINCT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(796)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1722596028691838186) != 0) || _la == KQLParserRIGHT || _la == KQLParserSTAR || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&-9187360625863417885) != 0) {
		{
			p.SetState(795)
			p.DistinctColumns()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistinctColumnsContext is an interface to support dynamic dispatch.
type IDistinctColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierOrWildcardList() IIdentifierOrWildcardListContext
	STAR() antlr.TerminalNode

	// IsDistinctColumnsContext differentiates from other interfaces.
	IsDistinctColumnsContext()
}

type DistinctColumnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistinctColumnsContext() *DistinctColumnsContext {
	var p = new(DistinctColumnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_distinctColumns
	return p
}

func InitEmptyDistinctColumnsContext(p *DistinctColumnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_distinctColumns
}

func (*DistinctColumnsContext) IsDistinctColumnsContext() {}

func NewDistinctColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistinctColumnsContext {
	var p = new(DistinctColumnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_distinctColumns

	return p
}

func (s *DistinctColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *DistinctColumnsContext) IdentifierOrWildcardList() IIdentifierOrWildcardListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrWildcardListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrWildcardListContext)
}

func (s *DistinctColumnsContext) STAR() antlr.TerminalNode {
	return s.GetToken(KQLParserSTAR, 0)
}

func (s *DistinctColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistinctColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterDistinctColumns(s)
	}
}

func (s *DistinctColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitDistinctColumns(s)
	}
}

func (s *DistinctColumnsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitDistinctColumns(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) DistinctColumns() (localctx IDistinctColumnsContext) {
	localctx = NewDistinctColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, KQLParserRULE_distinctColumns)
	p.SetState(800)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(798)
			p.IdentifierOrWildcardList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(799)
			p.Match(KQLParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICountOperatorContext is an interface to support dynamic dispatch.
type ICountOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COUNT() antlr.TerminalNode

	// IsCountOperatorContext differentiates from other interfaces.
	IsCountOperatorContext()
}

type CountOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCountOperatorContext() *CountOperatorContext {
	var p = new(CountOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_countOperator
	return p
}

func InitEmptyCountOperatorContext(p *CountOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_countOperator
}

func (*CountOperatorContext) IsCountOperatorContext() {}

func NewCountOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CountOperatorContext {
	var p = new(CountOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_countOperator

	return p
}

func (s *CountOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *CountOperatorContext) COUNT() antlr.TerminalNode {
	return s.GetToken(KQLParserCOUNT, 0)
}

func (s *CountOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CountOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CountOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterCountOperator(s)
	}
}

func (s *CountOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitCountOperator(s)
	}
}

func (s *CountOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitCountOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) CountOperator() (localctx ICountOperatorContext) {
	localctx = NewCountOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, KQLParserRULE_countOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(802)
		p.Match(KQLParserCOUNT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinOperatorContext is an interface to support dynamic dispatch.
type IJoinOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JOIN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	TabularExpression() ITabularExpressionContext
	RPAREN() antlr.TerminalNode
	ON() antlr.TerminalNode
	JoinCondition() IJoinConditionContext
	JoinKind() IJoinKindContext
	JoinHints() IJoinHintsContext
	TableName() ITableNameContext

	// IsJoinOperatorContext differentiates from other interfaces.
	IsJoinOperatorContext()
}

type JoinOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinOperatorContext() *JoinOperatorContext {
	var p = new(JoinOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_joinOperator
	return p
}

func InitEmptyJoinOperatorContext(p *JoinOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_joinOperator
}

func (*JoinOperatorContext) IsJoinOperatorContext() {}

func NewJoinOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinOperatorContext {
	var p = new(JoinOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_joinOperator

	return p
}

func (s *JoinOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinOperatorContext) JOIN() antlr.TerminalNode {
	return s.GetToken(KQLParserJOIN, 0)
}

func (s *JoinOperatorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *JoinOperatorContext) TabularExpression() ITabularExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabularExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabularExpressionContext)
}

func (s *JoinOperatorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *JoinOperatorContext) ON() antlr.TerminalNode {
	return s.GetToken(KQLParserON, 0)
}

func (s *JoinOperatorContext) JoinCondition() IJoinConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinConditionContext)
}

func (s *JoinOperatorContext) JoinKind() IJoinKindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinKindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinKindContext)
}

func (s *JoinOperatorContext) JoinHints() IJoinHintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinHintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinHintsContext)
}

func (s *JoinOperatorContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *JoinOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterJoinOperator(s)
	}
}

func (s *JoinOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitJoinOperator(s)
	}
}

func (s *JoinOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitJoinOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) JoinOperator() (localctx IJoinOperatorContext) {
	localctx = NewJoinOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, KQLParserRULE_joinOperator)
	var _la int

	p.SetState(828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(804)
			p.Match(KQLParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(806)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserKIND {
			{
				p.SetState(805)
				p.JoinKind()
			}

		}
		p.SetState(809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserHINT_DOT {
			{
				p.SetState(808)
				p.JoinHints()
			}

		}
		{
			p.SetState(811)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(812)
			p.TabularExpression()
		}
		{
			p.SetState(813)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(814)
			p.Match(KQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(815)
			p.JoinCondition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(817)
			p.Match(KQLParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(819)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 53, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(818)
				p.JoinKind()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(822)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserHINT_DOT {
			{
				p.SetState(821)
				p.JoinHints()
			}

		}
		{
			p.SetState(824)
			p.TableName()
		}
		{
			p.SetState(825)
			p.Match(KQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(826)
			p.JoinCondition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinKindContext is an interface to support dynamic dispatch.
type IJoinKindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KIND() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	JoinFlavor() IJoinFlavorContext

	// IsJoinKindContext differentiates from other interfaces.
	IsJoinKindContext()
}

type JoinKindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinKindContext() *JoinKindContext {
	var p = new(JoinKindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_joinKind
	return p
}

func InitEmptyJoinKindContext(p *JoinKindContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_joinKind
}

func (*JoinKindContext) IsJoinKindContext() {}

func NewJoinKindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinKindContext {
	var p = new(JoinKindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_joinKind

	return p
}

func (s *JoinKindContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinKindContext) KIND() antlr.TerminalNode {
	return s.GetToken(KQLParserKIND, 0)
}

func (s *JoinKindContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *JoinKindContext) JoinFlavor() IJoinFlavorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinFlavorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinFlavorContext)
}

func (s *JoinKindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinKindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinKindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterJoinKind(s)
	}
}

func (s *JoinKindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitJoinKind(s)
	}
}

func (s *JoinKindContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitJoinKind(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) JoinKind() (localctx IJoinKindContext) {
	localctx = NewJoinKindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, KQLParserRULE_joinKind)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(830)
		p.Match(KQLParserKIND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(831)
		p.Match(KQLParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(832)
		p.JoinFlavor()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinFlavorContext is an interface to support dynamic dispatch.
type IJoinFlavorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INNER() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	FULL() antlr.TerminalNode
	LEFTSEMI() antlr.TerminalNode
	RIGHTSEMI() antlr.TerminalNode
	LEFTANTI() antlr.TerminalNode
	RIGHTANTI() antlr.TerminalNode
	LEFTOUTER() antlr.TerminalNode
	RIGHTOUTER() antlr.TerminalNode
	FULLOUTER() antlr.TerminalNode
	INNERUNIQUE() antlr.TerminalNode
	ANTI() antlr.TerminalNode
	SEMI() antlr.TerminalNode

	// IsJoinFlavorContext differentiates from other interfaces.
	IsJoinFlavorContext()
}

type JoinFlavorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinFlavorContext() *JoinFlavorContext {
	var p = new(JoinFlavorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_joinFlavor
	return p
}

func InitEmptyJoinFlavorContext(p *JoinFlavorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_joinFlavor
}

func (*JoinFlavorContext) IsJoinFlavorContext() {}

func NewJoinFlavorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinFlavorContext {
	var p = new(JoinFlavorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_joinFlavor

	return p
}

func (s *JoinFlavorContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinFlavorContext) INNER() antlr.TerminalNode {
	return s.GetToken(KQLParserINNER, 0)
}

func (s *JoinFlavorContext) OUTER() antlr.TerminalNode {
	return s.GetToken(KQLParserOUTER, 0)
}

func (s *JoinFlavorContext) LEFT() antlr.TerminalNode {
	return s.GetToken(KQLParserLEFT, 0)
}

func (s *JoinFlavorContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(KQLParserRIGHT, 0)
}

func (s *JoinFlavorContext) FULL() antlr.TerminalNode {
	return s.GetToken(KQLParserFULL, 0)
}

func (s *JoinFlavorContext) LEFTSEMI() antlr.TerminalNode {
	return s.GetToken(KQLParserLEFTSEMI, 0)
}

func (s *JoinFlavorContext) RIGHTSEMI() antlr.TerminalNode {
	return s.GetToken(KQLParserRIGHTSEMI, 0)
}

func (s *JoinFlavorContext) LEFTANTI() antlr.TerminalNode {
	return s.GetToken(KQLParserLEFTANTI, 0)
}

func (s *JoinFlavorContext) RIGHTANTI() antlr.TerminalNode {
	return s.GetToken(KQLParserRIGHTANTI, 0)
}

func (s *JoinFlavorContext) LEFTOUTER() antlr.TerminalNode {
	return s.GetToken(KQLParserLEFTOUTER, 0)
}

func (s *JoinFlavorContext) RIGHTOUTER() antlr.TerminalNode {
	return s.GetToken(KQLParserRIGHTOUTER, 0)
}

func (s *JoinFlavorContext) FULLOUTER() antlr.TerminalNode {
	return s.GetToken(KQLParserFULLOUTER, 0)
}

func (s *JoinFlavorContext) INNERUNIQUE() antlr.TerminalNode {
	return s.GetToken(KQLParserINNERUNIQUE, 0)
}

func (s *JoinFlavorContext) ANTI() antlr.TerminalNode {
	return s.GetToken(KQLParserANTI, 0)
}

func (s *JoinFlavorContext) SEMI() antlr.TerminalNode {
	return s.GetToken(KQLParserSEMI, 0)
}

func (s *JoinFlavorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinFlavorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinFlavorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterJoinFlavor(s)
	}
}

func (s *JoinFlavorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitJoinFlavor(s)
	}
}

func (s *JoinFlavorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitJoinFlavor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) JoinFlavor() (localctx IJoinFlavorContext) {
	localctx = NewJoinFlavorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, KQLParserRULE_joinFlavor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(834)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-61)) & ^0x3f) == 0 && ((int64(1)<<(_la-61))&32767) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinHintsContext is an interface to support dynamic dispatch.
type IJoinHintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllJoinHint() []IJoinHintContext
	JoinHint(i int) IJoinHintContext

	// IsJoinHintsContext differentiates from other interfaces.
	IsJoinHintsContext()
}

type JoinHintsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinHintsContext() *JoinHintsContext {
	var p = new(JoinHintsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_joinHints
	return p
}

func InitEmptyJoinHintsContext(p *JoinHintsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_joinHints
}

func (*JoinHintsContext) IsJoinHintsContext() {}

func NewJoinHintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinHintsContext {
	var p = new(JoinHintsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_joinHints

	return p
}

func (s *JoinHintsContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinHintsContext) AllJoinHint() []IJoinHintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinHintContext); ok {
			len++
		}
	}

	tst := make([]IJoinHintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinHintContext); ok {
			tst[i] = t.(IJoinHintContext)
			i++
		}
	}

	return tst
}

func (s *JoinHintsContext) JoinHint(i int) IJoinHintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinHintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinHintContext)
}

func (s *JoinHintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinHintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinHintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterJoinHints(s)
	}
}

func (s *JoinHintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitJoinHints(s)
	}
}

func (s *JoinHintsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitJoinHints(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) JoinHints() (localctx IJoinHintsContext) {
	localctx = NewJoinHintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, KQLParserRULE_joinHints)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == KQLParserHINT_DOT {
		{
			p.SetState(836)
			p.JoinHint()
		}

		p.SetState(839)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinHintContext is an interface to support dynamic dispatch.
type IJoinHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HINT_DOT() antlr.TerminalNode
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsJoinHintContext differentiates from other interfaces.
	IsJoinHintContext()
}

type JoinHintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinHintContext() *JoinHintContext {
	var p = new(JoinHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_joinHint
	return p
}

func InitEmptyJoinHintContext(p *JoinHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_joinHint
}

func (*JoinHintContext) IsJoinHintContext() {}

func NewJoinHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinHintContext {
	var p = new(JoinHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_joinHint

	return p
}

func (s *JoinHintContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinHintContext) HINT_DOT() antlr.TerminalNode {
	return s.GetToken(KQLParserHINT_DOT, 0)
}

func (s *JoinHintContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JoinHintContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *JoinHintContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JoinHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterJoinHint(s)
	}
}

func (s *JoinHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitJoinHint(s)
	}
}

func (s *JoinHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitJoinHint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) JoinHint() (localctx IJoinHintContext) {
	localctx = NewJoinHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, KQLParserRULE_joinHint)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(841)
		p.Match(KQLParserHINT_DOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(842)
		p.Identifier()
	}
	{
		p.SetState(843)
		p.Match(KQLParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(844)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinConditionContext is an interface to support dynamic dispatch.
type IJoinConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllJoinAttribute() []IJoinAttributeContext
	JoinAttribute(i int) IJoinAttributeContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	Expression() IExpressionContext

	// IsJoinConditionContext differentiates from other interfaces.
	IsJoinConditionContext()
}

type JoinConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinConditionContext() *JoinConditionContext {
	var p = new(JoinConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_joinCondition
	return p
}

func InitEmptyJoinConditionContext(p *JoinConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_joinCondition
}

func (*JoinConditionContext) IsJoinConditionContext() {}

func NewJoinConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinConditionContext {
	var p = new(JoinConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_joinCondition

	return p
}

func (s *JoinConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinConditionContext) AllJoinAttribute() []IJoinAttributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinAttributeContext); ok {
			len++
		}
	}

	tst := make([]IJoinAttributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinAttributeContext); ok {
			tst[i] = t.(IJoinAttributeContext)
			i++
		}
	}

	return tst
}

func (s *JoinConditionContext) JoinAttribute(i int) IJoinAttributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinAttributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinAttributeContext)
}

func (s *JoinConditionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *JoinConditionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *JoinConditionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JoinConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterJoinCondition(s)
	}
}

func (s *JoinConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitJoinCondition(s)
	}
}

func (s *JoinConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitJoinCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) JoinCondition() (localctx IJoinConditionContext) {
	localctx = NewJoinConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, KQLParserRULE_joinCondition)
	var _la int

	p.SetState(855)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(846)
			p.JoinAttribute()
		}
		p.SetState(851)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KQLParserCOMMA {
			{
				p.SetState(847)
				p.Match(KQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(848)
				p.JoinAttribute()
			}

			p.SetState(853)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(854)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinAttributeContext is an interface to support dynamic dispatch.
type IJoinAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOLLAR() []antlr.TerminalNode
	DOLLAR(i int) antlr.TerminalNode
	LEFT() antlr.TerminalNode
	AllDOT() []antlr.TerminalNode
	DOT(i int) antlr.TerminalNode
	EQ() antlr.TerminalNode
	RIGHT() antlr.TerminalNode

	// IsJoinAttributeContext differentiates from other interfaces.
	IsJoinAttributeContext()
}

type JoinAttributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinAttributeContext() *JoinAttributeContext {
	var p = new(JoinAttributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_joinAttribute
	return p
}

func InitEmptyJoinAttributeContext(p *JoinAttributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_joinAttribute
}

func (*JoinAttributeContext) IsJoinAttributeContext() {}

func NewJoinAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinAttributeContext {
	var p = new(JoinAttributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_joinAttribute

	return p
}

func (s *JoinAttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinAttributeContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *JoinAttributeContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JoinAttributeContext) AllDOLLAR() []antlr.TerminalNode {
	return s.GetTokens(KQLParserDOLLAR)
}

func (s *JoinAttributeContext) DOLLAR(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserDOLLAR, i)
}

func (s *JoinAttributeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(KQLParserLEFT, 0)
}

func (s *JoinAttributeContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(KQLParserDOT)
}

func (s *JoinAttributeContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserDOT, i)
}

func (s *JoinAttributeContext) EQ() antlr.TerminalNode {
	return s.GetToken(KQLParserEQ, 0)
}

func (s *JoinAttributeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(KQLParserRIGHT, 0)
}

func (s *JoinAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinAttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterJoinAttribute(s)
	}
}

func (s *JoinAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitJoinAttribute(s)
	}
}

func (s *JoinAttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitJoinAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) JoinAttribute() (localctx IJoinAttributeContext) {
	localctx = NewJoinAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, KQLParserRULE_joinAttribute)
	p.SetState(868)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KQLParserWHERE, KQLParserSEARCH, KQLParserTAKE, KQLParserDISTINCT, KQLParserCOUNT, KQLParserPROJECT, KQLParserEXTEND, KQLParserPARSE, KQLParserSORT, KQLParserTOP, KQLParserSUMMARIZE, KQLParserJOIN, KQLParserLOOKUP, KQLParserUNION, KQLParserAS, KQLParserEVALUATE, KQLParserRANGE, KQLParserPRINT, KQLParserRENDER, KQLParserLET, KQLParserSET, KQLParserKIND, KQLParserINNER, KQLParserOUTER, KQLParserLEFT, KQLParserRIGHT, KQLParserASC, KQLParserDESC, KQLParserBY, KQLParserON, KQLParserWITH, KQLParserOF, KQLParserTO, KQLParserFROM, KQLParserSTEP, KQLParserDEFAULT, KQLParserTRUE, KQLParserFALSE, KQLParserTYPE_BOOL, KQLParserTYPE_DATETIME, KQLParserTYPE_DECIMAL, KQLParserTYPE_DOUBLE, KQLParserTYPE_DYNAMIC, KQLParserTYPE_GUID, KQLParserTYPE_INT, KQLParserTYPE_LONG, KQLParserTYPE_REAL, KQLParserTYPE_STRING, KQLParserTYPE_TIMESPAN, KQLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(857)
			p.Identifier()
		}

	case KQLParserDOLLAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(858)
			p.Match(KQLParserDOLLAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(859)
			p.Match(KQLParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(860)
			p.Match(KQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(861)
			p.Identifier()
		}
		{
			p.SetState(862)
			p.Match(KQLParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(863)
			p.Match(KQLParserDOLLAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(864)
			p.Match(KQLParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(865)
			p.Match(KQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(866)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnionOperatorContext is an interface to support dynamic dispatch.
type IUnionOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNION() antlr.TerminalNode
	UnionTables() IUnionTablesContext
	UnionParameters() IUnionParametersContext

	// IsUnionOperatorContext differentiates from other interfaces.
	IsUnionOperatorContext()
}

type UnionOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionOperatorContext() *UnionOperatorContext {
	var p = new(UnionOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_unionOperator
	return p
}

func InitEmptyUnionOperatorContext(p *UnionOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_unionOperator
}

func (*UnionOperatorContext) IsUnionOperatorContext() {}

func NewUnionOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionOperatorContext {
	var p = new(UnionOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_unionOperator

	return p
}

func (s *UnionOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionOperatorContext) UNION() antlr.TerminalNode {
	return s.GetToken(KQLParserUNION, 0)
}

func (s *UnionOperatorContext) UnionTables() IUnionTablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionTablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionTablesContext)
}

func (s *UnionOperatorContext) UnionParameters() IUnionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionParametersContext)
}

func (s *UnionOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterUnionOperator(s)
	}
}

func (s *UnionOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitUnionOperator(s)
	}
}

func (s *UnionOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitUnionOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) UnionOperator() (localctx IUnionOperatorContext) {
	localctx = NewUnionOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, KQLParserRULE_unionOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(870)
		p.Match(KQLParserUNION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(872)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(871)
			p.UnionParameters()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(874)
		p.UnionTables()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnionParametersContext is an interface to support dynamic dispatch.
type IUnionParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUnionParameter() []IUnionParameterContext
	UnionParameter(i int) IUnionParameterContext

	// IsUnionParametersContext differentiates from other interfaces.
	IsUnionParametersContext()
}

type UnionParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionParametersContext() *UnionParametersContext {
	var p = new(UnionParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_unionParameters
	return p
}

func InitEmptyUnionParametersContext(p *UnionParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_unionParameters
}

func (*UnionParametersContext) IsUnionParametersContext() {}

func NewUnionParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionParametersContext {
	var p = new(UnionParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_unionParameters

	return p
}

func (s *UnionParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionParametersContext) AllUnionParameter() []IUnionParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnionParameterContext); ok {
			len++
		}
	}

	tst := make([]IUnionParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnionParameterContext); ok {
			tst[i] = t.(IUnionParameterContext)
			i++
		}
	}

	return tst
}

func (s *UnionParametersContext) UnionParameter(i int) IUnionParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionParameterContext)
}

func (s *UnionParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterUnionParameters(s)
	}
}

func (s *UnionParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitUnionParameters(s)
	}
}

func (s *UnionParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitUnionParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) UnionParameters() (localctx IUnionParametersContext) {
	localctx = NewUnionParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, KQLParserRULE_unionParameters)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(877)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(876)
				p.UnionParameter()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(879)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnionParameterContext is an interface to support dynamic dispatch.
type IUnionParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KIND() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	Identifier() IIdentifierContext
	WITH_SOURCE() antlr.TerminalNode
	IS_FUZZY() antlr.TerminalNode
	BooleanLiteral() IBooleanLiteralContext

	// IsUnionParameterContext differentiates from other interfaces.
	IsUnionParameterContext()
}

type UnionParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionParameterContext() *UnionParameterContext {
	var p = new(UnionParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_unionParameter
	return p
}

func InitEmptyUnionParameterContext(p *UnionParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_unionParameter
}

func (*UnionParameterContext) IsUnionParameterContext() {}

func NewUnionParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionParameterContext {
	var p = new(UnionParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_unionParameter

	return p
}

func (s *UnionParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionParameterContext) KIND() antlr.TerminalNode {
	return s.GetToken(KQLParserKIND, 0)
}

func (s *UnionParameterContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *UnionParameterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnionParameterContext) WITH_SOURCE() antlr.TerminalNode {
	return s.GetToken(KQLParserWITH_SOURCE, 0)
}

func (s *UnionParameterContext) IS_FUZZY() antlr.TerminalNode {
	return s.GetToken(KQLParserIS_FUZZY, 0)
}

func (s *UnionParameterContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *UnionParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterUnionParameter(s)
	}
}

func (s *UnionParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitUnionParameter(s)
	}
}

func (s *UnionParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitUnionParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) UnionParameter() (localctx IUnionParameterContext) {
	localctx = NewUnionParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, KQLParserRULE_unionParameter)
	p.SetState(890)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KQLParserKIND:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(881)
			p.Match(KQLParserKIND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(882)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(883)
			p.Identifier()
		}

	case KQLParserWITH_SOURCE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(884)
			p.Match(KQLParserWITH_SOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(885)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(886)
			p.Identifier()
		}

	case KQLParserIS_FUZZY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(887)
			p.Match(KQLParserIS_FUZZY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(888)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(889)
			p.BooleanLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnionTablesContext is an interface to support dynamic dispatch.
type IUnionTablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUnionTable() []IUnionTableContext
	UnionTable(i int) IUnionTableContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsUnionTablesContext differentiates from other interfaces.
	IsUnionTablesContext()
}

type UnionTablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionTablesContext() *UnionTablesContext {
	var p = new(UnionTablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_unionTables
	return p
}

func InitEmptyUnionTablesContext(p *UnionTablesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_unionTables
}

func (*UnionTablesContext) IsUnionTablesContext() {}

func NewUnionTablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionTablesContext {
	var p = new(UnionTablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_unionTables

	return p
}

func (s *UnionTablesContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionTablesContext) AllUnionTable() []IUnionTableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnionTableContext); ok {
			len++
		}
	}

	tst := make([]IUnionTableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnionTableContext); ok {
			tst[i] = t.(IUnionTableContext)
			i++
		}
	}

	return tst
}

func (s *UnionTablesContext) UnionTable(i int) IUnionTableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnionTableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnionTableContext)
}

func (s *UnionTablesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *UnionTablesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *UnionTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionTablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterUnionTables(s)
	}
}

func (s *UnionTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitUnionTables(s)
	}
}

func (s *UnionTablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitUnionTables(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) UnionTables() (localctx IUnionTablesContext) {
	localctx = NewUnionTablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, KQLParserRULE_unionTables)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(892)
		p.UnionTable()
	}
	p.SetState(897)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(893)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(894)
			p.UnionTable()
		}

		p.SetState(899)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnionTableContext is an interface to support dynamic dispatch.
type IUnionTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	TabularExpression() ITabularExpressionContext
	RPAREN() antlr.TerminalNode
	TableName() ITableNameContext

	// IsUnionTableContext differentiates from other interfaces.
	IsUnionTableContext()
}

type UnionTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnionTableContext() *UnionTableContext {
	var p = new(UnionTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_unionTable
	return p
}

func InitEmptyUnionTableContext(p *UnionTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_unionTable
}

func (*UnionTableContext) IsUnionTableContext() {}

func NewUnionTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnionTableContext {
	var p = new(UnionTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_unionTable

	return p
}

func (s *UnionTableContext) GetParser() antlr.Parser { return s.parser }

func (s *UnionTableContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *UnionTableContext) TabularExpression() ITabularExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabularExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabularExpressionContext)
}

func (s *UnionTableContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *UnionTableContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *UnionTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnionTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnionTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterUnionTable(s)
	}
}

func (s *UnionTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitUnionTable(s)
	}
}

func (s *UnionTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitUnionTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) UnionTable() (localctx IUnionTableContext) {
	localctx = NewUnionTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, KQLParserRULE_unionTable)
	p.SetState(905)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KQLParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(900)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(901)
			p.TabularExpression()
		}
		{
			p.SetState(902)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserWHERE, KQLParserSEARCH, KQLParserTAKE, KQLParserDISTINCT, KQLParserCOUNT, KQLParserPROJECT, KQLParserEXTEND, KQLParserPARSE, KQLParserSORT, KQLParserTOP, KQLParserSUMMARIZE, KQLParserJOIN, KQLParserLOOKUP, KQLParserUNION, KQLParserAS, KQLParserEVALUATE, KQLParserRANGE, KQLParserPRINT, KQLParserRENDER, KQLParserLET, KQLParserSET, KQLParserKIND, KQLParserINNER, KQLParserOUTER, KQLParserLEFT, KQLParserRIGHT, KQLParserASC, KQLParserDESC, KQLParserBY, KQLParserON, KQLParserWITH, KQLParserOF, KQLParserTO, KQLParserFROM, KQLParserSTEP, KQLParserDEFAULT, KQLParserTRUE, KQLParserFALSE, KQLParserTYPE_BOOL, KQLParserTYPE_DATETIME, KQLParserTYPE_DECIMAL, KQLParserTYPE_DOUBLE, KQLParserTYPE_DYNAMIC, KQLParserTYPE_GUID, KQLParserTYPE_INT, KQLParserTYPE_LONG, KQLParserTYPE_REAL, KQLParserTYPE_STRING, KQLParserTYPE_TIMESPAN, KQLParserIDENTIFIER, KQLParserQUOTED_IDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(904)
			p.TableName()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILookupOperatorContext is an interface to support dynamic dispatch.
type ILookupOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOOKUP() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	TabularExpression() ITabularExpressionContext
	RPAREN() antlr.TerminalNode
	ON() antlr.TerminalNode
	LookupCondition() ILookupConditionContext
	LookupKind() ILookupKindContext
	TableName() ITableNameContext

	// IsLookupOperatorContext differentiates from other interfaces.
	IsLookupOperatorContext()
}

type LookupOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLookupOperatorContext() *LookupOperatorContext {
	var p = new(LookupOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_lookupOperator
	return p
}

func InitEmptyLookupOperatorContext(p *LookupOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_lookupOperator
}

func (*LookupOperatorContext) IsLookupOperatorContext() {}

func NewLookupOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LookupOperatorContext {
	var p = new(LookupOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_lookupOperator

	return p
}

func (s *LookupOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *LookupOperatorContext) LOOKUP() antlr.TerminalNode {
	return s.GetToken(KQLParserLOOKUP, 0)
}

func (s *LookupOperatorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *LookupOperatorContext) TabularExpression() ITabularExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabularExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabularExpressionContext)
}

func (s *LookupOperatorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *LookupOperatorContext) ON() antlr.TerminalNode {
	return s.GetToken(KQLParserON, 0)
}

func (s *LookupOperatorContext) LookupCondition() ILookupConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILookupConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILookupConditionContext)
}

func (s *LookupOperatorContext) LookupKind() ILookupKindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILookupKindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILookupKindContext)
}

func (s *LookupOperatorContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *LookupOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LookupOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LookupOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterLookupOperator(s)
	}
}

func (s *LookupOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitLookupOperator(s)
	}
}

func (s *LookupOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitLookupOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) LookupOperator() (localctx ILookupOperatorContext) {
	localctx = NewLookupOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, KQLParserRULE_lookupOperator)
	var _la int

	p.SetState(925)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(907)
			p.Match(KQLParserLOOKUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(909)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserKIND {
			{
				p.SetState(908)
				p.LookupKind()
			}

		}
		{
			p.SetState(911)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(912)
			p.TabularExpression()
		}
		{
			p.SetState(913)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(914)
			p.Match(KQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(915)
			p.LookupCondition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(917)
			p.Match(KQLParserLOOKUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(919)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(918)
				p.LookupKind()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(921)
			p.TableName()
		}
		{
			p.SetState(922)
			p.Match(KQLParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(923)
			p.LookupCondition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILookupKindContext is an interface to support dynamic dispatch.
type ILookupKindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KIND() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsLookupKindContext differentiates from other interfaces.
	IsLookupKindContext()
}

type LookupKindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLookupKindContext() *LookupKindContext {
	var p = new(LookupKindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_lookupKind
	return p
}

func InitEmptyLookupKindContext(p *LookupKindContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_lookupKind
}

func (*LookupKindContext) IsLookupKindContext() {}

func NewLookupKindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LookupKindContext {
	var p = new(LookupKindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_lookupKind

	return p
}

func (s *LookupKindContext) GetParser() antlr.Parser { return s.parser }

func (s *LookupKindContext) KIND() antlr.TerminalNode {
	return s.GetToken(KQLParserKIND, 0)
}

func (s *LookupKindContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *LookupKindContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LookupKindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LookupKindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LookupKindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterLookupKind(s)
	}
}

func (s *LookupKindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitLookupKind(s)
	}
}

func (s *LookupKindContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitLookupKind(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) LookupKind() (localctx ILookupKindContext) {
	localctx = NewLookupKindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, KQLParserRULE_lookupKind)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(927)
		p.Match(KQLParserKIND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(928)
		p.Match(KQLParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(929)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILookupConditionContext is an interface to support dynamic dispatch.
type ILookupConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JoinCondition() IJoinConditionContext

	// IsLookupConditionContext differentiates from other interfaces.
	IsLookupConditionContext()
}

type LookupConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLookupConditionContext() *LookupConditionContext {
	var p = new(LookupConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_lookupCondition
	return p
}

func InitEmptyLookupConditionContext(p *LookupConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_lookupCondition
}

func (*LookupConditionContext) IsLookupConditionContext() {}

func NewLookupConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LookupConditionContext {
	var p = new(LookupConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_lookupCondition

	return p
}

func (s *LookupConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *LookupConditionContext) JoinCondition() IJoinConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinConditionContext)
}

func (s *LookupConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LookupConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LookupConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterLookupCondition(s)
	}
}

func (s *LookupConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitLookupCondition(s)
	}
}

func (s *LookupConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitLookupCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) LookupCondition() (localctx ILookupConditionContext) {
	localctx = NewLookupConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, KQLParserRULE_lookupCondition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(931)
		p.JoinCondition()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParseOperatorContext is an interface to support dynamic dispatch.
type IParseOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARSE() antlr.TerminalNode
	Expression() IExpressionContext
	ParsePattern() IParsePatternContext
	ParseKind() IParseKindContext
	WITH() antlr.TerminalNode
	PARSE_WHERE() antlr.TerminalNode

	// IsParseOperatorContext differentiates from other interfaces.
	IsParseOperatorContext()
}

type ParseOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParseOperatorContext() *ParseOperatorContext {
	var p = new(ParseOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_parseOperator
	return p
}

func InitEmptyParseOperatorContext(p *ParseOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_parseOperator
}

func (*ParseOperatorContext) IsParseOperatorContext() {}

func NewParseOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParseOperatorContext {
	var p = new(ParseOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_parseOperator

	return p
}

func (s *ParseOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ParseOperatorContext) PARSE() antlr.TerminalNode {
	return s.GetToken(KQLParserPARSE, 0)
}

func (s *ParseOperatorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParseOperatorContext) ParsePattern() IParsePatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParsePatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParsePatternContext)
}

func (s *ParseOperatorContext) ParseKind() IParseKindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParseKindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParseKindContext)
}

func (s *ParseOperatorContext) WITH() antlr.TerminalNode {
	return s.GetToken(KQLParserWITH, 0)
}

func (s *ParseOperatorContext) PARSE_WHERE() antlr.TerminalNode {
	return s.GetToken(KQLParserPARSE_WHERE, 0)
}

func (s *ParseOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParseOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParseOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterParseOperator(s)
	}
}

func (s *ParseOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitParseOperator(s)
	}
}

func (s *ParseOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitParseOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ParseOperator() (localctx IParseOperatorContext) {
	localctx = NewParseOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, KQLParserRULE_parseOperator)
	p.SetState(953)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KQLParserPARSE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(933)
			p.Match(KQLParserPARSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(935)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(934)
				p.ParseKind()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(937)
			p.Expression()
		}
		p.SetState(939)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(938)
				p.Match(KQLParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(941)
			p.ParsePattern()
		}

	case KQLParserPARSE_WHERE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(943)
			p.Match(KQLParserPARSE_WHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(945)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(944)
				p.ParseKind()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(947)
			p.Expression()
		}
		p.SetState(949)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(948)
				p.Match(KQLParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(951)
			p.ParsePattern()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParseKindContext is an interface to support dynamic dispatch.
type IParseKindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KIND() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsParseKindContext differentiates from other interfaces.
	IsParseKindContext()
}

type ParseKindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParseKindContext() *ParseKindContext {
	var p = new(ParseKindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_parseKind
	return p
}

func InitEmptyParseKindContext(p *ParseKindContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_parseKind
}

func (*ParseKindContext) IsParseKindContext() {}

func NewParseKindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParseKindContext {
	var p = new(ParseKindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_parseKind

	return p
}

func (s *ParseKindContext) GetParser() antlr.Parser { return s.parser }

func (s *ParseKindContext) KIND() antlr.TerminalNode {
	return s.GetToken(KQLParserKIND, 0)
}

func (s *ParseKindContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *ParseKindContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ParseKindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParseKindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParseKindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterParseKind(s)
	}
}

func (s *ParseKindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitParseKind(s)
	}
}

func (s *ParseKindContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitParseKind(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ParseKind() (localctx IParseKindContext) {
	localctx = NewParseKindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, KQLParserRULE_parseKind)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(955)
		p.Match(KQLParserKIND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(956)
		p.Match(KQLParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(957)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParsePatternContext is an interface to support dynamic dispatch.
type IParsePatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParsePatternItem() []IParsePatternItemContext
	ParsePatternItem(i int) IParsePatternItemContext

	// IsParsePatternContext differentiates from other interfaces.
	IsParsePatternContext()
}

type ParsePatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParsePatternContext() *ParsePatternContext {
	var p = new(ParsePatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_parsePattern
	return p
}

func InitEmptyParsePatternContext(p *ParsePatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_parsePattern
}

func (*ParsePatternContext) IsParsePatternContext() {}

func NewParsePatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParsePatternContext {
	var p = new(ParsePatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_parsePattern

	return p
}

func (s *ParsePatternContext) GetParser() antlr.Parser { return s.parser }

func (s *ParsePatternContext) AllParsePatternItem() []IParsePatternItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParsePatternItemContext); ok {
			len++
		}
	}

	tst := make([]IParsePatternItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParsePatternItemContext); ok {
			tst[i] = t.(IParsePatternItemContext)
			i++
		}
	}

	return tst
}

func (s *ParsePatternContext) ParsePatternItem(i int) IParsePatternItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParsePatternItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParsePatternItemContext)
}

func (s *ParsePatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParsePatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParsePatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterParsePattern(s)
	}
}

func (s *ParsePatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitParsePattern(s)
	}
}

func (s *ParsePatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitParsePattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ParsePattern() (localctx IParsePatternContext) {
	localctx = NewParsePatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, KQLParserRULE_parsePattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(960)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1722596028691838186) != 0) || _la == KQLParserRIGHT || _la == KQLParserSTAR || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&-9079274234806525981) != 0) {
		{
			p.SetState(959)
			p.ParsePatternItem()
		}

		p.SetState(962)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParsePatternItemContext is an interface to support dynamic dispatch.
type IParsePatternItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode
	VERBATIM_STRING() antlr.TerminalNode
	STAR() antlr.TerminalNode
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	TypeSpecifier() ITypeSpecifierContext

	// IsParsePatternItemContext differentiates from other interfaces.
	IsParsePatternItemContext()
}

type ParsePatternItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParsePatternItemContext() *ParsePatternItemContext {
	var p = new(ParsePatternItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_parsePatternItem
	return p
}

func InitEmptyParsePatternItemContext(p *ParsePatternItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_parsePatternItem
}

func (*ParsePatternItemContext) IsParsePatternItemContext() {}

func NewParsePatternItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParsePatternItemContext {
	var p = new(ParsePatternItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_parsePatternItem

	return p
}

func (s *ParsePatternItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ParsePatternItemContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(KQLParserSTRING_LITERAL, 0)
}

func (s *ParsePatternItemContext) VERBATIM_STRING() antlr.TerminalNode {
	return s.GetToken(KQLParserVERBATIM_STRING, 0)
}

func (s *ParsePatternItemContext) STAR() antlr.TerminalNode {
	return s.GetToken(KQLParserSTAR, 0)
}

func (s *ParsePatternItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ParsePatternItemContext) COLON() antlr.TerminalNode {
	return s.GetToken(KQLParserCOLON, 0)
}

func (s *ParsePatternItemContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *ParsePatternItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParsePatternItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParsePatternItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterParsePatternItem(s)
	}
}

func (s *ParsePatternItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitParsePatternItem(s)
	}
}

func (s *ParsePatternItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitParsePatternItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ParsePatternItem() (localctx IParsePatternItemContext) {
	localctx = NewParsePatternItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, KQLParserRULE_parsePatternItem)
	p.SetState(972)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KQLParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(964)
			p.Match(KQLParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserVERBATIM_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(965)
			p.Match(KQLParserVERBATIM_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserSTAR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(966)
			p.Match(KQLParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserWHERE, KQLParserSEARCH, KQLParserTAKE, KQLParserDISTINCT, KQLParserCOUNT, KQLParserPROJECT, KQLParserEXTEND, KQLParserPARSE, KQLParserSORT, KQLParserTOP, KQLParserSUMMARIZE, KQLParserJOIN, KQLParserLOOKUP, KQLParserUNION, KQLParserAS, KQLParserEVALUATE, KQLParserRANGE, KQLParserPRINT, KQLParserRENDER, KQLParserLET, KQLParserSET, KQLParserKIND, KQLParserINNER, KQLParserOUTER, KQLParserLEFT, KQLParserRIGHT, KQLParserASC, KQLParserDESC, KQLParserBY, KQLParserON, KQLParserWITH, KQLParserOF, KQLParserTO, KQLParserFROM, KQLParserSTEP, KQLParserDEFAULT, KQLParserTRUE, KQLParserFALSE, KQLParserTYPE_BOOL, KQLParserTYPE_DATETIME, KQLParserTYPE_DECIMAL, KQLParserTYPE_DOUBLE, KQLParserTYPE_DYNAMIC, KQLParserTYPE_GUID, KQLParserTYPE_INT, KQLParserTYPE_LONG, KQLParserTYPE_REAL, KQLParserTYPE_STRING, KQLParserTYPE_TIMESPAN, KQLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(967)
			p.Identifier()
		}
		{
			p.SetState(968)
			p.Match(KQLParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(970)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(969)
				p.TypeSpecifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParseKvOperatorContext is an interface to support dynamic dispatch.
type IParseKvOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARSE_KV() antlr.TerminalNode
	Expression() IExpressionContext
	AS() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	KvPairList() IKvPairListContext
	RPAREN() antlr.TerminalNode
	ParseKvParameters() IParseKvParametersContext

	// IsParseKvOperatorContext differentiates from other interfaces.
	IsParseKvOperatorContext()
}

type ParseKvOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParseKvOperatorContext() *ParseKvOperatorContext {
	var p = new(ParseKvOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_parseKvOperator
	return p
}

func InitEmptyParseKvOperatorContext(p *ParseKvOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_parseKvOperator
}

func (*ParseKvOperatorContext) IsParseKvOperatorContext() {}

func NewParseKvOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParseKvOperatorContext {
	var p = new(ParseKvOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_parseKvOperator

	return p
}

func (s *ParseKvOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ParseKvOperatorContext) PARSE_KV() antlr.TerminalNode {
	return s.GetToken(KQLParserPARSE_KV, 0)
}

func (s *ParseKvOperatorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParseKvOperatorContext) AS() antlr.TerminalNode {
	return s.GetToken(KQLParserAS, 0)
}

func (s *ParseKvOperatorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *ParseKvOperatorContext) KvPairList() IKvPairListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKvPairListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKvPairListContext)
}

func (s *ParseKvOperatorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *ParseKvOperatorContext) ParseKvParameters() IParseKvParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParseKvParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParseKvParametersContext)
}

func (s *ParseKvOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParseKvOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParseKvOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterParseKvOperator(s)
	}
}

func (s *ParseKvOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitParseKvOperator(s)
	}
}

func (s *ParseKvOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitParseKvOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ParseKvOperator() (localctx IParseKvOperatorContext) {
	localctx = NewParseKvOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, KQLParserRULE_parseKvOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(974)
		p.Match(KQLParserPARSE_KV)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(975)
		p.Expression()
	}
	{
		p.SetState(976)
		p.Match(KQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(977)
		p.Match(KQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(978)
		p.KvPairList()
	}
	{
		p.SetState(979)
		p.Match(KQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(981)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserWITH {
		{
			p.SetState(980)
			p.ParseKvParameters()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKvPairListContext is an interface to support dynamic dispatch.
type IKvPairListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllKvPair() []IKvPairContext
	KvPair(i int) IKvPairContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsKvPairListContext differentiates from other interfaces.
	IsKvPairListContext()
}

type KvPairListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKvPairListContext() *KvPairListContext {
	var p = new(KvPairListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_kvPairList
	return p
}

func InitEmptyKvPairListContext(p *KvPairListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_kvPairList
}

func (*KvPairListContext) IsKvPairListContext() {}

func NewKvPairListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KvPairListContext {
	var p = new(KvPairListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_kvPairList

	return p
}

func (s *KvPairListContext) GetParser() antlr.Parser { return s.parser }

func (s *KvPairListContext) AllKvPair() []IKvPairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKvPairContext); ok {
			len++
		}
	}

	tst := make([]IKvPairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKvPairContext); ok {
			tst[i] = t.(IKvPairContext)
			i++
		}
	}

	return tst
}

func (s *KvPairListContext) KvPair(i int) IKvPairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKvPairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKvPairContext)
}

func (s *KvPairListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *KvPairListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *KvPairListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KvPairListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KvPairListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterKvPairList(s)
	}
}

func (s *KvPairListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitKvPairList(s)
	}
}

func (s *KvPairListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitKvPairList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) KvPairList() (localctx IKvPairListContext) {
	localctx = NewKvPairListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, KQLParserRULE_kvPairList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(983)
		p.KvPair()
	}
	p.SetState(988)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(984)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(985)
			p.KvPair()
		}

		p.SetState(990)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKvPairContext is an interface to support dynamic dispatch.
type IKvPairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	TypeSpecifier() ITypeSpecifierContext

	// IsKvPairContext differentiates from other interfaces.
	IsKvPairContext()
}

type KvPairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKvPairContext() *KvPairContext {
	var p = new(KvPairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_kvPair
	return p
}

func InitEmptyKvPairContext(p *KvPairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_kvPair
}

func (*KvPairContext) IsKvPairContext() {}

func NewKvPairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KvPairContext {
	var p = new(KvPairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_kvPair

	return p
}

func (s *KvPairContext) GetParser() antlr.Parser { return s.parser }

func (s *KvPairContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *KvPairContext) COLON() antlr.TerminalNode {
	return s.GetToken(KQLParserCOLON, 0)
}

func (s *KvPairContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *KvPairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KvPairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KvPairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterKvPair(s)
	}
}

func (s *KvPairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitKvPair(s)
	}
}

func (s *KvPairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitKvPair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) KvPair() (localctx IKvPairContext) {
	localctx = NewKvPairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, KQLParserRULE_kvPair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(991)
		p.Identifier()
	}
	{
		p.SetState(992)
		p.Match(KQLParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(993)
		p.TypeSpecifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParseKvParametersContext is an interface to support dynamic dispatch.
type IParseKvParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllParseKvParam() []IParseKvParamContext
	ParseKvParam(i int) IParseKvParamContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsParseKvParametersContext differentiates from other interfaces.
	IsParseKvParametersContext()
}

type ParseKvParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParseKvParametersContext() *ParseKvParametersContext {
	var p = new(ParseKvParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_parseKvParameters
	return p
}

func InitEmptyParseKvParametersContext(p *ParseKvParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_parseKvParameters
}

func (*ParseKvParametersContext) IsParseKvParametersContext() {}

func NewParseKvParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParseKvParametersContext {
	var p = new(ParseKvParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_parseKvParameters

	return p
}

func (s *ParseKvParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParseKvParametersContext) WITH() antlr.TerminalNode {
	return s.GetToken(KQLParserWITH, 0)
}

func (s *ParseKvParametersContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *ParseKvParametersContext) AllParseKvParam() []IParseKvParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParseKvParamContext); ok {
			len++
		}
	}

	tst := make([]IParseKvParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParseKvParamContext); ok {
			tst[i] = t.(IParseKvParamContext)
			i++
		}
	}

	return tst
}

func (s *ParseKvParametersContext) ParseKvParam(i int) IParseKvParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParseKvParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParseKvParamContext)
}

func (s *ParseKvParametersContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *ParseKvParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *ParseKvParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *ParseKvParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParseKvParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParseKvParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterParseKvParameters(s)
	}
}

func (s *ParseKvParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitParseKvParameters(s)
	}
}

func (s *ParseKvParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitParseKvParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ParseKvParameters() (localctx IParseKvParametersContext) {
	localctx = NewParseKvParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, KQLParserRULE_parseKvParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(995)
		p.Match(KQLParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(996)
		p.Match(KQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(997)
		p.ParseKvParam()
	}
	p.SetState(1002)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(998)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(999)
			p.ParseKvParam()
		}

		p.SetState(1004)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1005)
		p.Match(KQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParseKvParamContext is an interface to support dynamic dispatch.
type IParseKvParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsParseKvParamContext differentiates from other interfaces.
	IsParseKvParamContext()
}

type ParseKvParamContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParseKvParamContext() *ParseKvParamContext {
	var p = new(ParseKvParamContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_parseKvParam
	return p
}

func InitEmptyParseKvParamContext(p *ParseKvParamContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_parseKvParam
}

func (*ParseKvParamContext) IsParseKvParamContext() {}

func NewParseKvParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParseKvParamContext {
	var p = new(ParseKvParamContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_parseKvParam

	return p
}

func (s *ParseKvParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParseKvParamContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ParseKvParamContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *ParseKvParamContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParseKvParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParseKvParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParseKvParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterParseKvParam(s)
	}
}

func (s *ParseKvParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitParseKvParam(s)
	}
}

func (s *ParseKvParamContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitParseKvParam(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ParseKvParam() (localctx IParseKvParamContext) {
	localctx = NewParseKvParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, KQLParserRULE_parseKvParam)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1007)
		p.Identifier()
	}
	{
		p.SetState(1008)
		p.Match(KQLParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1009)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvExpandOperatorContext is an interface to support dynamic dispatch.
type IMvExpandOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MV_EXPAND() antlr.TerminalNode
	MvExpandItemList() IMvExpandItemListContext
	MvExpandKind() IMvExpandKindContext
	MvExpandParams() IMvExpandParamsContext
	LimitClause() ILimitClauseContext

	// IsMvExpandOperatorContext differentiates from other interfaces.
	IsMvExpandOperatorContext()
}

type MvExpandOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMvExpandOperatorContext() *MvExpandOperatorContext {
	var p = new(MvExpandOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_mvExpandOperator
	return p
}

func InitEmptyMvExpandOperatorContext(p *MvExpandOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_mvExpandOperator
}

func (*MvExpandOperatorContext) IsMvExpandOperatorContext() {}

func NewMvExpandOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvExpandOperatorContext {
	var p = new(MvExpandOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_mvExpandOperator

	return p
}

func (s *MvExpandOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MvExpandOperatorContext) MV_EXPAND() antlr.TerminalNode {
	return s.GetToken(KQLParserMV_EXPAND, 0)
}

func (s *MvExpandOperatorContext) MvExpandItemList() IMvExpandItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvExpandItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvExpandItemListContext)
}

func (s *MvExpandOperatorContext) MvExpandKind() IMvExpandKindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvExpandKindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvExpandKindContext)
}

func (s *MvExpandOperatorContext) MvExpandParams() IMvExpandParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvExpandParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvExpandParamsContext)
}

func (s *MvExpandOperatorContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *MvExpandOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvExpandOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvExpandOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterMvExpandOperator(s)
	}
}

func (s *MvExpandOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitMvExpandOperator(s)
	}
}

func (s *MvExpandOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitMvExpandOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) MvExpandOperator() (localctx IMvExpandOperatorContext) {
	localctx = NewMvExpandOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, KQLParserRULE_mvExpandOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1011)
		p.Match(KQLParserMV_EXPAND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1013)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1012)
			p.MvExpandKind()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1016)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserBAG_EXPANSION || _la == KQLParserWITH_ITEMINDEX {
		{
			p.SetState(1015)
			p.MvExpandParams()
		}

	}
	{
		p.SetState(1018)
		p.MvExpandItemList()
	}
	p.SetState(1020)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserLIMIT {
		{
			p.SetState(1019)
			p.LimitClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvExpandKindContext is an interface to support dynamic dispatch.
type IMvExpandKindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KIND() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsMvExpandKindContext differentiates from other interfaces.
	IsMvExpandKindContext()
}

type MvExpandKindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMvExpandKindContext() *MvExpandKindContext {
	var p = new(MvExpandKindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_mvExpandKind
	return p
}

func InitEmptyMvExpandKindContext(p *MvExpandKindContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_mvExpandKind
}

func (*MvExpandKindContext) IsMvExpandKindContext() {}

func NewMvExpandKindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvExpandKindContext {
	var p = new(MvExpandKindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_mvExpandKind

	return p
}

func (s *MvExpandKindContext) GetParser() antlr.Parser { return s.parser }

func (s *MvExpandKindContext) KIND() antlr.TerminalNode {
	return s.GetToken(KQLParserKIND, 0)
}

func (s *MvExpandKindContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *MvExpandKindContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MvExpandKindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvExpandKindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvExpandKindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterMvExpandKind(s)
	}
}

func (s *MvExpandKindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitMvExpandKind(s)
	}
}

func (s *MvExpandKindContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitMvExpandKind(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) MvExpandKind() (localctx IMvExpandKindContext) {
	localctx = NewMvExpandKindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, KQLParserRULE_mvExpandKind)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1022)
		p.Match(KQLParserKIND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1023)
		p.Match(KQLParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1024)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvExpandParamsContext is an interface to support dynamic dispatch.
type IMvExpandParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BAG_EXPANSION() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	Identifier() IIdentifierContext
	WITH_ITEMINDEX() antlr.TerminalNode

	// IsMvExpandParamsContext differentiates from other interfaces.
	IsMvExpandParamsContext()
}

type MvExpandParamsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMvExpandParamsContext() *MvExpandParamsContext {
	var p = new(MvExpandParamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_mvExpandParams
	return p
}

func InitEmptyMvExpandParamsContext(p *MvExpandParamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_mvExpandParams
}

func (*MvExpandParamsContext) IsMvExpandParamsContext() {}

func NewMvExpandParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvExpandParamsContext {
	var p = new(MvExpandParamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_mvExpandParams

	return p
}

func (s *MvExpandParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *MvExpandParamsContext) BAG_EXPANSION() antlr.TerminalNode {
	return s.GetToken(KQLParserBAG_EXPANSION, 0)
}

func (s *MvExpandParamsContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *MvExpandParamsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MvExpandParamsContext) WITH_ITEMINDEX() antlr.TerminalNode {
	return s.GetToken(KQLParserWITH_ITEMINDEX, 0)
}

func (s *MvExpandParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvExpandParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvExpandParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterMvExpandParams(s)
	}
}

func (s *MvExpandParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitMvExpandParams(s)
	}
}

func (s *MvExpandParamsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitMvExpandParams(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) MvExpandParams() (localctx IMvExpandParamsContext) {
	localctx = NewMvExpandParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, KQLParserRULE_mvExpandParams)
	p.SetState(1032)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KQLParserBAG_EXPANSION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1026)
			p.Match(KQLParserBAG_EXPANSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1027)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1028)
			p.Identifier()
		}

	case KQLParserWITH_ITEMINDEX:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1029)
			p.Match(KQLParserWITH_ITEMINDEX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1030)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1031)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvExpandItemListContext is an interface to support dynamic dispatch.
type IMvExpandItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMvExpandItem() []IMvExpandItemContext
	MvExpandItem(i int) IMvExpandItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMvExpandItemListContext differentiates from other interfaces.
	IsMvExpandItemListContext()
}

type MvExpandItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMvExpandItemListContext() *MvExpandItemListContext {
	var p = new(MvExpandItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_mvExpandItemList
	return p
}

func InitEmptyMvExpandItemListContext(p *MvExpandItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_mvExpandItemList
}

func (*MvExpandItemListContext) IsMvExpandItemListContext() {}

func NewMvExpandItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvExpandItemListContext {
	var p = new(MvExpandItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_mvExpandItemList

	return p
}

func (s *MvExpandItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *MvExpandItemListContext) AllMvExpandItem() []IMvExpandItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMvExpandItemContext); ok {
			len++
		}
	}

	tst := make([]IMvExpandItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMvExpandItemContext); ok {
			tst[i] = t.(IMvExpandItemContext)
			i++
		}
	}

	return tst
}

func (s *MvExpandItemListContext) MvExpandItem(i int) IMvExpandItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvExpandItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvExpandItemContext)
}

func (s *MvExpandItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *MvExpandItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *MvExpandItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvExpandItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvExpandItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterMvExpandItemList(s)
	}
}

func (s *MvExpandItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitMvExpandItemList(s)
	}
}

func (s *MvExpandItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitMvExpandItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) MvExpandItemList() (localctx IMvExpandItemListContext) {
	localctx = NewMvExpandItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, KQLParserRULE_mvExpandItemList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1034)
		p.MvExpandItem()
	}
	p.SetState(1039)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(1035)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1036)
			p.MvExpandItem()
		}

		p.SetState(1041)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvExpandItemContext is an interface to support dynamic dispatch.
type IMvExpandItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	TO() antlr.TerminalNode
	TYPEOF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	TypeSpecifier() ITypeSpecifierContext
	RPAREN() antlr.TerminalNode
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode

	// IsMvExpandItemContext differentiates from other interfaces.
	IsMvExpandItemContext()
}

type MvExpandItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMvExpandItemContext() *MvExpandItemContext {
	var p = new(MvExpandItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_mvExpandItem
	return p
}

func InitEmptyMvExpandItemContext(p *MvExpandItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_mvExpandItem
}

func (*MvExpandItemContext) IsMvExpandItemContext() {}

func NewMvExpandItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvExpandItemContext {
	var p = new(MvExpandItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_mvExpandItem

	return p
}

func (s *MvExpandItemContext) GetParser() antlr.Parser { return s.parser }

func (s *MvExpandItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MvExpandItemContext) TO() antlr.TerminalNode {
	return s.GetToken(KQLParserTO, 0)
}

func (s *MvExpandItemContext) TYPEOF() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPEOF, 0)
}

func (s *MvExpandItemContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *MvExpandItemContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *MvExpandItemContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *MvExpandItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MvExpandItemContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *MvExpandItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvExpandItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvExpandItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterMvExpandItem(s)
	}
}

func (s *MvExpandItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitMvExpandItem(s)
	}
}

func (s *MvExpandItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitMvExpandItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) MvExpandItem() (localctx IMvExpandItemContext) {
	localctx = NewMvExpandItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, KQLParserRULE_mvExpandItem)
	var _la int

	p.SetState(1062)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1042)
			p.Expression()
		}
		p.SetState(1049)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserTO {
			{
				p.SetState(1043)
				p.Match(KQLParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1044)
				p.Match(KQLParserTYPEOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1045)
				p.Match(KQLParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1046)
				p.TypeSpecifier()
			}
			{
				p.SetState(1047)
				p.Match(KQLParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1051)
			p.Identifier()
		}
		{
			p.SetState(1052)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1053)
			p.Expression()
		}
		p.SetState(1060)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserTO {
			{
				p.SetState(1054)
				p.Match(KQLParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1055)
				p.Match(KQLParserTYPEOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1056)
				p.Match(KQLParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1057)
				p.TypeSpecifier()
			}
			{
				p.SetState(1058)
				p.Match(KQLParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(KQLParserLIMIT, 0)
}

func (s *LimitClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (s *LimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, KQLParserRULE_limitClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1064)
		p.Match(KQLParserLIMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1065)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvApplyOperatorContext is an interface to support dynamic dispatch.
type IMvApplyOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MV_APPLY() antlr.TerminalNode
	MvApplyItemList() IMvApplyItemListContext
	LPAREN() antlr.TerminalNode
	TabularExpression() ITabularExpressionContext
	RPAREN() antlr.TerminalNode
	MvApplyOnClause() IMvApplyOnClauseContext

	// IsMvApplyOperatorContext differentiates from other interfaces.
	IsMvApplyOperatorContext()
}

type MvApplyOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMvApplyOperatorContext() *MvApplyOperatorContext {
	var p = new(MvApplyOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_mvApplyOperator
	return p
}

func InitEmptyMvApplyOperatorContext(p *MvApplyOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_mvApplyOperator
}

func (*MvApplyOperatorContext) IsMvApplyOperatorContext() {}

func NewMvApplyOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvApplyOperatorContext {
	var p = new(MvApplyOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_mvApplyOperator

	return p
}

func (s *MvApplyOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MvApplyOperatorContext) MV_APPLY() antlr.TerminalNode {
	return s.GetToken(KQLParserMV_APPLY, 0)
}

func (s *MvApplyOperatorContext) MvApplyItemList() IMvApplyItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvApplyItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvApplyItemListContext)
}

func (s *MvApplyOperatorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *MvApplyOperatorContext) TabularExpression() ITabularExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabularExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabularExpressionContext)
}

func (s *MvApplyOperatorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *MvApplyOperatorContext) MvApplyOnClause() IMvApplyOnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvApplyOnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvApplyOnClauseContext)
}

func (s *MvApplyOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvApplyOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvApplyOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterMvApplyOperator(s)
	}
}

func (s *MvApplyOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitMvApplyOperator(s)
	}
}

func (s *MvApplyOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitMvApplyOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) MvApplyOperator() (localctx IMvApplyOperatorContext) {
	localctx = NewMvApplyOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, KQLParserRULE_mvApplyOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1067)
		p.Match(KQLParserMV_APPLY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1068)
		p.MvApplyItemList()
	}
	p.SetState(1070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserON {
		{
			p.SetState(1069)
			p.MvApplyOnClause()
		}

	}
	{
		p.SetState(1072)
		p.Match(KQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1073)
		p.TabularExpression()
	}
	{
		p.SetState(1074)
		p.Match(KQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvApplyItemListContext is an interface to support dynamic dispatch.
type IMvApplyItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMvApplyItem() []IMvApplyItemContext
	MvApplyItem(i int) IMvApplyItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMvApplyItemListContext differentiates from other interfaces.
	IsMvApplyItemListContext()
}

type MvApplyItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMvApplyItemListContext() *MvApplyItemListContext {
	var p = new(MvApplyItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_mvApplyItemList
	return p
}

func InitEmptyMvApplyItemListContext(p *MvApplyItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_mvApplyItemList
}

func (*MvApplyItemListContext) IsMvApplyItemListContext() {}

func NewMvApplyItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvApplyItemListContext {
	var p = new(MvApplyItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_mvApplyItemList

	return p
}

func (s *MvApplyItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *MvApplyItemListContext) AllMvApplyItem() []IMvApplyItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMvApplyItemContext); ok {
			len++
		}
	}

	tst := make([]IMvApplyItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMvApplyItemContext); ok {
			tst[i] = t.(IMvApplyItemContext)
			i++
		}
	}

	return tst
}

func (s *MvApplyItemListContext) MvApplyItem(i int) IMvApplyItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvApplyItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvApplyItemContext)
}

func (s *MvApplyItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *MvApplyItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *MvApplyItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvApplyItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvApplyItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterMvApplyItemList(s)
	}
}

func (s *MvApplyItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitMvApplyItemList(s)
	}
}

func (s *MvApplyItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitMvApplyItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) MvApplyItemList() (localctx IMvApplyItemListContext) {
	localctx = NewMvApplyItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, KQLParserRULE_mvApplyItemList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1076)
		p.MvApplyItem()
	}
	p.SetState(1081)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(1077)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1078)
			p.MvApplyItem()
		}

		p.SetState(1083)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvApplyItemContext is an interface to support dynamic dispatch.
type IMvApplyItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	TO() antlr.TerminalNode
	TYPEOF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	TypeSpecifier() ITypeSpecifierContext
	RPAREN() antlr.TerminalNode
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode

	// IsMvApplyItemContext differentiates from other interfaces.
	IsMvApplyItemContext()
}

type MvApplyItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMvApplyItemContext() *MvApplyItemContext {
	var p = new(MvApplyItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_mvApplyItem
	return p
}

func InitEmptyMvApplyItemContext(p *MvApplyItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_mvApplyItem
}

func (*MvApplyItemContext) IsMvApplyItemContext() {}

func NewMvApplyItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvApplyItemContext {
	var p = new(MvApplyItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_mvApplyItem

	return p
}

func (s *MvApplyItemContext) GetParser() antlr.Parser { return s.parser }

func (s *MvApplyItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MvApplyItemContext) TO() antlr.TerminalNode {
	return s.GetToken(KQLParserTO, 0)
}

func (s *MvApplyItemContext) TYPEOF() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPEOF, 0)
}

func (s *MvApplyItemContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *MvApplyItemContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *MvApplyItemContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *MvApplyItemContext) AS() antlr.TerminalNode {
	return s.GetToken(KQLParserAS, 0)
}

func (s *MvApplyItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MvApplyItemContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *MvApplyItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvApplyItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvApplyItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterMvApplyItem(s)
	}
}

func (s *MvApplyItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitMvApplyItem(s)
	}
}

func (s *MvApplyItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitMvApplyItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) MvApplyItem() (localctx IMvApplyItemContext) {
	localctx = NewMvApplyItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, KQLParserRULE_mvApplyItem)
	var _la int

	p.SetState(1108)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1084)
			p.Expression()
		}
		p.SetState(1091)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserTO {
			{
				p.SetState(1085)
				p.Match(KQLParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1086)
				p.Match(KQLParserTYPEOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1087)
				p.Match(KQLParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1088)
				p.TypeSpecifier()
			}
			{
				p.SetState(1089)
				p.Match(KQLParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1095)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserAS {
			{
				p.SetState(1093)
				p.Match(KQLParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1094)
				p.Identifier()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1097)
			p.Identifier()
		}
		{
			p.SetState(1098)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1099)
			p.Expression()
		}
		p.SetState(1106)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserTO {
			{
				p.SetState(1100)
				p.Match(KQLParserTO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1101)
				p.Match(KQLParserTYPEOF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1102)
				p.Match(KQLParserLPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1103)
				p.TypeSpecifier()
			}
			{
				p.SetState(1104)
				p.Match(KQLParserRPAREN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvApplyOnClauseContext is an interface to support dynamic dispatch.
type IMvApplyOnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsMvApplyOnClauseContext differentiates from other interfaces.
	IsMvApplyOnClauseContext()
}

type MvApplyOnClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMvApplyOnClauseContext() *MvApplyOnClauseContext {
	var p = new(MvApplyOnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_mvApplyOnClause
	return p
}

func InitEmptyMvApplyOnClauseContext(p *MvApplyOnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_mvApplyOnClause
}

func (*MvApplyOnClauseContext) IsMvApplyOnClauseContext() {}

func NewMvApplyOnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvApplyOnClauseContext {
	var p = new(MvApplyOnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_mvApplyOnClause

	return p
}

func (s *MvApplyOnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MvApplyOnClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(KQLParserON, 0)
}

func (s *MvApplyOnClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *MvApplyOnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvApplyOnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvApplyOnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterMvApplyOnClause(s)
	}
}

func (s *MvApplyOnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitMvApplyOnClause(s)
	}
}

func (s *MvApplyOnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitMvApplyOnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) MvApplyOnClause() (localctx IMvApplyOnClauseContext) {
	localctx = NewMvApplyOnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, KQLParserRULE_mvApplyOnClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1110)
		p.Match(KQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1111)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEvaluateOperatorContext is an interface to support dynamic dispatch.
type IEvaluateOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EVALUATE() antlr.TerminalNode
	FunctionCall() IFunctionCallContext
	EvaluateHints() IEvaluateHintsContext

	// IsEvaluateOperatorContext differentiates from other interfaces.
	IsEvaluateOperatorContext()
}

type EvaluateOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateOperatorContext() *EvaluateOperatorContext {
	var p = new(EvaluateOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_evaluateOperator
	return p
}

func InitEmptyEvaluateOperatorContext(p *EvaluateOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_evaluateOperator
}

func (*EvaluateOperatorContext) IsEvaluateOperatorContext() {}

func NewEvaluateOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateOperatorContext {
	var p = new(EvaluateOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_evaluateOperator

	return p
}

func (s *EvaluateOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateOperatorContext) EVALUATE() antlr.TerminalNode {
	return s.GetToken(KQLParserEVALUATE, 0)
}

func (s *EvaluateOperatorContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *EvaluateOperatorContext) EvaluateHints() IEvaluateHintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvaluateHintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvaluateHintsContext)
}

func (s *EvaluateOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterEvaluateOperator(s)
	}
}

func (s *EvaluateOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitEvaluateOperator(s)
	}
}

func (s *EvaluateOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitEvaluateOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) EvaluateOperator() (localctx IEvaluateOperatorContext) {
	localctx = NewEvaluateOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, KQLParserRULE_evaluateOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1113)
		p.Match(KQLParserEVALUATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1115)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserHINT_DOT {
		{
			p.SetState(1114)
			p.EvaluateHints()
		}

	}
	{
		p.SetState(1117)
		p.FunctionCall()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEvaluateHintsContext is an interface to support dynamic dispatch.
type IEvaluateHintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HINT_DOT() antlr.TerminalNode
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsEvaluateHintsContext differentiates from other interfaces.
	IsEvaluateHintsContext()
}

type EvaluateHintsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateHintsContext() *EvaluateHintsContext {
	var p = new(EvaluateHintsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_evaluateHints
	return p
}

func InitEmptyEvaluateHintsContext(p *EvaluateHintsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_evaluateHints
}

func (*EvaluateHintsContext) IsEvaluateHintsContext() {}

func NewEvaluateHintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateHintsContext {
	var p = new(EvaluateHintsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_evaluateHints

	return p
}

func (s *EvaluateHintsContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateHintsContext) HINT_DOT() antlr.TerminalNode {
	return s.GetToken(KQLParserHINT_DOT, 0)
}

func (s *EvaluateHintsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EvaluateHintsContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *EvaluateHintsContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EvaluateHintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateHintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateHintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterEvaluateHints(s)
	}
}

func (s *EvaluateHintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitEvaluateHints(s)
	}
}

func (s *EvaluateHintsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitEvaluateHints(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) EvaluateHints() (localctx IEvaluateHintsContext) {
	localctx = NewEvaluateHintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, KQLParserRULE_evaluateHints)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1119)
		p.Match(KQLParserHINT_DOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1120)
		p.Identifier()
	}
	{
		p.SetState(1121)
		p.Match(KQLParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1122)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFacetOperatorContext is an interface to support dynamic dispatch.
type IFacetOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FACET() antlr.TerminalNode
	BY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	TabularExpression() ITabularExpressionContext
	RPAREN() antlr.TerminalNode

	// IsFacetOperatorContext differentiates from other interfaces.
	IsFacetOperatorContext()
}

type FacetOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFacetOperatorContext() *FacetOperatorContext {
	var p = new(FacetOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_facetOperator
	return p
}

func InitEmptyFacetOperatorContext(p *FacetOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_facetOperator
}

func (*FacetOperatorContext) IsFacetOperatorContext() {}

func NewFacetOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FacetOperatorContext {
	var p = new(FacetOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_facetOperator

	return p
}

func (s *FacetOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *FacetOperatorContext) FACET() antlr.TerminalNode {
	return s.GetToken(KQLParserFACET, 0)
}

func (s *FacetOperatorContext) BY() antlr.TerminalNode {
	return s.GetToken(KQLParserBY, 0)
}

func (s *FacetOperatorContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *FacetOperatorContext) WITH() antlr.TerminalNode {
	return s.GetToken(KQLParserWITH, 0)
}

func (s *FacetOperatorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *FacetOperatorContext) TabularExpression() ITabularExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabularExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabularExpressionContext)
}

func (s *FacetOperatorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *FacetOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FacetOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FacetOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterFacetOperator(s)
	}
}

func (s *FacetOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitFacetOperator(s)
	}
}

func (s *FacetOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitFacetOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) FacetOperator() (localctx IFacetOperatorContext) {
	localctx = NewFacetOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, KQLParserRULE_facetOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1124)
		p.Match(KQLParserFACET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1125)
		p.Match(KQLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1126)
		p.IdentifierList()
	}
	p.SetState(1132)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserWITH {
		{
			p.SetState(1127)
			p.Match(KQLParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1128)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1129)
			p.TabularExpression()
		}
		{
			p.SetState(1130)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForkOperatorContext is an interface to support dynamic dispatch.
type IForkOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FORK() antlr.TerminalNode
	AllForkBranch() []IForkBranchContext
	ForkBranch(i int) IForkBranchContext

	// IsForkOperatorContext differentiates from other interfaces.
	IsForkOperatorContext()
}

type ForkOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForkOperatorContext() *ForkOperatorContext {
	var p = new(ForkOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_forkOperator
	return p
}

func InitEmptyForkOperatorContext(p *ForkOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_forkOperator
}

func (*ForkOperatorContext) IsForkOperatorContext() {}

func NewForkOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForkOperatorContext {
	var p = new(ForkOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_forkOperator

	return p
}

func (s *ForkOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ForkOperatorContext) FORK() antlr.TerminalNode {
	return s.GetToken(KQLParserFORK, 0)
}

func (s *ForkOperatorContext) AllForkBranch() []IForkBranchContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IForkBranchContext); ok {
			len++
		}
	}

	tst := make([]IForkBranchContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IForkBranchContext); ok {
			tst[i] = t.(IForkBranchContext)
			i++
		}
	}

	return tst
}

func (s *ForkOperatorContext) ForkBranch(i int) IForkBranchContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForkBranchContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForkBranchContext)
}

func (s *ForkOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForkOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForkOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterForkOperator(s)
	}
}

func (s *ForkOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitForkOperator(s)
	}
}

func (s *ForkOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitForkOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ForkOperator() (localctx IForkOperatorContext) {
	localctx = NewForkOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, KQLParserRULE_forkOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1134)
		p.Match(KQLParserFORK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1136)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == KQLParserLPAREN {
		{
			p.SetState(1135)
			p.ForkBranch()
		}

		p.SetState(1138)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForkBranchContext is an interface to support dynamic dispatch.
type IForkBranchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	TabularExpression() ITabularExpressionContext
	RPAREN() antlr.TerminalNode

	// IsForkBranchContext differentiates from other interfaces.
	IsForkBranchContext()
}

type ForkBranchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForkBranchContext() *ForkBranchContext {
	var p = new(ForkBranchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_forkBranch
	return p
}

func InitEmptyForkBranchContext(p *ForkBranchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_forkBranch
}

func (*ForkBranchContext) IsForkBranchContext() {}

func NewForkBranchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForkBranchContext {
	var p = new(ForkBranchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_forkBranch

	return p
}

func (s *ForkBranchContext) GetParser() antlr.Parser { return s.parser }

func (s *ForkBranchContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *ForkBranchContext) TabularExpression() ITabularExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabularExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabularExpressionContext)
}

func (s *ForkBranchContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *ForkBranchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForkBranchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForkBranchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterForkBranch(s)
	}
}

func (s *ForkBranchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitForkBranch(s)
	}
}

func (s *ForkBranchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitForkBranch(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ForkBranch() (localctx IForkBranchContext) {
	localctx = NewForkBranchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, KQLParserRULE_forkBranch)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1140)
		p.Match(KQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1141)
		p.TabularExpression()
	}
	{
		p.SetState(1142)
		p.Match(KQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionOperatorContext is an interface to support dynamic dispatch.
type IPartitionOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	Expression() IExpressionContext
	LPAREN() antlr.TerminalNode
	TabularExpression() ITabularExpressionContext
	RPAREN() antlr.TerminalNode
	PartitionHints() IPartitionHintsContext

	// IsPartitionOperatorContext differentiates from other interfaces.
	IsPartitionOperatorContext()
}

type PartitionOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionOperatorContext() *PartitionOperatorContext {
	var p = new(PartitionOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_partitionOperator
	return p
}

func InitEmptyPartitionOperatorContext(p *PartitionOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_partitionOperator
}

func (*PartitionOperatorContext) IsPartitionOperatorContext() {}

func NewPartitionOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionOperatorContext {
	var p = new(PartitionOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_partitionOperator

	return p
}

func (s *PartitionOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionOperatorContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(KQLParserPARTITION, 0)
}

func (s *PartitionOperatorContext) BY() antlr.TerminalNode {
	return s.GetToken(KQLParserBY, 0)
}

func (s *PartitionOperatorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionOperatorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *PartitionOperatorContext) TabularExpression() ITabularExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabularExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabularExpressionContext)
}

func (s *PartitionOperatorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *PartitionOperatorContext) PartitionHints() IPartitionHintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionHintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionHintsContext)
}

func (s *PartitionOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterPartitionOperator(s)
	}
}

func (s *PartitionOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitPartitionOperator(s)
	}
}

func (s *PartitionOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitPartitionOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) PartitionOperator() (localctx IPartitionOperatorContext) {
	localctx = NewPartitionOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, KQLParserRULE_partitionOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1144)
		p.Match(KQLParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1146)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserHINT_DOT {
		{
			p.SetState(1145)
			p.PartitionHints()
		}

	}
	{
		p.SetState(1148)
		p.Match(KQLParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1149)
		p.Expression()
	}
	{
		p.SetState(1150)
		p.Match(KQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1151)
		p.TabularExpression()
	}
	{
		p.SetState(1152)
		p.Match(KQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionHintsContext is an interface to support dynamic dispatch.
type IPartitionHintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HINT_DOT() antlr.TerminalNode
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsPartitionHintsContext differentiates from other interfaces.
	IsPartitionHintsContext()
}

type PartitionHintsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionHintsContext() *PartitionHintsContext {
	var p = new(PartitionHintsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_partitionHints
	return p
}

func InitEmptyPartitionHintsContext(p *PartitionHintsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_partitionHints
}

func (*PartitionHintsContext) IsPartitionHintsContext() {}

func NewPartitionHintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionHintsContext {
	var p = new(PartitionHintsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_partitionHints

	return p
}

func (s *PartitionHintsContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionHintsContext) HINT_DOT() antlr.TerminalNode {
	return s.GetToken(KQLParserHINT_DOT, 0)
}

func (s *PartitionHintsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PartitionHintsContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *PartitionHintsContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PartitionHintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionHintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionHintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterPartitionHints(s)
	}
}

func (s *PartitionHintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitPartitionHints(s)
	}
}

func (s *PartitionHintsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitPartitionHints(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) PartitionHints() (localctx IPartitionHintsContext) {
	localctx = NewPartitionHintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, KQLParserRULE_partitionHints)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1154)
		p.Match(KQLParserHINT_DOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1155)
		p.Identifier()
	}
	{
		p.SetState(1156)
		p.Match(KQLParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1157)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScanOperatorContext is an interface to support dynamic dispatch.
type IScanOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SCAN() antlr.TerminalNode
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	ScanStepList() IScanStepListContext
	RPAREN() antlr.TerminalNode
	ScanParams() IScanParamsContext
	ScanDeclare() IScanDeclareContext

	// IsScanOperatorContext differentiates from other interfaces.
	IsScanOperatorContext()
}

type ScanOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScanOperatorContext() *ScanOperatorContext {
	var p = new(ScanOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_scanOperator
	return p
}

func InitEmptyScanOperatorContext(p *ScanOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_scanOperator
}

func (*ScanOperatorContext) IsScanOperatorContext() {}

func NewScanOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScanOperatorContext {
	var p = new(ScanOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_scanOperator

	return p
}

func (s *ScanOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ScanOperatorContext) SCAN() antlr.TerminalNode {
	return s.GetToken(KQLParserSCAN, 0)
}

func (s *ScanOperatorContext) WITH() antlr.TerminalNode {
	return s.GetToken(KQLParserWITH, 0)
}

func (s *ScanOperatorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *ScanOperatorContext) ScanStepList() IScanStepListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScanStepListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScanStepListContext)
}

func (s *ScanOperatorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *ScanOperatorContext) ScanParams() IScanParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScanParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScanParamsContext)
}

func (s *ScanOperatorContext) ScanDeclare() IScanDeclareContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScanDeclareContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScanDeclareContext)
}

func (s *ScanOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScanOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScanOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterScanOperator(s)
	}
}

func (s *ScanOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitScanOperator(s)
	}
}

func (s *ScanOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitScanOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ScanOperator() (localctx IScanOperatorContext) {
	localctx = NewScanOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, KQLParserRULE_scanOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1159)
		p.Match(KQLParserSCAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1161)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserWITH_MATCH_ID {
		{
			p.SetState(1160)
			p.ScanParams()
		}

	}
	p.SetState(1164)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserDECLARE {
		{
			p.SetState(1163)
			p.ScanDeclare()
		}

	}
	{
		p.SetState(1166)
		p.Match(KQLParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1167)
		p.Match(KQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1168)
		p.ScanStepList()
	}
	{
		p.SetState(1169)
		p.Match(KQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScanParamsContext is an interface to support dynamic dispatch.
type IScanParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_MATCH_ID() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsScanParamsContext differentiates from other interfaces.
	IsScanParamsContext()
}

type ScanParamsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScanParamsContext() *ScanParamsContext {
	var p = new(ScanParamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_scanParams
	return p
}

func InitEmptyScanParamsContext(p *ScanParamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_scanParams
}

func (*ScanParamsContext) IsScanParamsContext() {}

func NewScanParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScanParamsContext {
	var p = new(ScanParamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_scanParams

	return p
}

func (s *ScanParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *ScanParamsContext) WITH_MATCH_ID() antlr.TerminalNode {
	return s.GetToken(KQLParserWITH_MATCH_ID, 0)
}

func (s *ScanParamsContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *ScanParamsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScanParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScanParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScanParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterScanParams(s)
	}
}

func (s *ScanParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitScanParams(s)
	}
}

func (s *ScanParamsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitScanParams(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ScanParams() (localctx IScanParamsContext) {
	localctx = NewScanParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, KQLParserRULE_scanParams)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1171)
		p.Match(KQLParserWITH_MATCH_ID)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1172)
		p.Match(KQLParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1173)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScanDeclareContext is an interface to support dynamic dispatch.
type IScanDeclareContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECLARE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllScanDeclareItem() []IScanDeclareItemContext
	ScanDeclareItem(i int) IScanDeclareItemContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsScanDeclareContext differentiates from other interfaces.
	IsScanDeclareContext()
}

type ScanDeclareContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScanDeclareContext() *ScanDeclareContext {
	var p = new(ScanDeclareContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_scanDeclare
	return p
}

func InitEmptyScanDeclareContext(p *ScanDeclareContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_scanDeclare
}

func (*ScanDeclareContext) IsScanDeclareContext() {}

func NewScanDeclareContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScanDeclareContext {
	var p = new(ScanDeclareContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_scanDeclare

	return p
}

func (s *ScanDeclareContext) GetParser() antlr.Parser { return s.parser }

func (s *ScanDeclareContext) DECLARE() antlr.TerminalNode {
	return s.GetToken(KQLParserDECLARE, 0)
}

func (s *ScanDeclareContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *ScanDeclareContext) AllScanDeclareItem() []IScanDeclareItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScanDeclareItemContext); ok {
			len++
		}
	}

	tst := make([]IScanDeclareItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScanDeclareItemContext); ok {
			tst[i] = t.(IScanDeclareItemContext)
			i++
		}
	}

	return tst
}

func (s *ScanDeclareContext) ScanDeclareItem(i int) IScanDeclareItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScanDeclareItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScanDeclareItemContext)
}

func (s *ScanDeclareContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *ScanDeclareContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *ScanDeclareContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *ScanDeclareContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScanDeclareContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScanDeclareContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterScanDeclare(s)
	}
}

func (s *ScanDeclareContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitScanDeclare(s)
	}
}

func (s *ScanDeclareContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitScanDeclare(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ScanDeclare() (localctx IScanDeclareContext) {
	localctx = NewScanDeclareContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, KQLParserRULE_scanDeclare)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1175)
		p.Match(KQLParserDECLARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1176)
		p.Match(KQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1177)
		p.ScanDeclareItem()
	}
	p.SetState(1182)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(1178)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1179)
			p.ScanDeclareItem()
		}

		p.SetState(1184)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1185)
		p.Match(KQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScanDeclareItemContext is an interface to support dynamic dispatch.
type IScanDeclareItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	TypeSpecifier() ITypeSpecifierContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsScanDeclareItemContext differentiates from other interfaces.
	IsScanDeclareItemContext()
}

type ScanDeclareItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScanDeclareItemContext() *ScanDeclareItemContext {
	var p = new(ScanDeclareItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_scanDeclareItem
	return p
}

func InitEmptyScanDeclareItemContext(p *ScanDeclareItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_scanDeclareItem
}

func (*ScanDeclareItemContext) IsScanDeclareItemContext() {}

func NewScanDeclareItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScanDeclareItemContext {
	var p = new(ScanDeclareItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_scanDeclareItem

	return p
}

func (s *ScanDeclareItemContext) GetParser() antlr.Parser { return s.parser }

func (s *ScanDeclareItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScanDeclareItemContext) COLON() antlr.TerminalNode {
	return s.GetToken(KQLParserCOLON, 0)
}

func (s *ScanDeclareItemContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *ScanDeclareItemContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *ScanDeclareItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ScanDeclareItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScanDeclareItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScanDeclareItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterScanDeclareItem(s)
	}
}

func (s *ScanDeclareItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitScanDeclareItem(s)
	}
}

func (s *ScanDeclareItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitScanDeclareItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ScanDeclareItem() (localctx IScanDeclareItemContext) {
	localctx = NewScanDeclareItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, KQLParserRULE_scanDeclareItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1187)
		p.Identifier()
	}
	{
		p.SetState(1188)
		p.Match(KQLParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1189)
		p.TypeSpecifier()
	}
	p.SetState(1192)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserASSIGN {
		{
			p.SetState(1190)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1191)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScanStepListContext is an interface to support dynamic dispatch.
type IScanStepListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllScanStep() []IScanStepContext
	ScanStep(i int) IScanStepContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsScanStepListContext differentiates from other interfaces.
	IsScanStepListContext()
}

type ScanStepListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScanStepListContext() *ScanStepListContext {
	var p = new(ScanStepListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_scanStepList
	return p
}

func InitEmptyScanStepListContext(p *ScanStepListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_scanStepList
}

func (*ScanStepListContext) IsScanStepListContext() {}

func NewScanStepListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScanStepListContext {
	var p = new(ScanStepListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_scanStepList

	return p
}

func (s *ScanStepListContext) GetParser() antlr.Parser { return s.parser }

func (s *ScanStepListContext) AllScanStep() []IScanStepContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScanStepContext); ok {
			len++
		}
	}

	tst := make([]IScanStepContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScanStepContext); ok {
			tst[i] = t.(IScanStepContext)
			i++
		}
	}

	return tst
}

func (s *ScanStepListContext) ScanStep(i int) IScanStepContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScanStepContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScanStepContext)
}

func (s *ScanStepListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *ScanStepListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *ScanStepListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScanStepListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScanStepListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterScanStepList(s)
	}
}

func (s *ScanStepListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitScanStepList(s)
	}
}

func (s *ScanStepListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitScanStepList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ScanStepList() (localctx IScanStepListContext) {
	localctx = NewScanStepListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, KQLParserRULE_scanStepList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1194)
		p.ScanStep()
	}
	p.SetState(1199)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(1195)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1196)
			p.ScanStep()
		}

		p.SetState(1201)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScanStepContext is an interface to support dynamic dispatch.
type IScanStepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STEP() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	COLON() antlr.TerminalNode
	Expression() IExpressionContext
	ARROW() antlr.TerminalNode
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	OUTPUT() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	AllScanAction() []IScanActionContext
	ScanAction(i int) IScanActionContext

	// IsScanStepContext differentiates from other interfaces.
	IsScanStepContext()
}

type ScanStepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScanStepContext() *ScanStepContext {
	var p = new(ScanStepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_scanStep
	return p
}

func InitEmptyScanStepContext(p *ScanStepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_scanStep
}

func (*ScanStepContext) IsScanStepContext() {}

func NewScanStepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScanStepContext {
	var p = new(ScanStepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_scanStep

	return p
}

func (s *ScanStepContext) GetParser() antlr.Parser { return s.parser }

func (s *ScanStepContext) STEP() antlr.TerminalNode {
	return s.GetToken(KQLParserSTEP, 0)
}

func (s *ScanStepContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ScanStepContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScanStepContext) COLON() antlr.TerminalNode {
	return s.GetToken(KQLParserCOLON, 0)
}

func (s *ScanStepContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ScanStepContext) ARROW() antlr.TerminalNode {
	return s.GetToken(KQLParserARROW, 0)
}

func (s *ScanStepContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(KQLParserLBRACE, 0)
}

func (s *ScanStepContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(KQLParserRBRACE, 0)
}

func (s *ScanStepContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(KQLParserOUTPUT, 0)
}

func (s *ScanStepContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *ScanStepContext) AllScanAction() []IScanActionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScanActionContext); ok {
			len++
		}
	}

	tst := make([]IScanActionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScanActionContext); ok {
			tst[i] = t.(IScanActionContext)
			i++
		}
	}

	return tst
}

func (s *ScanStepContext) ScanAction(i int) IScanActionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScanActionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScanActionContext)
}

func (s *ScanStepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScanStepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScanStepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterScanStep(s)
	}
}

func (s *ScanStepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitScanStep(s)
	}
}

func (s *ScanStepContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitScanStep(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ScanStep() (localctx IScanStepContext) {
	localctx = NewScanStepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, KQLParserRULE_scanStep)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1202)
		p.Match(KQLParserSTEP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1203)
		p.Identifier()
	}
	p.SetState(1207)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserOUTPUT {
		{
			p.SetState(1204)
			p.Match(KQLParserOUTPUT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1205)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1206)
			p.Identifier()
		}

	}
	{
		p.SetState(1209)
		p.Match(KQLParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1210)
		p.Expression()
	}
	{
		p.SetState(1211)
		p.Match(KQLParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1212)
		p.Match(KQLParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1214)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-861298014345919093) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&-9187360625863417885) != 0) {
		{
			p.SetState(1213)
			p.ScanAction()
		}

		p.SetState(1216)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1218)
		p.Match(KQLParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IScanActionContext is an interface to support dynamic dispatch.
type IScanActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext
	SEMICOLON() antlr.TerminalNode

	// IsScanActionContext differentiates from other interfaces.
	IsScanActionContext()
}

type ScanActionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScanActionContext() *ScanActionContext {
	var p = new(ScanActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_scanAction
	return p
}

func InitEmptyScanActionContext(p *ScanActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_scanAction
}

func (*ScanActionContext) IsScanActionContext() {}

func NewScanActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScanActionContext {
	var p = new(ScanActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_scanAction

	return p
}

func (s *ScanActionContext) GetParser() antlr.Parser { return s.parser }

func (s *ScanActionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScanActionContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *ScanActionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ScanActionContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(KQLParserSEMICOLON, 0)
}

func (s *ScanActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScanActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScanActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterScanAction(s)
	}
}

func (s *ScanActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitScanAction(s)
	}
}

func (s *ScanActionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitScanAction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ScanAction() (localctx IScanActionContext) {
	localctx = NewScanActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, KQLParserRULE_scanAction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1220)
		p.Identifier()
	}
	{
		p.SetState(1221)
		p.Match(KQLParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1222)
		p.Expression()
	}
	p.SetState(1224)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserSEMICOLON {
		{
			p.SetState(1223)
			p.Match(KQLParserSEMICOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISerializeOperatorContext is an interface to support dynamic dispatch.
type ISerializeOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SERIALIZE() antlr.TerminalNode
	ExtendItemList() IExtendItemListContext

	// IsSerializeOperatorContext differentiates from other interfaces.
	IsSerializeOperatorContext()
}

type SerializeOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySerializeOperatorContext() *SerializeOperatorContext {
	var p = new(SerializeOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_serializeOperator
	return p
}

func InitEmptySerializeOperatorContext(p *SerializeOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_serializeOperator
}

func (*SerializeOperatorContext) IsSerializeOperatorContext() {}

func NewSerializeOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SerializeOperatorContext {
	var p = new(SerializeOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_serializeOperator

	return p
}

func (s *SerializeOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *SerializeOperatorContext) SERIALIZE() antlr.TerminalNode {
	return s.GetToken(KQLParserSERIALIZE, 0)
}

func (s *SerializeOperatorContext) ExtendItemList() IExtendItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtendItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtendItemListContext)
}

func (s *SerializeOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SerializeOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SerializeOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterSerializeOperator(s)
	}
}

func (s *SerializeOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitSerializeOperator(s)
	}
}

func (s *SerializeOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitSerializeOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) SerializeOperator() (localctx ISerializeOperatorContext) {
	localctx = NewSerializeOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, KQLParserRULE_serializeOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1226)
		p.Match(KQLParserSERIALIZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1228)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1722596028691838186) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2017612633061998593) != 0) || ((int64((_la-136)) & ^0x3f) == 0 && ((int64(1)<<(_la-136))&-137430566699) != 0) || ((int64((_la-200)) & ^0x3f) == 0 && ((int64(1)<<(_la-200))&255) != 0) {
		{
			p.SetState(1227)
			p.ExtendItemList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleOperatorContext is an interface to support dynamic dispatch.
type ISampleOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAMPLE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsSampleOperatorContext differentiates from other interfaces.
	IsSampleOperatorContext()
}

type SampleOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleOperatorContext() *SampleOperatorContext {
	var p = new(SampleOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_sampleOperator
	return p
}

func InitEmptySampleOperatorContext(p *SampleOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_sampleOperator
}

func (*SampleOperatorContext) IsSampleOperatorContext() {}

func NewSampleOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleOperatorContext {
	var p = new(SampleOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_sampleOperator

	return p
}

func (s *SampleOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleOperatorContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(KQLParserSAMPLE, 0)
}

func (s *SampleOperatorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SampleOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterSampleOperator(s)
	}
}

func (s *SampleOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitSampleOperator(s)
	}
}

func (s *SampleOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitSampleOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) SampleOperator() (localctx ISampleOperatorContext) {
	localctx = NewSampleOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, KQLParserRULE_sampleOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1230)
		p.Match(KQLParserSAMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1231)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleDistinctOperatorContext is an interface to support dynamic dispatch.
type ISampleDistinctOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAMPLE_DISTINCT() antlr.TerminalNode
	Expression() IExpressionContext
	OF() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsSampleDistinctOperatorContext differentiates from other interfaces.
	IsSampleDistinctOperatorContext()
}

type SampleDistinctOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleDistinctOperatorContext() *SampleDistinctOperatorContext {
	var p = new(SampleDistinctOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_sampleDistinctOperator
	return p
}

func InitEmptySampleDistinctOperatorContext(p *SampleDistinctOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_sampleDistinctOperator
}

func (*SampleDistinctOperatorContext) IsSampleDistinctOperatorContext() {}

func NewSampleDistinctOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleDistinctOperatorContext {
	var p = new(SampleDistinctOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_sampleDistinctOperator

	return p
}

func (s *SampleDistinctOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleDistinctOperatorContext) SAMPLE_DISTINCT() antlr.TerminalNode {
	return s.GetToken(KQLParserSAMPLE_DISTINCT, 0)
}

func (s *SampleDistinctOperatorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SampleDistinctOperatorContext) OF() antlr.TerminalNode {
	return s.GetToken(KQLParserOF, 0)
}

func (s *SampleDistinctOperatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SampleDistinctOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleDistinctOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleDistinctOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterSampleDistinctOperator(s)
	}
}

func (s *SampleDistinctOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitSampleDistinctOperator(s)
	}
}

func (s *SampleDistinctOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitSampleDistinctOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) SampleDistinctOperator() (localctx ISampleDistinctOperatorContext) {
	localctx = NewSampleDistinctOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, KQLParserRULE_sampleDistinctOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1233)
		p.Match(KQLParserSAMPLE_DISTINCT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1234)
		p.Expression()
	}
	{
		p.SetState(1235)
		p.Match(KQLParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1236)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMakeSeriesOperatorContext is an interface to support dynamic dispatch.
type IMakeSeriesOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAKE_SERIES() antlr.TerminalNode
	MakeSeriesItemList() IMakeSeriesItemListContext
	MakeSeriesOnClause() IMakeSeriesOnClauseContext
	MakeSeriesParams() IMakeSeriesParamsContext

	// IsMakeSeriesOperatorContext differentiates from other interfaces.
	IsMakeSeriesOperatorContext()
}

type MakeSeriesOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMakeSeriesOperatorContext() *MakeSeriesOperatorContext {
	var p = new(MakeSeriesOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_makeSeriesOperator
	return p
}

func InitEmptyMakeSeriesOperatorContext(p *MakeSeriesOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_makeSeriesOperator
}

func (*MakeSeriesOperatorContext) IsMakeSeriesOperatorContext() {}

func NewMakeSeriesOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MakeSeriesOperatorContext {
	var p = new(MakeSeriesOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_makeSeriesOperator

	return p
}

func (s *MakeSeriesOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MakeSeriesOperatorContext) MAKE_SERIES() antlr.TerminalNode {
	return s.GetToken(KQLParserMAKE_SERIES, 0)
}

func (s *MakeSeriesOperatorContext) MakeSeriesItemList() IMakeSeriesItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMakeSeriesItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMakeSeriesItemListContext)
}

func (s *MakeSeriesOperatorContext) MakeSeriesOnClause() IMakeSeriesOnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMakeSeriesOnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMakeSeriesOnClauseContext)
}

func (s *MakeSeriesOperatorContext) MakeSeriesParams() IMakeSeriesParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMakeSeriesParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMakeSeriesParamsContext)
}

func (s *MakeSeriesOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MakeSeriesOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MakeSeriesOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterMakeSeriesOperator(s)
	}
}

func (s *MakeSeriesOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitMakeSeriesOperator(s)
	}
}

func (s *MakeSeriesOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitMakeSeriesOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) MakeSeriesOperator() (localctx IMakeSeriesOperatorContext) {
	localctx = NewMakeSeriesOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, KQLParserRULE_makeSeriesOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1238)
		p.Match(KQLParserMAKE_SERIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1239)
		p.MakeSeriesItemList()
	}
	{
		p.SetState(1240)
		p.MakeSeriesOnClause()
	}
	p.SetState(1242)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserKIND {
		{
			p.SetState(1241)
			p.MakeSeriesParams()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMakeSeriesItemListContext is an interface to support dynamic dispatch.
type IMakeSeriesItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMakeSeriesItem() []IMakeSeriesItemContext
	MakeSeriesItem(i int) IMakeSeriesItemContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsMakeSeriesItemListContext differentiates from other interfaces.
	IsMakeSeriesItemListContext()
}

type MakeSeriesItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMakeSeriesItemListContext() *MakeSeriesItemListContext {
	var p = new(MakeSeriesItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_makeSeriesItemList
	return p
}

func InitEmptyMakeSeriesItemListContext(p *MakeSeriesItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_makeSeriesItemList
}

func (*MakeSeriesItemListContext) IsMakeSeriesItemListContext() {}

func NewMakeSeriesItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MakeSeriesItemListContext {
	var p = new(MakeSeriesItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_makeSeriesItemList

	return p
}

func (s *MakeSeriesItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *MakeSeriesItemListContext) AllMakeSeriesItem() []IMakeSeriesItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMakeSeriesItemContext); ok {
			len++
		}
	}

	tst := make([]IMakeSeriesItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMakeSeriesItemContext); ok {
			tst[i] = t.(IMakeSeriesItemContext)
			i++
		}
	}

	return tst
}

func (s *MakeSeriesItemListContext) MakeSeriesItem(i int) IMakeSeriesItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMakeSeriesItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMakeSeriesItemContext)
}

func (s *MakeSeriesItemListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *MakeSeriesItemListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *MakeSeriesItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MakeSeriesItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MakeSeriesItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterMakeSeriesItemList(s)
	}
}

func (s *MakeSeriesItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitMakeSeriesItemList(s)
	}
}

func (s *MakeSeriesItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitMakeSeriesItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) MakeSeriesItemList() (localctx IMakeSeriesItemListContext) {
	localctx = NewMakeSeriesItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, KQLParserRULE_makeSeriesItemList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1244)
		p.MakeSeriesItem()
	}
	p.SetState(1249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(1245)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1246)
			p.MakeSeriesItem()
		}

		p.SetState(1251)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMakeSeriesItemContext is an interface to support dynamic dispatch.
type IMakeSeriesItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AggregationFunction() IAggregationFunctionContext
	Identifier() IIdentifierContext
	AllASSIGN() []antlr.TerminalNode
	ASSIGN(i int) antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	Expression() IExpressionContext

	// IsMakeSeriesItemContext differentiates from other interfaces.
	IsMakeSeriesItemContext()
}

type MakeSeriesItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMakeSeriesItemContext() *MakeSeriesItemContext {
	var p = new(MakeSeriesItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_makeSeriesItem
	return p
}

func InitEmptyMakeSeriesItemContext(p *MakeSeriesItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_makeSeriesItem
}

func (*MakeSeriesItemContext) IsMakeSeriesItemContext() {}

func NewMakeSeriesItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MakeSeriesItemContext {
	var p = new(MakeSeriesItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_makeSeriesItem

	return p
}

func (s *MakeSeriesItemContext) GetParser() antlr.Parser { return s.parser }

func (s *MakeSeriesItemContext) AggregationFunction() IAggregationFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregationFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregationFunctionContext)
}

func (s *MakeSeriesItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MakeSeriesItemContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(KQLParserASSIGN)
}

func (s *MakeSeriesItemContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, i)
}

func (s *MakeSeriesItemContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(KQLParserDEFAULT, 0)
}

func (s *MakeSeriesItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MakeSeriesItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MakeSeriesItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MakeSeriesItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterMakeSeriesItem(s)
	}
}

func (s *MakeSeriesItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitMakeSeriesItem(s)
	}
}

func (s *MakeSeriesItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitMakeSeriesItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) MakeSeriesItem() (localctx IMakeSeriesItemContext) {
	localctx = NewMakeSeriesItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, KQLParserRULE_makeSeriesItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1253)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1252)
			p.Identifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1256)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserASSIGN {
		{
			p.SetState(1255)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1258)
		p.AggregationFunction()
	}
	p.SetState(1262)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserDEFAULT {
		{
			p.SetState(1259)
			p.Match(KQLParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1260)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1261)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMakeSeriesOnClauseContext is an interface to support dynamic dispatch.
type IMakeSeriesOnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	STEP() antlr.TerminalNode
	FROM() antlr.TerminalNode
	TO() antlr.TerminalNode
	BY() antlr.TerminalNode
	GroupByList() IGroupByListContext

	// IsMakeSeriesOnClauseContext differentiates from other interfaces.
	IsMakeSeriesOnClauseContext()
}

type MakeSeriesOnClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMakeSeriesOnClauseContext() *MakeSeriesOnClauseContext {
	var p = new(MakeSeriesOnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_makeSeriesOnClause
	return p
}

func InitEmptyMakeSeriesOnClauseContext(p *MakeSeriesOnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_makeSeriesOnClause
}

func (*MakeSeriesOnClauseContext) IsMakeSeriesOnClauseContext() {}

func NewMakeSeriesOnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MakeSeriesOnClauseContext {
	var p = new(MakeSeriesOnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_makeSeriesOnClause

	return p
}

func (s *MakeSeriesOnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MakeSeriesOnClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(KQLParserON, 0)
}

func (s *MakeSeriesOnClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MakeSeriesOnClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MakeSeriesOnClauseContext) STEP() antlr.TerminalNode {
	return s.GetToken(KQLParserSTEP, 0)
}

func (s *MakeSeriesOnClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(KQLParserFROM, 0)
}

func (s *MakeSeriesOnClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(KQLParserTO, 0)
}

func (s *MakeSeriesOnClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(KQLParserBY, 0)
}

func (s *MakeSeriesOnClauseContext) GroupByList() IGroupByListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByListContext)
}

func (s *MakeSeriesOnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MakeSeriesOnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MakeSeriesOnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterMakeSeriesOnClause(s)
	}
}

func (s *MakeSeriesOnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitMakeSeriesOnClause(s)
	}
}

func (s *MakeSeriesOnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitMakeSeriesOnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) MakeSeriesOnClause() (localctx IMakeSeriesOnClauseContext) {
	localctx = NewMakeSeriesOnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, KQLParserRULE_makeSeriesOnClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1264)
		p.Match(KQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1265)
		p.Expression()
	}
	p.SetState(1271)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserFROM {
		{
			p.SetState(1266)
			p.Match(KQLParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1267)
			p.Expression()
		}
		{
			p.SetState(1268)
			p.Match(KQLParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1269)
			p.Expression()
		}

	}
	{
		p.SetState(1273)
		p.Match(KQLParserSTEP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1274)
		p.Expression()
	}
	p.SetState(1277)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserBY {
		{
			p.SetState(1275)
			p.Match(KQLParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1276)
			p.GroupByList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMakeSeriesParamsContext is an interface to support dynamic dispatch.
type IMakeSeriesParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KIND() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsMakeSeriesParamsContext differentiates from other interfaces.
	IsMakeSeriesParamsContext()
}

type MakeSeriesParamsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMakeSeriesParamsContext() *MakeSeriesParamsContext {
	var p = new(MakeSeriesParamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_makeSeriesParams
	return p
}

func InitEmptyMakeSeriesParamsContext(p *MakeSeriesParamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_makeSeriesParams
}

func (*MakeSeriesParamsContext) IsMakeSeriesParamsContext() {}

func NewMakeSeriesParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MakeSeriesParamsContext {
	var p = new(MakeSeriesParamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_makeSeriesParams

	return p
}

func (s *MakeSeriesParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *MakeSeriesParamsContext) KIND() antlr.TerminalNode {
	return s.GetToken(KQLParserKIND, 0)
}

func (s *MakeSeriesParamsContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *MakeSeriesParamsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MakeSeriesParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MakeSeriesParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MakeSeriesParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterMakeSeriesParams(s)
	}
}

func (s *MakeSeriesParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitMakeSeriesParams(s)
	}
}

func (s *MakeSeriesParamsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitMakeSeriesParams(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) MakeSeriesParams() (localctx IMakeSeriesParamsContext) {
	localctx = NewMakeSeriesParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, KQLParserRULE_makeSeriesParams)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1279)
		p.Match(KQLParserKIND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1280)
		p.Match(KQLParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1281)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFindOperatorContext is an interface to support dynamic dispatch.
type IFindOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FIND() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	FindParams() IFindParamsContext
	IN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	TableList() ITableListContext
	RPAREN() antlr.TerminalNode
	PROJECT() antlr.TerminalNode
	ProjectItemList() IProjectItemListContext

	// IsFindOperatorContext differentiates from other interfaces.
	IsFindOperatorContext()
}

type FindOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFindOperatorContext() *FindOperatorContext {
	var p = new(FindOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_findOperator
	return p
}

func InitEmptyFindOperatorContext(p *FindOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_findOperator
}

func (*FindOperatorContext) IsFindOperatorContext() {}

func NewFindOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FindOperatorContext {
	var p = new(FindOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_findOperator

	return p
}

func (s *FindOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *FindOperatorContext) FIND() antlr.TerminalNode {
	return s.GetToken(KQLParserFIND, 0)
}

func (s *FindOperatorContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KQLParserWHERE, 0)
}

func (s *FindOperatorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FindOperatorContext) FindParams() IFindParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFindParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFindParamsContext)
}

func (s *FindOperatorContext) IN() antlr.TerminalNode {
	return s.GetToken(KQLParserIN, 0)
}

func (s *FindOperatorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *FindOperatorContext) TableList() ITableListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableListContext)
}

func (s *FindOperatorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *FindOperatorContext) PROJECT() antlr.TerminalNode {
	return s.GetToken(KQLParserPROJECT, 0)
}

func (s *FindOperatorContext) ProjectItemList() IProjectItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectItemListContext)
}

func (s *FindOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FindOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FindOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterFindOperator(s)
	}
}

func (s *FindOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitFindOperator(s)
	}
}

func (s *FindOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitFindOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) FindOperator() (localctx IFindOperatorContext) {
	localctx = NewFindOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, KQLParserRULE_findOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1283)
		p.Match(KQLParserFIND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1285)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserWITH_SOURCE || _la == KQLParserDATA_SCOPE {
		{
			p.SetState(1284)
			p.FindParams()
		}

	}
	p.SetState(1292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserIN {
		{
			p.SetState(1287)
			p.Match(KQLParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1288)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1289)
			p.TableList()
		}
		{
			p.SetState(1290)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1294)
		p.Match(KQLParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1295)
		p.Expression()
	}
	p.SetState(1298)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserPROJECT {
		{
			p.SetState(1296)
			p.Match(KQLParserPROJECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1297)
			p.ProjectItemList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFindParamsContext is an interface to support dynamic dispatch.
type IFindParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SOURCE() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	Identifier() IIdentifierContext
	DATA_SCOPE() antlr.TerminalNode

	// IsFindParamsContext differentiates from other interfaces.
	IsFindParamsContext()
}

type FindParamsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFindParamsContext() *FindParamsContext {
	var p = new(FindParamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_findParams
	return p
}

func InitEmptyFindParamsContext(p *FindParamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_findParams
}

func (*FindParamsContext) IsFindParamsContext() {}

func NewFindParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FindParamsContext {
	var p = new(FindParamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_findParams

	return p
}

func (s *FindParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *FindParamsContext) WITH_SOURCE() antlr.TerminalNode {
	return s.GetToken(KQLParserWITH_SOURCE, 0)
}

func (s *FindParamsContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *FindParamsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FindParamsContext) DATA_SCOPE() antlr.TerminalNode {
	return s.GetToken(KQLParserDATA_SCOPE, 0)
}

func (s *FindParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FindParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FindParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterFindParams(s)
	}
}

func (s *FindParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitFindParams(s)
	}
}

func (s *FindParamsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitFindParams(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) FindParams() (localctx IFindParamsContext) {
	localctx = NewFindParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, KQLParserRULE_findParams)
	p.SetState(1306)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KQLParserWITH_SOURCE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1300)
			p.Match(KQLParserWITH_SOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1301)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1302)
			p.Identifier()
		}

	case KQLParserDATA_SCOPE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1303)
			p.Match(KQLParserDATA_SCOPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1304)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1305)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGetschemaOperatorContext is an interface to support dynamic dispatch.
type IGetschemaOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GETSCHEMA() antlr.TerminalNode

	// IsGetschemaOperatorContext differentiates from other interfaces.
	IsGetschemaOperatorContext()
}

type GetschemaOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGetschemaOperatorContext() *GetschemaOperatorContext {
	var p = new(GetschemaOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_getschemaOperator
	return p
}

func InitEmptyGetschemaOperatorContext(p *GetschemaOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_getschemaOperator
}

func (*GetschemaOperatorContext) IsGetschemaOperatorContext() {}

func NewGetschemaOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GetschemaOperatorContext {
	var p = new(GetschemaOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_getschemaOperator

	return p
}

func (s *GetschemaOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *GetschemaOperatorContext) GETSCHEMA() antlr.TerminalNode {
	return s.GetToken(KQLParserGETSCHEMA, 0)
}

func (s *GetschemaOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GetschemaOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GetschemaOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterGetschemaOperator(s)
	}
}

func (s *GetschemaOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitGetschemaOperator(s)
	}
}

func (s *GetschemaOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitGetschemaOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) GetschemaOperator() (localctx IGetschemaOperatorContext) {
	localctx = NewGetschemaOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, KQLParserRULE_getschemaOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1308)
		p.Match(KQLParserGETSCHEMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenderOperatorContext is an interface to support dynamic dispatch.
type IRenderOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENDER() antlr.TerminalNode
	Identifier() IIdentifierContext
	RenderProperties() IRenderPropertiesContext

	// IsRenderOperatorContext differentiates from other interfaces.
	IsRenderOperatorContext()
}

type RenderOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenderOperatorContext() *RenderOperatorContext {
	var p = new(RenderOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_renderOperator
	return p
}

func InitEmptyRenderOperatorContext(p *RenderOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_renderOperator
}

func (*RenderOperatorContext) IsRenderOperatorContext() {}

func NewRenderOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenderOperatorContext {
	var p = new(RenderOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_renderOperator

	return p
}

func (s *RenderOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *RenderOperatorContext) RENDER() antlr.TerminalNode {
	return s.GetToken(KQLParserRENDER, 0)
}

func (s *RenderOperatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenderOperatorContext) RenderProperties() IRenderPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenderPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenderPropertiesContext)
}

func (s *RenderOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenderOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenderOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterRenderOperator(s)
	}
}

func (s *RenderOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitRenderOperator(s)
	}
}

func (s *RenderOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitRenderOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) RenderOperator() (localctx IRenderOperatorContext) {
	localctx = NewRenderOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, KQLParserRULE_renderOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1310)
		p.Match(KQLParserRENDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1311)
		p.Identifier()
	}
	p.SetState(1313)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserWITH {
		{
			p.SetState(1312)
			p.RenderProperties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenderPropertiesContext is an interface to support dynamic dispatch.
type IRenderPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllRenderProperty() []IRenderPropertyContext
	RenderProperty(i int) IRenderPropertyContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsRenderPropertiesContext differentiates from other interfaces.
	IsRenderPropertiesContext()
}

type RenderPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenderPropertiesContext() *RenderPropertiesContext {
	var p = new(RenderPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_renderProperties
	return p
}

func InitEmptyRenderPropertiesContext(p *RenderPropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_renderProperties
}

func (*RenderPropertiesContext) IsRenderPropertiesContext() {}

func NewRenderPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenderPropertiesContext {
	var p = new(RenderPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_renderProperties

	return p
}

func (s *RenderPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *RenderPropertiesContext) WITH() antlr.TerminalNode {
	return s.GetToken(KQLParserWITH, 0)
}

func (s *RenderPropertiesContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *RenderPropertiesContext) AllRenderProperty() []IRenderPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRenderPropertyContext); ok {
			len++
		}
	}

	tst := make([]IRenderPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRenderPropertyContext); ok {
			tst[i] = t.(IRenderPropertyContext)
			i++
		}
	}

	return tst
}

func (s *RenderPropertiesContext) RenderProperty(i int) IRenderPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenderPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenderPropertyContext)
}

func (s *RenderPropertiesContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *RenderPropertiesContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *RenderPropertiesContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *RenderPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenderPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenderPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterRenderProperties(s)
	}
}

func (s *RenderPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitRenderProperties(s)
	}
}

func (s *RenderPropertiesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitRenderProperties(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) RenderProperties() (localctx IRenderPropertiesContext) {
	localctx = NewRenderPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, KQLParserRULE_renderProperties)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1315)
		p.Match(KQLParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1316)
		p.Match(KQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1317)
		p.RenderProperty()
	}
	p.SetState(1322)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(1318)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1319)
			p.RenderProperty()
		}

		p.SetState(1324)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1325)
		p.Match(KQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenderPropertyContext is an interface to support dynamic dispatch.
type IRenderPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsRenderPropertyContext differentiates from other interfaces.
	IsRenderPropertyContext()
}

type RenderPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenderPropertyContext() *RenderPropertyContext {
	var p = new(RenderPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_renderProperty
	return p
}

func InitEmptyRenderPropertyContext(p *RenderPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_renderProperty
}

func (*RenderPropertyContext) IsRenderPropertyContext() {}

func NewRenderPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenderPropertyContext {
	var p = new(RenderPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_renderProperty

	return p
}

func (s *RenderPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *RenderPropertyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RenderPropertyContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *RenderPropertyContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RenderPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenderPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenderPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterRenderProperty(s)
	}
}

func (s *RenderPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitRenderProperty(s)
	}
}

func (s *RenderPropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitRenderProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) RenderProperty() (localctx IRenderPropertyContext) {
	localctx = NewRenderPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, KQLParserRULE_renderProperty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1327)
		p.Identifier()
	}
	{
		p.SetState(1328)
		p.Match(KQLParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1329)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConsumeOperatorContext is an interface to support dynamic dispatch.
type IConsumeOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONSUME() antlr.TerminalNode
	DECODEBLOCKS() antlr.TerminalNode
	ASSIGN() antlr.TerminalNode
	BooleanLiteral() IBooleanLiteralContext

	// IsConsumeOperatorContext differentiates from other interfaces.
	IsConsumeOperatorContext()
}

type ConsumeOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConsumeOperatorContext() *ConsumeOperatorContext {
	var p = new(ConsumeOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_consumeOperator
	return p
}

func InitEmptyConsumeOperatorContext(p *ConsumeOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_consumeOperator
}

func (*ConsumeOperatorContext) IsConsumeOperatorContext() {}

func NewConsumeOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConsumeOperatorContext {
	var p = new(ConsumeOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_consumeOperator

	return p
}

func (s *ConsumeOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ConsumeOperatorContext) CONSUME() antlr.TerminalNode {
	return s.GetToken(KQLParserCONSUME, 0)
}

func (s *ConsumeOperatorContext) DECODEBLOCKS() antlr.TerminalNode {
	return s.GetToken(KQLParserDECODEBLOCKS, 0)
}

func (s *ConsumeOperatorContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *ConsumeOperatorContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *ConsumeOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConsumeOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConsumeOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterConsumeOperator(s)
	}
}

func (s *ConsumeOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitConsumeOperator(s)
	}
}

func (s *ConsumeOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitConsumeOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ConsumeOperator() (localctx IConsumeOperatorContext) {
	localctx = NewConsumeOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, KQLParserRULE_consumeOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1331)
		p.Match(KQLParserCONSUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1335)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserDECODEBLOCKS {
		{
			p.SetState(1332)
			p.Match(KQLParserDECODEBLOCKS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1333)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1334)
			p.BooleanLiteral()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInvokeOperatorContext is an interface to support dynamic dispatch.
type IInvokeOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INVOKE() antlr.TerminalNode
	FunctionCall() IFunctionCallContext

	// IsInvokeOperatorContext differentiates from other interfaces.
	IsInvokeOperatorContext()
}

type InvokeOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInvokeOperatorContext() *InvokeOperatorContext {
	var p = new(InvokeOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_invokeOperator
	return p
}

func InitEmptyInvokeOperatorContext(p *InvokeOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_invokeOperator
}

func (*InvokeOperatorContext) IsInvokeOperatorContext() {}

func NewInvokeOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InvokeOperatorContext {
	var p = new(InvokeOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_invokeOperator

	return p
}

func (s *InvokeOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *InvokeOperatorContext) INVOKE() antlr.TerminalNode {
	return s.GetToken(KQLParserINVOKE, 0)
}

func (s *InvokeOperatorContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *InvokeOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvokeOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InvokeOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterInvokeOperator(s)
	}
}

func (s *InvokeOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitInvokeOperator(s)
	}
}

func (s *InvokeOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitInvokeOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) InvokeOperator() (localctx IInvokeOperatorContext) {
	localctx = NewInvokeOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, KQLParserRULE_invokeOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1337)
		p.Match(KQLParserINVOKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1338)
		p.FunctionCall()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsOperatorContext is an interface to support dynamic dispatch.
type IAsOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsAsOperatorContext differentiates from other interfaces.
	IsAsOperatorContext()
}

type AsOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsOperatorContext() *AsOperatorContext {
	var p = new(AsOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_asOperator
	return p
}

func InitEmptyAsOperatorContext(p *AsOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_asOperator
}

func (*AsOperatorContext) IsAsOperatorContext() {}

func NewAsOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsOperatorContext {
	var p = new(AsOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_asOperator

	return p
}

func (s *AsOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AsOperatorContext) AS() antlr.TerminalNode {
	return s.GetToken(KQLParserAS, 0)
}

func (s *AsOperatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AsOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterAsOperator(s)
	}
}

func (s *AsOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitAsOperator(s)
	}
}

func (s *AsOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitAsOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) AsOperator() (localctx IAsOperatorContext) {
	localctx = NewAsOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, KQLParserRULE_asOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1340)
		p.Match(KQLParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1341)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphOperatorContext is an interface to support dynamic dispatch.
type IGraphOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MakeGraphOperator() IMakeGraphOperatorContext
	GraphMatchOperator() IGraphMatchOperatorContext
	GraphShortestPathsOperator() IGraphShortestPathsOperatorContext
	GraphToTableOperator() IGraphToTableOperatorContext

	// IsGraphOperatorContext differentiates from other interfaces.
	IsGraphOperatorContext()
}

type GraphOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphOperatorContext() *GraphOperatorContext {
	var p = new(GraphOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_graphOperator
	return p
}

func InitEmptyGraphOperatorContext(p *GraphOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_graphOperator
}

func (*GraphOperatorContext) IsGraphOperatorContext() {}

func NewGraphOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphOperatorContext {
	var p = new(GraphOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_graphOperator

	return p
}

func (s *GraphOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphOperatorContext) MakeGraphOperator() IMakeGraphOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMakeGraphOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMakeGraphOperatorContext)
}

func (s *GraphOperatorContext) GraphMatchOperator() IGraphMatchOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphMatchOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphMatchOperatorContext)
}

func (s *GraphOperatorContext) GraphShortestPathsOperator() IGraphShortestPathsOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphShortestPathsOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphShortestPathsOperatorContext)
}

func (s *GraphOperatorContext) GraphToTableOperator() IGraphToTableOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphToTableOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphToTableOperatorContext)
}

func (s *GraphOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterGraphOperator(s)
	}
}

func (s *GraphOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitGraphOperator(s)
	}
}

func (s *GraphOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitGraphOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) GraphOperator() (localctx IGraphOperatorContext) {
	localctx = NewGraphOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, KQLParserRULE_graphOperator)
	p.SetState(1347)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KQLParserMAKE_GRAPH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1343)
			p.MakeGraphOperator()
		}

	case KQLParserGRAPH_MATCH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1344)
			p.GraphMatchOperator()
		}

	case KQLParserGRAPH_SHORTEST_PATHS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1345)
			p.GraphShortestPathsOperator()
		}

	case KQLParserGRAPH_TO_TABLE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1346)
			p.GraphToTableOperator()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMakeGraphOperatorContext is an interface to support dynamic dispatch.
type IMakeGraphOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAKE_GRAPH() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	ARROW() antlr.TerminalNode
	WITH() antlr.TerminalNode
	TableName() ITableNameContext
	ON() antlr.TerminalNode

	// IsMakeGraphOperatorContext differentiates from other interfaces.
	IsMakeGraphOperatorContext()
}

type MakeGraphOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMakeGraphOperatorContext() *MakeGraphOperatorContext {
	var p = new(MakeGraphOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_makeGraphOperator
	return p
}

func InitEmptyMakeGraphOperatorContext(p *MakeGraphOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_makeGraphOperator
}

func (*MakeGraphOperatorContext) IsMakeGraphOperatorContext() {}

func NewMakeGraphOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MakeGraphOperatorContext {
	var p = new(MakeGraphOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_makeGraphOperator

	return p
}

func (s *MakeGraphOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *MakeGraphOperatorContext) MAKE_GRAPH() antlr.TerminalNode {
	return s.GetToken(KQLParserMAKE_GRAPH, 0)
}

func (s *MakeGraphOperatorContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *MakeGraphOperatorContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MakeGraphOperatorContext) ARROW() antlr.TerminalNode {
	return s.GetToken(KQLParserARROW, 0)
}

func (s *MakeGraphOperatorContext) WITH() antlr.TerminalNode {
	return s.GetToken(KQLParserWITH, 0)
}

func (s *MakeGraphOperatorContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *MakeGraphOperatorContext) ON() antlr.TerminalNode {
	return s.GetToken(KQLParserON, 0)
}

func (s *MakeGraphOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MakeGraphOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MakeGraphOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterMakeGraphOperator(s)
	}
}

func (s *MakeGraphOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitMakeGraphOperator(s)
	}
}

func (s *MakeGraphOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitMakeGraphOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) MakeGraphOperator() (localctx IMakeGraphOperatorContext) {
	localctx = NewMakeGraphOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, KQLParserRULE_makeGraphOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1349)
		p.Match(KQLParserMAKE_GRAPH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1350)
		p.Identifier()
	}
	{
		p.SetState(1351)
		p.Match(KQLParserARROW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1352)
		p.Identifier()
	}
	{
		p.SetState(1353)
		p.Match(KQLParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1354)
		p.TableName()
	}
	{
		p.SetState(1355)
		p.Match(KQLParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1356)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphMatchOperatorContext is an interface to support dynamic dispatch.
type IGraphMatchOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GRAPH_MATCH() antlr.TerminalNode
	GraphPattern() IGraphPatternContext
	PROJECT() antlr.TerminalNode
	ProjectItemList() IProjectItemListContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsGraphMatchOperatorContext differentiates from other interfaces.
	IsGraphMatchOperatorContext()
}

type GraphMatchOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphMatchOperatorContext() *GraphMatchOperatorContext {
	var p = new(GraphMatchOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_graphMatchOperator
	return p
}

func InitEmptyGraphMatchOperatorContext(p *GraphMatchOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_graphMatchOperator
}

func (*GraphMatchOperatorContext) IsGraphMatchOperatorContext() {}

func NewGraphMatchOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphMatchOperatorContext {
	var p = new(GraphMatchOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_graphMatchOperator

	return p
}

func (s *GraphMatchOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphMatchOperatorContext) GRAPH_MATCH() antlr.TerminalNode {
	return s.GetToken(KQLParserGRAPH_MATCH, 0)
}

func (s *GraphMatchOperatorContext) GraphPattern() IGraphPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphPatternContext)
}

func (s *GraphMatchOperatorContext) PROJECT() antlr.TerminalNode {
	return s.GetToken(KQLParserPROJECT, 0)
}

func (s *GraphMatchOperatorContext) ProjectItemList() IProjectItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectItemListContext)
}

func (s *GraphMatchOperatorContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KQLParserWHERE, 0)
}

func (s *GraphMatchOperatorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GraphMatchOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphMatchOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphMatchOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterGraphMatchOperator(s)
	}
}

func (s *GraphMatchOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitGraphMatchOperator(s)
	}
}

func (s *GraphMatchOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitGraphMatchOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) GraphMatchOperator() (localctx IGraphMatchOperatorContext) {
	localctx = NewGraphMatchOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, KQLParserRULE_graphMatchOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1358)
		p.Match(KQLParserGRAPH_MATCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1359)
		p.GraphPattern()
	}
	p.SetState(1362)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserPROJECT {
		{
			p.SetState(1360)
			p.Match(KQLParserPROJECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1361)
			p.ProjectItemList()
		}

	}
	p.SetState(1366)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserWHERE {
		{
			p.SetState(1364)
			p.Match(KQLParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1365)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphPatternContext is an interface to support dynamic dispatch.
type IGraphPatternContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGraphPatternElement() []IGraphPatternElementContext
	GraphPatternElement(i int) IGraphPatternElementContext

	// IsGraphPatternContext differentiates from other interfaces.
	IsGraphPatternContext()
}

type GraphPatternContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphPatternContext() *GraphPatternContext {
	var p = new(GraphPatternContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_graphPattern
	return p
}

func InitEmptyGraphPatternContext(p *GraphPatternContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_graphPattern
}

func (*GraphPatternContext) IsGraphPatternContext() {}

func NewGraphPatternContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphPatternContext {
	var p = new(GraphPatternContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_graphPattern

	return p
}

func (s *GraphPatternContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphPatternContext) AllGraphPatternElement() []IGraphPatternElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGraphPatternElementContext); ok {
			len++
		}
	}

	tst := make([]IGraphPatternElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGraphPatternElementContext); ok {
			tst[i] = t.(IGraphPatternElementContext)
			i++
		}
	}

	return tst
}

func (s *GraphPatternContext) GraphPatternElement(i int) IGraphPatternElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphPatternElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphPatternElementContext)
}

func (s *GraphPatternContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphPatternContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphPatternContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterGraphPattern(s)
	}
}

func (s *GraphPatternContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitGraphPattern(s)
	}
}

func (s *GraphPatternContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitGraphPattern(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) GraphPattern() (localctx IGraphPatternContext) {
	localctx = NewGraphPatternContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, KQLParserRULE_graphPattern)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1369)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == KQLParserLPAREN {
		{
			p.SetState(1368)
			p.GraphPatternElement()
		}

		p.SetState(1371)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphPatternElementContext is an interface to support dynamic dispatch.
type IGraphPatternElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LPAREN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RPAREN() antlr.TerminalNode
	COLON() antlr.TerminalNode
	GraphEdge() IGraphEdgeContext

	// IsGraphPatternElementContext differentiates from other interfaces.
	IsGraphPatternElementContext()
}

type GraphPatternElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphPatternElementContext() *GraphPatternElementContext {
	var p = new(GraphPatternElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_graphPatternElement
	return p
}

func InitEmptyGraphPatternElementContext(p *GraphPatternElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_graphPatternElement
}

func (*GraphPatternElementContext) IsGraphPatternElementContext() {}

func NewGraphPatternElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphPatternElementContext {
	var p = new(GraphPatternElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_graphPatternElement

	return p
}

func (s *GraphPatternElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphPatternElementContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *GraphPatternElementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *GraphPatternElementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GraphPatternElementContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *GraphPatternElementContext) COLON() antlr.TerminalNode {
	return s.GetToken(KQLParserCOLON, 0)
}

func (s *GraphPatternElementContext) GraphEdge() IGraphEdgeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphEdgeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphEdgeContext)
}

func (s *GraphPatternElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphPatternElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphPatternElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterGraphPatternElement(s)
	}
}

func (s *GraphPatternElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitGraphPatternElement(s)
	}
}

func (s *GraphPatternElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitGraphPatternElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) GraphPatternElement() (localctx IGraphPatternElementContext) {
	localctx = NewGraphPatternElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, KQLParserRULE_graphPatternElement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1373)
		p.Match(KQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1374)
		p.Identifier()
	}
	p.SetState(1377)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserCOLON {
		{
			p.SetState(1375)
			p.Match(KQLParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1376)
			p.Identifier()
		}

	}
	{
		p.SetState(1379)
		p.Match(KQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserLT || _la == KQLParserMINUS {
		{
			p.SetState(1380)
			p.GraphEdge()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphEdgeContext is an interface to support dynamic dispatch.
type IGraphEdgeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode
	LBRACKET() antlr.TerminalNode
	RBRACKET() antlr.TerminalNode
	ARROW() antlr.TerminalNode
	GraphPatternElement() IGraphPatternElementContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	COLON() antlr.TerminalNode
	LT() antlr.TerminalNode

	// IsGraphEdgeContext differentiates from other interfaces.
	IsGraphEdgeContext()
}

type GraphEdgeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphEdgeContext() *GraphEdgeContext {
	var p = new(GraphEdgeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_graphEdge
	return p
}

func InitEmptyGraphEdgeContext(p *GraphEdgeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_graphEdge
}

func (*GraphEdgeContext) IsGraphEdgeContext() {}

func NewGraphEdgeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphEdgeContext {
	var p = new(GraphEdgeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_graphEdge

	return p
}

func (s *GraphEdgeContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphEdgeContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(KQLParserMINUS)
}

func (s *GraphEdgeContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserMINUS, i)
}

func (s *GraphEdgeContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(KQLParserLBRACKET, 0)
}

func (s *GraphEdgeContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(KQLParserRBRACKET, 0)
}

func (s *GraphEdgeContext) ARROW() antlr.TerminalNode {
	return s.GetToken(KQLParserARROW, 0)
}

func (s *GraphEdgeContext) GraphPatternElement() IGraphPatternElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphPatternElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphPatternElementContext)
}

func (s *GraphEdgeContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *GraphEdgeContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GraphEdgeContext) COLON() antlr.TerminalNode {
	return s.GetToken(KQLParserCOLON, 0)
}

func (s *GraphEdgeContext) LT() antlr.TerminalNode {
	return s.GetToken(KQLParserLT, 0)
}

func (s *GraphEdgeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphEdgeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphEdgeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterGraphEdge(s)
	}
}

func (s *GraphEdgeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitGraphEdge(s)
	}
}

func (s *GraphEdgeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitGraphEdge(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) GraphEdge() (localctx IGraphEdgeContext) {
	localctx = NewGraphEdgeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, KQLParserRULE_graphEdge)
	var _la int

	p.SetState(1408)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KQLParserMINUS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1383)
			p.Match(KQLParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1384)
			p.Match(KQLParserLBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1386)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-861298014345919093) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&-9187360625863417885) != 0) {
			{
				p.SetState(1385)
				p.Identifier()
			}

		}
		p.SetState(1390)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserCOLON {
			{
				p.SetState(1388)
				p.Match(KQLParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1389)
				p.Identifier()
			}

		}
		{
			p.SetState(1392)
			p.Match(KQLParserRBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1393)
			p.Match(KQLParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1394)
			p.GraphPatternElement()
		}

	case KQLParserLT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1395)
			p.Match(KQLParserLT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1396)
			p.Match(KQLParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1397)
			p.Match(KQLParserLBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1399)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-861298014345919093) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&-9187360625863417885) != 0) {
			{
				p.SetState(1398)
				p.Identifier()
			}

		}
		p.SetState(1403)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == KQLParserCOLON {
			{
				p.SetState(1401)
				p.Match(KQLParserCOLON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1402)
				p.Identifier()
			}

		}
		{
			p.SetState(1405)
			p.Match(KQLParserRBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1406)
			p.Match(KQLParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1407)
			p.GraphPatternElement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphShortestPathsOperatorContext is an interface to support dynamic dispatch.
type IGraphShortestPathsOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GRAPH_SHORTEST_PATHS() antlr.TerminalNode
	GraphPattern() IGraphPatternContext
	PROJECT() antlr.TerminalNode
	ProjectItemList() IProjectItemListContext

	// IsGraphShortestPathsOperatorContext differentiates from other interfaces.
	IsGraphShortestPathsOperatorContext()
}

type GraphShortestPathsOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphShortestPathsOperatorContext() *GraphShortestPathsOperatorContext {
	var p = new(GraphShortestPathsOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_graphShortestPathsOperator
	return p
}

func InitEmptyGraphShortestPathsOperatorContext(p *GraphShortestPathsOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_graphShortestPathsOperator
}

func (*GraphShortestPathsOperatorContext) IsGraphShortestPathsOperatorContext() {}

func NewGraphShortestPathsOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphShortestPathsOperatorContext {
	var p = new(GraphShortestPathsOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_graphShortestPathsOperator

	return p
}

func (s *GraphShortestPathsOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphShortestPathsOperatorContext) GRAPH_SHORTEST_PATHS() antlr.TerminalNode {
	return s.GetToken(KQLParserGRAPH_SHORTEST_PATHS, 0)
}

func (s *GraphShortestPathsOperatorContext) GraphPattern() IGraphPatternContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphPatternContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphPatternContext)
}

func (s *GraphShortestPathsOperatorContext) PROJECT() antlr.TerminalNode {
	return s.GetToken(KQLParserPROJECT, 0)
}

func (s *GraphShortestPathsOperatorContext) ProjectItemList() IProjectItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProjectItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProjectItemListContext)
}

func (s *GraphShortestPathsOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphShortestPathsOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphShortestPathsOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterGraphShortestPathsOperator(s)
	}
}

func (s *GraphShortestPathsOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitGraphShortestPathsOperator(s)
	}
}

func (s *GraphShortestPathsOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitGraphShortestPathsOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) GraphShortestPathsOperator() (localctx IGraphShortestPathsOperatorContext) {
	localctx = NewGraphShortestPathsOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, KQLParserRULE_graphShortestPathsOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1410)
		p.Match(KQLParserGRAPH_SHORTEST_PATHS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1411)
		p.GraphPattern()
	}
	p.SetState(1414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserPROJECT {
		{
			p.SetState(1412)
			p.Match(KQLParserPROJECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1413)
			p.ProjectItemList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphToTableOperatorContext is an interface to support dynamic dispatch.
type IGraphToTableOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GRAPH_TO_TABLE() antlr.TerminalNode
	GraphToTableParams() IGraphToTableParamsContext

	// IsGraphToTableOperatorContext differentiates from other interfaces.
	IsGraphToTableOperatorContext()
}

type GraphToTableOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphToTableOperatorContext() *GraphToTableOperatorContext {
	var p = new(GraphToTableOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_graphToTableOperator
	return p
}

func InitEmptyGraphToTableOperatorContext(p *GraphToTableOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_graphToTableOperator
}

func (*GraphToTableOperatorContext) IsGraphToTableOperatorContext() {}

func NewGraphToTableOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphToTableOperatorContext {
	var p = new(GraphToTableOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_graphToTableOperator

	return p
}

func (s *GraphToTableOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphToTableOperatorContext) GRAPH_TO_TABLE() antlr.TerminalNode {
	return s.GetToken(KQLParserGRAPH_TO_TABLE, 0)
}

func (s *GraphToTableOperatorContext) GraphToTableParams() IGraphToTableParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGraphToTableParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGraphToTableParamsContext)
}

func (s *GraphToTableOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphToTableOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphToTableOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterGraphToTableOperator(s)
	}
}

func (s *GraphToTableOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitGraphToTableOperator(s)
	}
}

func (s *GraphToTableOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitGraphToTableOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) GraphToTableOperator() (localctx IGraphToTableOperatorContext) {
	localctx = NewGraphToTableOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, KQLParserRULE_graphToTableOperator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1416)
		p.Match(KQLParserGRAPH_TO_TABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1417)
		p.GraphToTableParams()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGraphToTableParamsContext is an interface to support dynamic dispatch.
type IGraphToTableParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NODES() antlr.TerminalNode
	EDGES() antlr.TerminalNode
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsGraphToTableParamsContext differentiates from other interfaces.
	IsGraphToTableParamsContext()
}

type GraphToTableParamsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGraphToTableParamsContext() *GraphToTableParamsContext {
	var p = new(GraphToTableParamsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_graphToTableParams
	return p
}

func InitEmptyGraphToTableParamsContext(p *GraphToTableParamsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_graphToTableParams
}

func (*GraphToTableParamsContext) IsGraphToTableParamsContext() {}

func NewGraphToTableParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GraphToTableParamsContext {
	var p = new(GraphToTableParamsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_graphToTableParams

	return p
}

func (s *GraphToTableParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *GraphToTableParamsContext) NODES() antlr.TerminalNode {
	return s.GetToken(KQLParserNODES, 0)
}

func (s *GraphToTableParamsContext) EDGES() antlr.TerminalNode {
	return s.GetToken(KQLParserEDGES, 0)
}

func (s *GraphToTableParamsContext) AS() antlr.TerminalNode {
	return s.GetToken(KQLParserAS, 0)
}

func (s *GraphToTableParamsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GraphToTableParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GraphToTableParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GraphToTableParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterGraphToTableParams(s)
	}
}

func (s *GraphToTableParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitGraphToTableParams(s)
	}
}

func (s *GraphToTableParamsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitGraphToTableParams(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) GraphToTableParams() (localctx IGraphToTableParamsContext) {
	localctx = NewGraphToTableParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, KQLParserRULE_graphToTableParams)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1419)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KQLParserNODES || _la == KQLParserEDGES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1422)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserAS {
		{
			p.SetState(1420)
			p.Match(KQLParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1421)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatatableContext is an interface to support dynamic dispatch.
type IDatatableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATATABLE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	DatatableSchema() IDatatableSchemaContext
	RPAREN() antlr.TerminalNode
	LBRACKET() antlr.TerminalNode
	DatatableRows() IDatatableRowsContext
	RBRACKET() antlr.TerminalNode

	// IsDatatableContext differentiates from other interfaces.
	IsDatatableContext()
}

type DatatableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatatableContext() *DatatableContext {
	var p = new(DatatableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_datatable
	return p
}

func InitEmptyDatatableContext(p *DatatableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_datatable
}

func (*DatatableContext) IsDatatableContext() {}

func NewDatatableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatatableContext {
	var p = new(DatatableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_datatable

	return p
}

func (s *DatatableContext) GetParser() antlr.Parser { return s.parser }

func (s *DatatableContext) DATATABLE() antlr.TerminalNode {
	return s.GetToken(KQLParserDATATABLE, 0)
}

func (s *DatatableContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *DatatableContext) DatatableSchema() IDatatableSchemaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatatableSchemaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatatableSchemaContext)
}

func (s *DatatableContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *DatatableContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(KQLParserLBRACKET, 0)
}

func (s *DatatableContext) DatatableRows() IDatatableRowsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatatableRowsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatatableRowsContext)
}

func (s *DatatableContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(KQLParserRBRACKET, 0)
}

func (s *DatatableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatatableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatatableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterDatatable(s)
	}
}

func (s *DatatableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitDatatable(s)
	}
}

func (s *DatatableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitDatatable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) Datatable() (localctx IDatatableContext) {
	localctx = NewDatatableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, KQLParserRULE_datatable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1424)
		p.Match(KQLParserDATATABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1425)
		p.Match(KQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1426)
		p.DatatableSchema()
	}
	{
		p.SetState(1427)
		p.Match(KQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1428)
		p.Match(KQLParserLBRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1429)
		p.DatatableRows()
	}
	{
		p.SetState(1430)
		p.Match(KQLParserRBRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatatableSchemaContext is an interface to support dynamic dispatch.
type IDatatableSchemaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDatatableColumn() []IDatatableColumnContext
	DatatableColumn(i int) IDatatableColumnContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDatatableSchemaContext differentiates from other interfaces.
	IsDatatableSchemaContext()
}

type DatatableSchemaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatatableSchemaContext() *DatatableSchemaContext {
	var p = new(DatatableSchemaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_datatableSchema
	return p
}

func InitEmptyDatatableSchemaContext(p *DatatableSchemaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_datatableSchema
}

func (*DatatableSchemaContext) IsDatatableSchemaContext() {}

func NewDatatableSchemaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatatableSchemaContext {
	var p = new(DatatableSchemaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_datatableSchema

	return p
}

func (s *DatatableSchemaContext) GetParser() antlr.Parser { return s.parser }

func (s *DatatableSchemaContext) AllDatatableColumn() []IDatatableColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDatatableColumnContext); ok {
			len++
		}
	}

	tst := make([]IDatatableColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDatatableColumnContext); ok {
			tst[i] = t.(IDatatableColumnContext)
			i++
		}
	}

	return tst
}

func (s *DatatableSchemaContext) DatatableColumn(i int) IDatatableColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatatableColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatatableColumnContext)
}

func (s *DatatableSchemaContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *DatatableSchemaContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *DatatableSchemaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatatableSchemaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatatableSchemaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterDatatableSchema(s)
	}
}

func (s *DatatableSchemaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitDatatableSchema(s)
	}
}

func (s *DatatableSchemaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitDatatableSchema(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) DatatableSchema() (localctx IDatatableSchemaContext) {
	localctx = NewDatatableSchemaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, KQLParserRULE_datatableSchema)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1432)
		p.DatatableColumn()
	}
	p.SetState(1437)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(1433)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1434)
			p.DatatableColumn()
		}

		p.SetState(1439)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatatableColumnContext is an interface to support dynamic dispatch.
type IDatatableColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	TypeSpecifier() ITypeSpecifierContext

	// IsDatatableColumnContext differentiates from other interfaces.
	IsDatatableColumnContext()
}

type DatatableColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatatableColumnContext() *DatatableColumnContext {
	var p = new(DatatableColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_datatableColumn
	return p
}

func InitEmptyDatatableColumnContext(p *DatatableColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_datatableColumn
}

func (*DatatableColumnContext) IsDatatableColumnContext() {}

func NewDatatableColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatatableColumnContext {
	var p = new(DatatableColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_datatableColumn

	return p
}

func (s *DatatableColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *DatatableColumnContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DatatableColumnContext) COLON() antlr.TerminalNode {
	return s.GetToken(KQLParserCOLON, 0)
}

func (s *DatatableColumnContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *DatatableColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatatableColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatatableColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterDatatableColumn(s)
	}
}

func (s *DatatableColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitDatatableColumn(s)
	}
}

func (s *DatatableColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitDatatableColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) DatatableColumn() (localctx IDatatableColumnContext) {
	localctx = NewDatatableColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, KQLParserRULE_datatableColumn)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1440)
		p.Identifier()
	}
	{
		p.SetState(1441)
		p.Match(KQLParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1442)
		p.TypeSpecifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDatatableRowsContext is an interface to support dynamic dispatch.
type IDatatableRowsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLiteral() []ILiteralContext
	Literal(i int) ILiteralContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsDatatableRowsContext differentiates from other interfaces.
	IsDatatableRowsContext()
}

type DatatableRowsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatatableRowsContext() *DatatableRowsContext {
	var p = new(DatatableRowsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_datatableRows
	return p
}

func InitEmptyDatatableRowsContext(p *DatatableRowsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_datatableRows
}

func (*DatatableRowsContext) IsDatatableRowsContext() {}

func NewDatatableRowsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DatatableRowsContext {
	var p = new(DatatableRowsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_datatableRows

	return p
}

func (s *DatatableRowsContext) GetParser() antlr.Parser { return s.parser }

func (s *DatatableRowsContext) AllLiteral() []ILiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteralContext); ok {
			len++
		}
	}

	tst := make([]ILiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteralContext); ok {
			tst[i] = t.(ILiteralContext)
			i++
		}
	}

	return tst
}

func (s *DatatableRowsContext) Literal(i int) ILiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DatatableRowsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *DatatableRowsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *DatatableRowsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DatatableRowsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DatatableRowsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterDatatableRows(s)
	}
}

func (s *DatatableRowsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitDatatableRows(s)
	}
}

func (s *DatatableRowsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitDatatableRows(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) DatatableRows() (localctx IDatatableRowsContext) {
	localctx = NewDatatableRowsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, KQLParserRULE_datatableRows)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-178)) & ^0x3f) == 0 && ((int64(1)<<(_la-178))&133693695) != 0 {
		{
			p.SetState(1444)
			p.Literal()
		}
		p.SetState(1449)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == KQLParserCOMMA {
			{
				p.SetState(1445)
				p.Match(KQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1446)
				p.Literal()
			}

			p.SetState(1451)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternalDataContext is an interface to support dynamic dispatch.
type IExternalDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXTERNALDATA() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	DatatableSchema() IDatatableSchemaContext
	RPAREN() antlr.TerminalNode
	LBRACKET() antlr.TerminalNode
	AllExternalDataUri() []IExternalDataUriContext
	ExternalDataUri(i int) IExternalDataUriContext
	RBRACKET() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	ExternalDataOptions() IExternalDataOptionsContext

	// IsExternalDataContext differentiates from other interfaces.
	IsExternalDataContext()
}

type ExternalDataContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalDataContext() *ExternalDataContext {
	var p = new(ExternalDataContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_externalData
	return p
}

func InitEmptyExternalDataContext(p *ExternalDataContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_externalData
}

func (*ExternalDataContext) IsExternalDataContext() {}

func NewExternalDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalDataContext {
	var p = new(ExternalDataContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_externalData

	return p
}

func (s *ExternalDataContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalDataContext) EXTERNALDATA() antlr.TerminalNode {
	return s.GetToken(KQLParserEXTERNALDATA, 0)
}

func (s *ExternalDataContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *ExternalDataContext) DatatableSchema() IDatatableSchemaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDatatableSchemaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDatatableSchemaContext)
}

func (s *ExternalDataContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *ExternalDataContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(KQLParserLBRACKET, 0)
}

func (s *ExternalDataContext) AllExternalDataUri() []IExternalDataUriContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExternalDataUriContext); ok {
			len++
		}
	}

	tst := make([]IExternalDataUriContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExternalDataUriContext); ok {
			tst[i] = t.(IExternalDataUriContext)
			i++
		}
	}

	return tst
}

func (s *ExternalDataContext) ExternalDataUri(i int) IExternalDataUriContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternalDataUriContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternalDataUriContext)
}

func (s *ExternalDataContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(KQLParserRBRACKET, 0)
}

func (s *ExternalDataContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *ExternalDataContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *ExternalDataContext) ExternalDataOptions() IExternalDataOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternalDataOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternalDataOptionsContext)
}

func (s *ExternalDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalDataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterExternalData(s)
	}
}

func (s *ExternalDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitExternalData(s)
	}
}

func (s *ExternalDataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitExternalData(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ExternalData() (localctx IExternalDataContext) {
	localctx = NewExternalDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, KQLParserRULE_externalData)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1454)
		p.Match(KQLParserEXTERNALDATA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1455)
		p.Match(KQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1456)
		p.DatatableSchema()
	}
	{
		p.SetState(1457)
		p.Match(KQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1458)
		p.Match(KQLParserLBRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1459)
		p.ExternalDataUri()
	}
	p.SetState(1464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(1460)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1461)
			p.ExternalDataUri()
		}

		p.SetState(1466)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1467)
		p.Match(KQLParserRBRACKET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1469)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserWITH {
		{
			p.SetState(1468)
			p.ExternalDataOptions()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternalDataUriContext is an interface to support dynamic dispatch.
type IExternalDataUriContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode
	VERBATIM_STRING() antlr.TerminalNode

	// IsExternalDataUriContext differentiates from other interfaces.
	IsExternalDataUriContext()
}

type ExternalDataUriContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalDataUriContext() *ExternalDataUriContext {
	var p = new(ExternalDataUriContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_externalDataUri
	return p
}

func InitEmptyExternalDataUriContext(p *ExternalDataUriContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_externalDataUri
}

func (*ExternalDataUriContext) IsExternalDataUriContext() {}

func NewExternalDataUriContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalDataUriContext {
	var p = new(ExternalDataUriContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_externalDataUri

	return p
}

func (s *ExternalDataUriContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalDataUriContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(KQLParserSTRING_LITERAL, 0)
}

func (s *ExternalDataUriContext) VERBATIM_STRING() antlr.TerminalNode {
	return s.GetToken(KQLParserVERBATIM_STRING, 0)
}

func (s *ExternalDataUriContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalDataUriContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalDataUriContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterExternalDataUri(s)
	}
}

func (s *ExternalDataUriContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitExternalDataUri(s)
	}
}

func (s *ExternalDataUriContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitExternalDataUri(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ExternalDataUri() (localctx IExternalDataUriContext) {
	localctx = NewExternalDataUriContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, KQLParserRULE_externalDataUri)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1471)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KQLParserSTRING_LITERAL || _la == KQLParserVERBATIM_STRING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternalDataOptionsContext is an interface to support dynamic dispatch.
type IExternalDataOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllExternalDataOption() []IExternalDataOptionContext
	ExternalDataOption(i int) IExternalDataOptionContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExternalDataOptionsContext differentiates from other interfaces.
	IsExternalDataOptionsContext()
}

type ExternalDataOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalDataOptionsContext() *ExternalDataOptionsContext {
	var p = new(ExternalDataOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_externalDataOptions
	return p
}

func InitEmptyExternalDataOptionsContext(p *ExternalDataOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_externalDataOptions
}

func (*ExternalDataOptionsContext) IsExternalDataOptionsContext() {}

func NewExternalDataOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalDataOptionsContext {
	var p = new(ExternalDataOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_externalDataOptions

	return p
}

func (s *ExternalDataOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalDataOptionsContext) WITH() antlr.TerminalNode {
	return s.GetToken(KQLParserWITH, 0)
}

func (s *ExternalDataOptionsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *ExternalDataOptionsContext) AllExternalDataOption() []IExternalDataOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExternalDataOptionContext); ok {
			len++
		}
	}

	tst := make([]IExternalDataOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExternalDataOptionContext); ok {
			tst[i] = t.(IExternalDataOptionContext)
			i++
		}
	}

	return tst
}

func (s *ExternalDataOptionsContext) ExternalDataOption(i int) IExternalDataOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternalDataOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternalDataOptionContext)
}

func (s *ExternalDataOptionsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *ExternalDataOptionsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *ExternalDataOptionsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *ExternalDataOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalDataOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalDataOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterExternalDataOptions(s)
	}
}

func (s *ExternalDataOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitExternalDataOptions(s)
	}
}

func (s *ExternalDataOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitExternalDataOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ExternalDataOptions() (localctx IExternalDataOptionsContext) {
	localctx = NewExternalDataOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, KQLParserRULE_externalDataOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1473)
		p.Match(KQLParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1474)
		p.Match(KQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1475)
		p.ExternalDataOption()
	}
	p.SetState(1480)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(1476)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1477)
			p.ExternalDataOption()
		}

		p.SetState(1482)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1483)
		p.Match(KQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExternalDataOptionContext is an interface to support dynamic dispatch.
type IExternalDataOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsExternalDataOptionContext differentiates from other interfaces.
	IsExternalDataOptionContext()
}

type ExternalDataOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalDataOptionContext() *ExternalDataOptionContext {
	var p = new(ExternalDataOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_externalDataOption
	return p
}

func InitEmptyExternalDataOptionContext(p *ExternalDataOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_externalDataOption
}

func (*ExternalDataOptionContext) IsExternalDataOptionContext() {}

func NewExternalDataOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalDataOptionContext {
	var p = new(ExternalDataOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_externalDataOption

	return p
}

func (s *ExternalDataOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalDataOptionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExternalDataOptionContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *ExternalDataOptionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExternalDataOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalDataOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalDataOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterExternalDataOption(s)
	}
}

func (s *ExternalDataOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitExternalDataOption(s)
	}
}

func (s *ExternalDataOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitExternalDataOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ExternalDataOption() (localctx IExternalDataOptionContext) {
	localctx = NewExternalDataOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, KQLParserRULE_externalDataOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1485)
		p.Identifier()
	}
	{
		p.SetState(1486)
		p.Match(KQLParserASSIGN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1487)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrintArgListContext is an interface to support dynamic dispatch.
type IPrintArgListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrintArg() []IPrintArgContext
	PrintArg(i int) IPrintArgContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsPrintArgListContext differentiates from other interfaces.
	IsPrintArgListContext()
}

type PrintArgListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrintArgListContext() *PrintArgListContext {
	var p = new(PrintArgListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_printArgList
	return p
}

func InitEmptyPrintArgListContext(p *PrintArgListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_printArgList
}

func (*PrintArgListContext) IsPrintArgListContext() {}

func NewPrintArgListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrintArgListContext {
	var p = new(PrintArgListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_printArgList

	return p
}

func (s *PrintArgListContext) GetParser() antlr.Parser { return s.parser }

func (s *PrintArgListContext) AllPrintArg() []IPrintArgContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrintArgContext); ok {
			len++
		}
	}

	tst := make([]IPrintArgContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrintArgContext); ok {
			tst[i] = t.(IPrintArgContext)
			i++
		}
	}

	return tst
}

func (s *PrintArgListContext) PrintArg(i int) IPrintArgContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrintArgContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrintArgContext)
}

func (s *PrintArgListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *PrintArgListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *PrintArgListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintArgListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrintArgListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterPrintArgList(s)
	}
}

func (s *PrintArgListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitPrintArgList(s)
	}
}

func (s *PrintArgListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitPrintArgList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) PrintArgList() (localctx IPrintArgListContext) {
	localctx = NewPrintArgListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, KQLParserRULE_printArgList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1489)
		p.PrintArg()
	}
	p.SetState(1494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(1490)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1491)
			p.PrintArg()
		}

		p.SetState(1496)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrintArgContext is an interface to support dynamic dispatch.
type IPrintArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsPrintArgContext differentiates from other interfaces.
	IsPrintArgContext()
}

type PrintArgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrintArgContext() *PrintArgContext {
	var p = new(PrintArgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_printArg
	return p
}

func InitEmptyPrintArgContext(p *PrintArgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_printArg
}

func (*PrintArgContext) IsPrintArgContext() {}

func NewPrintArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrintArgContext {
	var p = new(PrintArgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_printArg

	return p
}

func (s *PrintArgContext) GetParser() antlr.Parser { return s.parser }

func (s *PrintArgContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrintArgContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *PrintArgContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrintArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrintArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterPrintArg(s)
	}
}

func (s *PrintArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitPrintArg(s)
	}
}

func (s *PrintArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitPrintArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) PrintArg() (localctx IPrintArgContext) {
	localctx = NewPrintArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, KQLParserRULE_printArg)
	p.SetState(1502)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 140, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1497)
			p.Identifier()
		}
		{
			p.SetState(1498)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1499)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1501)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OrExpression() IOrExpressionContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) OrExpression() IOrExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, KQLParserRULE_expression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1504)
		p.OrExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrExpressionContext is an interface to support dynamic dispatch.
type IOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAndExpression() []IAndExpressionContext
	AndExpression(i int) IAndExpressionContext
	AllOR() []antlr.TerminalNode
	OR(i int) antlr.TerminalNode

	// IsOrExpressionContext differentiates from other interfaces.
	IsOrExpressionContext()
}

type OrExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrExpressionContext() *OrExpressionContext {
	var p = new(OrExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_orExpression
	return p
}

func InitEmptyOrExpressionContext(p *OrExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_orExpression
}

func (*OrExpressionContext) IsOrExpressionContext() {}

func NewOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrExpressionContext {
	var p = new(OrExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_orExpression

	return p
}

func (s *OrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OrExpressionContext) AllAndExpression() []IAndExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAndExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAndExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAndExpressionContext); ok {
			tst[i] = t.(IAndExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OrExpressionContext) AndExpression(i int) IAndExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAndExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAndExpressionContext)
}

func (s *OrExpressionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(KQLParserOR)
}

func (s *OrExpressionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserOR, i)
}

func (s *OrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterOrExpression(s)
	}
}

func (s *OrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitOrExpression(s)
	}
}

func (s *OrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) OrExpression() (localctx IOrExpressionContext) {
	localctx = NewOrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, KQLParserRULE_orExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1506)
		p.AndExpression()
	}
	p.SetState(1511)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserOR {
		{
			p.SetState(1507)
			p.Match(KQLParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1508)
			p.AndExpression()
		}

		p.SetState(1513)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAndExpressionContext is an interface to support dynamic dispatch.
type IAndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNotExpression() []INotExpressionContext
	NotExpression(i int) INotExpressionContext
	AllAND() []antlr.TerminalNode
	AND(i int) antlr.TerminalNode

	// IsAndExpressionContext differentiates from other interfaces.
	IsAndExpressionContext()
}

type AndExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndExpressionContext() *AndExpressionContext {
	var p = new(AndExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_andExpression
	return p
}

func InitEmptyAndExpressionContext(p *AndExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_andExpression
}

func (*AndExpressionContext) IsAndExpressionContext() {}

func NewAndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndExpressionContext {
	var p = new(AndExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_andExpression

	return p
}

func (s *AndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AndExpressionContext) AllNotExpression() []INotExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INotExpressionContext); ok {
			len++
		}
	}

	tst := make([]INotExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INotExpressionContext); ok {
			tst[i] = t.(INotExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AndExpressionContext) NotExpression(i int) INotExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotExpressionContext)
}

func (s *AndExpressionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(KQLParserAND)
}

func (s *AndExpressionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserAND, i)
}

func (s *AndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterAndExpression(s)
	}
}

func (s *AndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitAndExpression(s)
	}
}

func (s *AndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) AndExpression() (localctx IAndExpressionContext) {
	localctx = NewAndExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, KQLParserRULE_andExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1514)
		p.NotExpression()
	}
	p.SetState(1519)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserAND {
		{
			p.SetState(1515)
			p.Match(KQLParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1516)
			p.NotExpression()
		}

		p.SetState(1521)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INotExpressionContext is an interface to support dynamic dispatch.
type INotExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOT() antlr.TerminalNode
	NotExpression() INotExpressionContext
	ComparisonExpression() IComparisonExpressionContext

	// IsNotExpressionContext differentiates from other interfaces.
	IsNotExpressionContext()
}

type NotExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotExpressionContext() *NotExpressionContext {
	var p = new(NotExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_notExpression
	return p
}

func InitEmptyNotExpressionContext(p *NotExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_notExpression
}

func (*NotExpressionContext) IsNotExpressionContext() {}

func NewNotExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotExpressionContext {
	var p = new(NotExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_notExpression

	return p
}

func (s *NotExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NotExpressionContext) NOT() antlr.TerminalNode {
	return s.GetToken(KQLParserNOT, 0)
}

func (s *NotExpressionContext) NotExpression() INotExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotExpressionContext)
}

func (s *NotExpressionContext) ComparisonExpression() IComparisonExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonExpressionContext)
}

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterNotExpression(s)
	}
}

func (s *NotExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitNotExpression(s)
	}
}

func (s *NotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) NotExpression() (localctx INotExpressionContext) {
	localctx = NewNotExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, KQLParserRULE_notExpression)
	p.SetState(1525)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KQLParserNOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1522)
			p.Match(KQLParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1523)
			p.NotExpression()
		}

	case KQLParserWHERE, KQLParserSEARCH, KQLParserTAKE, KQLParserDISTINCT, KQLParserCOUNT, KQLParserPROJECT, KQLParserEXTEND, KQLParserPARSE, KQLParserSORT, KQLParserTOP, KQLParserSUMMARIZE, KQLParserJOIN, KQLParserLOOKUP, KQLParserUNION, KQLParserAS, KQLParserEVALUATE, KQLParserRANGE, KQLParserPRINT, KQLParserRENDER, KQLParserLET, KQLParserSET, KQLParserKIND, KQLParserINNER, KQLParserOUTER, KQLParserLEFT, KQLParserRIGHT, KQLParserPLUS, KQLParserMINUS, KQLParserSTAR, KQLParserLPAREN, KQLParserLBRACKET, KQLParserLBRACE, KQLParserASC, KQLParserDESC, KQLParserBY, KQLParserON, KQLParserWITH, KQLParserOF, KQLParserTO, KQLParserFROM, KQLParserSTEP, KQLParserDEFAULT, KQLParserTYPEOF, KQLParserPACK, KQLParserPACK_ALL, KQLParserBAG_PACK, KQLParserCASE, KQLParserIFF, KQLParserIIF, KQLParserTOSCALAR, KQLParserPACK_ARRAY, KQLParserTRUE, KQLParserFALSE, KQLParserNULL, KQLParserDATETIME_LITERAL, KQLParserTIMESPAN_LITERAL, KQLParserTIMESPAN_SHORT, KQLParserDYNAMIC_LITERAL, KQLParserGUID_LITERAL, KQLParserTYPE_BOOL, KQLParserTYPE_DATETIME, KQLParserTYPE_DECIMAL, KQLParserTYPE_DOUBLE, KQLParserTYPE_DYNAMIC, KQLParserTYPE_GUID, KQLParserTYPE_INT, KQLParserTYPE_LONG, KQLParserTYPE_REAL, KQLParserTYPE_STRING, KQLParserTYPE_TIMESPAN, KQLParserSTRING_LITERAL, KQLParserVERBATIM_STRING, KQLParserMULTILINE_STRING, KQLParserHEX_NUMBER, KQLParserREAL_NUMBER, KQLParserLONG_NUMBER, KQLParserINT_NUMBER, KQLParserDECIMAL_NUMBER, KQLParserIDENTIFIER, KQLParserQUOTED_IDENTIFIER, KQLParserCLIENT_PARAMETER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1524)
			p.ComparisonExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonExpressionContext is an interface to support dynamic dispatch.
type IComparisonExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAdditiveExpression() []IAdditiveExpressionContext
	AdditiveExpression(i int) IAdditiveExpressionContext
	ComparisonOperator() IComparisonOperatorContext
	BETWEEN() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	DOTDOT() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	NOT_BETWEEN() antlr.TerminalNode
	IN() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	TableName() ITableNameContext
	NOT_IN() antlr.TerminalNode
	HAS_ANY() antlr.TerminalNode
	HAS_ALL() antlr.TerminalNode
	StringOperator() IStringOperatorContext

	// IsComparisonExpressionContext differentiates from other interfaces.
	IsComparisonExpressionContext()
}

type ComparisonExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonExpressionContext() *ComparisonExpressionContext {
	var p = new(ComparisonExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_comparisonExpression
	return p
}

func InitEmptyComparisonExpressionContext(p *ComparisonExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_comparisonExpression
}

func (*ComparisonExpressionContext) IsComparisonExpressionContext() {}

func NewComparisonExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonExpressionContext {
	var p = new(ComparisonExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_comparisonExpression

	return p
}

func (s *ComparisonExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonExpressionContext) AllAdditiveExpression() []IAdditiveExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAdditiveExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAdditiveExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAdditiveExpressionContext); ok {
			tst[i] = t.(IAdditiveExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonExpressionContext) AdditiveExpression(i int) IAdditiveExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExpressionContext)
}

func (s *ComparisonExpressionContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonExpressionContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(KQLParserBETWEEN, 0)
}

func (s *ComparisonExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *ComparisonExpressionContext) DOTDOT() antlr.TerminalNode {
	return s.GetToken(KQLParserDOTDOT, 0)
}

func (s *ComparisonExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *ComparisonExpressionContext) NOT_BETWEEN() antlr.TerminalNode {
	return s.GetToken(KQLParserNOT_BETWEEN, 0)
}

func (s *ComparisonExpressionContext) IN() antlr.TerminalNode {
	return s.GetToken(KQLParserIN, 0)
}

func (s *ComparisonExpressionContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ComparisonExpressionContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *ComparisonExpressionContext) NOT_IN() antlr.TerminalNode {
	return s.GetToken(KQLParserNOT_IN, 0)
}

func (s *ComparisonExpressionContext) HAS_ANY() antlr.TerminalNode {
	return s.GetToken(KQLParserHAS_ANY, 0)
}

func (s *ComparisonExpressionContext) HAS_ALL() antlr.TerminalNode {
	return s.GetToken(KQLParserHAS_ALL, 0)
}

func (s *ComparisonExpressionContext) StringOperator() IStringOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringOperatorContext)
}

func (s *ComparisonExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterComparisonExpression(s)
	}
}

func (s *ComparisonExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitComparisonExpression(s)
	}
}

func (s *ComparisonExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitComparisonExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ComparisonExpression() (localctx IComparisonExpressionContext) {
	localctx = NewComparisonExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, KQLParserRULE_comparisonExpression)
	p.SetState(1580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1527)
			p.AdditiveExpression()
		}
		{
			p.SetState(1528)
			p.ComparisonOperator()
		}
		{
			p.SetState(1529)
			p.AdditiveExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1531)
			p.AdditiveExpression()
		}
		{
			p.SetState(1532)
			p.Match(KQLParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1533)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1534)
			p.AdditiveExpression()
		}
		{
			p.SetState(1535)
			p.Match(KQLParserDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1536)
			p.AdditiveExpression()
		}
		{
			p.SetState(1537)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1539)
			p.AdditiveExpression()
		}
		{
			p.SetState(1540)
			p.Match(KQLParserNOT_BETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1541)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1542)
			p.AdditiveExpression()
		}
		{
			p.SetState(1543)
			p.Match(KQLParserDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1544)
			p.AdditiveExpression()
		}
		{
			p.SetState(1545)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1547)
			p.AdditiveExpression()
		}
		{
			p.SetState(1548)
			p.Match(KQLParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1549)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1550)
			p.ExpressionList()
		}
		{
			p.SetState(1551)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1553)
			p.AdditiveExpression()
		}
		{
			p.SetState(1554)
			p.Match(KQLParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1555)
			p.TableName()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1557)
			p.AdditiveExpression()
		}
		{
			p.SetState(1558)
			p.Match(KQLParserNOT_IN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1559)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1560)
			p.ExpressionList()
		}
		{
			p.SetState(1561)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1563)
			p.AdditiveExpression()
		}
		{
			p.SetState(1564)
			p.Match(KQLParserHAS_ANY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1565)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1566)
			p.ExpressionList()
		}
		{
			p.SetState(1567)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1569)
			p.AdditiveExpression()
		}
		{
			p.SetState(1570)
			p.Match(KQLParserHAS_ALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1571)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1572)
			p.ExpressionList()
		}
		{
			p.SetState(1573)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1575)
			p.AdditiveExpression()
		}
		{
			p.SetState(1576)
			p.StringOperator()
		}
		{
			p.SetState(1577)
			p.AdditiveExpression()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1579)
			p.AdditiveExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	NEQ() antlr.TerminalNode
	LT() antlr.TerminalNode
	GT() antlr.TerminalNode
	LTE() antlr.TerminalNode
	GTE() antlr.TerminalNode
	EQTILDE() antlr.TerminalNode
	NEQTILDE() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(KQLParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(KQLParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(KQLParserLT, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(KQLParserGT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(KQLParserLTE, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(KQLParserGTE, 0)
}

func (s *ComparisonOperatorContext) EQTILDE() antlr.TerminalNode {
	return s.GetToken(KQLParserEQTILDE, 0)
}

func (s *ComparisonOperatorContext) NEQTILDE() antlr.TerminalNode {
	return s.GetToken(KQLParserNEQTILDE, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitComparisonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, KQLParserRULE_comparisonOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1582)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-113)) & ^0x3f) == 0 && ((int64(1)<<(_la-113))&509) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringOperatorContext is an interface to support dynamic dispatch.
type IStringOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONTAINS() antlr.TerminalNode
	NOT_CONTAINS() antlr.TerminalNode
	CONTAINS_CS() antlr.TerminalNode
	NOT_CONTAINS_CS() antlr.TerminalNode
	HAS() antlr.TerminalNode
	NOT_HAS() antlr.TerminalNode
	HAS_CS() antlr.TerminalNode
	NOT_HAS_CS() antlr.TerminalNode
	HASPREFIX() antlr.TerminalNode
	NOT_HASPREFIX() antlr.TerminalNode
	HASPREFIX_CS() antlr.TerminalNode
	NOT_HASPREFIX_CS() antlr.TerminalNode
	HASSUFFIX() antlr.TerminalNode
	NOT_HASSUFFIX() antlr.TerminalNode
	HASSUFFIX_CS() antlr.TerminalNode
	NOT_HASSUFFIX_CS() antlr.TerminalNode
	STARTSWITH() antlr.TerminalNode
	NOT_STARTSWITH() antlr.TerminalNode
	STARTSWITH_CS() antlr.TerminalNode
	NOT_STARTSWITH_CS() antlr.TerminalNode
	ENDSWITH() antlr.TerminalNode
	NOT_ENDSWITH() antlr.TerminalNode
	ENDSWITH_CS() antlr.TerminalNode
	NOT_ENDSWITH_CS() antlr.TerminalNode
	MATCHES_REGEX() antlr.TerminalNode
	MATCHES() antlr.TerminalNode

	// IsStringOperatorContext differentiates from other interfaces.
	IsStringOperatorContext()
}

type StringOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringOperatorContext() *StringOperatorContext {
	var p = new(StringOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_stringOperator
	return p
}

func InitEmptyStringOperatorContext(p *StringOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_stringOperator
}

func (*StringOperatorContext) IsStringOperatorContext() {}

func NewStringOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringOperatorContext {
	var p = new(StringOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_stringOperator

	return p
}

func (s *StringOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *StringOperatorContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(KQLParserCONTAINS, 0)
}

func (s *StringOperatorContext) NOT_CONTAINS() antlr.TerminalNode {
	return s.GetToken(KQLParserNOT_CONTAINS, 0)
}

func (s *StringOperatorContext) CONTAINS_CS() antlr.TerminalNode {
	return s.GetToken(KQLParserCONTAINS_CS, 0)
}

func (s *StringOperatorContext) NOT_CONTAINS_CS() antlr.TerminalNode {
	return s.GetToken(KQLParserNOT_CONTAINS_CS, 0)
}

func (s *StringOperatorContext) HAS() antlr.TerminalNode {
	return s.GetToken(KQLParserHAS, 0)
}

func (s *StringOperatorContext) NOT_HAS() antlr.TerminalNode {
	return s.GetToken(KQLParserNOT_HAS, 0)
}

func (s *StringOperatorContext) HAS_CS() antlr.TerminalNode {
	return s.GetToken(KQLParserHAS_CS, 0)
}

func (s *StringOperatorContext) NOT_HAS_CS() antlr.TerminalNode {
	return s.GetToken(KQLParserNOT_HAS_CS, 0)
}

func (s *StringOperatorContext) HASPREFIX() antlr.TerminalNode {
	return s.GetToken(KQLParserHASPREFIX, 0)
}

func (s *StringOperatorContext) NOT_HASPREFIX() antlr.TerminalNode {
	return s.GetToken(KQLParserNOT_HASPREFIX, 0)
}

func (s *StringOperatorContext) HASPREFIX_CS() antlr.TerminalNode {
	return s.GetToken(KQLParserHASPREFIX_CS, 0)
}

func (s *StringOperatorContext) NOT_HASPREFIX_CS() antlr.TerminalNode {
	return s.GetToken(KQLParserNOT_HASPREFIX_CS, 0)
}

func (s *StringOperatorContext) HASSUFFIX() antlr.TerminalNode {
	return s.GetToken(KQLParserHASSUFFIX, 0)
}

func (s *StringOperatorContext) NOT_HASSUFFIX() antlr.TerminalNode {
	return s.GetToken(KQLParserNOT_HASSUFFIX, 0)
}

func (s *StringOperatorContext) HASSUFFIX_CS() antlr.TerminalNode {
	return s.GetToken(KQLParserHASSUFFIX_CS, 0)
}

func (s *StringOperatorContext) NOT_HASSUFFIX_CS() antlr.TerminalNode {
	return s.GetToken(KQLParserNOT_HASSUFFIX_CS, 0)
}

func (s *StringOperatorContext) STARTSWITH() antlr.TerminalNode {
	return s.GetToken(KQLParserSTARTSWITH, 0)
}

func (s *StringOperatorContext) NOT_STARTSWITH() antlr.TerminalNode {
	return s.GetToken(KQLParserNOT_STARTSWITH, 0)
}

func (s *StringOperatorContext) STARTSWITH_CS() antlr.TerminalNode {
	return s.GetToken(KQLParserSTARTSWITH_CS, 0)
}

func (s *StringOperatorContext) NOT_STARTSWITH_CS() antlr.TerminalNode {
	return s.GetToken(KQLParserNOT_STARTSWITH_CS, 0)
}

func (s *StringOperatorContext) ENDSWITH() antlr.TerminalNode {
	return s.GetToken(KQLParserENDSWITH, 0)
}

func (s *StringOperatorContext) NOT_ENDSWITH() antlr.TerminalNode {
	return s.GetToken(KQLParserNOT_ENDSWITH, 0)
}

func (s *StringOperatorContext) ENDSWITH_CS() antlr.TerminalNode {
	return s.GetToken(KQLParserENDSWITH_CS, 0)
}

func (s *StringOperatorContext) NOT_ENDSWITH_CS() antlr.TerminalNode {
	return s.GetToken(KQLParserNOT_ENDSWITH_CS, 0)
}

func (s *StringOperatorContext) MATCHES_REGEX() antlr.TerminalNode {
	return s.GetToken(KQLParserMATCHES_REGEX, 0)
}

func (s *StringOperatorContext) MATCHES() antlr.TerminalNode {
	return s.GetToken(KQLParserMATCHES, 0)
}

func (s *StringOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterStringOperator(s)
	}
}

func (s *StringOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitStringOperator(s)
	}
}

func (s *StringOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitStringOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) StringOperator() (localctx IStringOperatorContext) {
	localctx = NewStringOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, KQLParserRULE_stringOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1584)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-87)) & ^0x3f) == 0 && ((int64(1)<<(_la-87))&67108863) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveExpressionContext is an interface to support dynamic dispatch.
type IAdditiveExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMultiplicativeExpression() []IMultiplicativeExpressionContext
	MultiplicativeExpression(i int) IMultiplicativeExpressionContext
	AllPLUS() []antlr.TerminalNode
	PLUS(i int) antlr.TerminalNode
	AllMINUS() []antlr.TerminalNode
	MINUS(i int) antlr.TerminalNode

	// IsAdditiveExpressionContext differentiates from other interfaces.
	IsAdditiveExpressionContext()
}

type AdditiveExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveExpressionContext() *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_additiveExpression
	return p
}

func InitEmptyAdditiveExpressionContext(p *AdditiveExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_additiveExpression
}

func (*AdditiveExpressionContext) IsAdditiveExpressionContext() {}

func NewAdditiveExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_additiveExpression

	return p
}

func (s *AdditiveExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExpressionContext) AllMultiplicativeExpression() []IMultiplicativeExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiplicativeExpressionContext); ok {
			len++
		}
	}

	tst := make([]IMultiplicativeExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiplicativeExpressionContext); ok {
			tst[i] = t.(IMultiplicativeExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) MultiplicativeExpression(i int) IMultiplicativeExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExpressionContext)
}

func (s *AdditiveExpressionContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(KQLParserPLUS)
}

func (s *AdditiveExpressionContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserPLUS, i)
}

func (s *AdditiveExpressionContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(KQLParserMINUS)
}

func (s *AdditiveExpressionContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserMINUS, i)
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitAdditiveExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) AdditiveExpression() (localctx IAdditiveExpressionContext) {
	localctx = NewAdditiveExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, KQLParserRULE_additiveExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1586)
		p.MultiplicativeExpression()
	}
	p.SetState(1591)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1587)
				_la = p.GetTokenStream().LA(1)

				if !(_la == KQLParserPLUS || _la == KQLParserMINUS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1588)
				p.MultiplicativeExpression()
			}

		}
		p.SetState(1593)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeExpressionContext is an interface to support dynamic dispatch.
type IMultiplicativeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUnaryExpression() []IUnaryExpressionContext
	UnaryExpression(i int) IUnaryExpressionContext
	AllSTAR() []antlr.TerminalNode
	STAR(i int) antlr.TerminalNode
	AllSLASH() []antlr.TerminalNode
	SLASH(i int) antlr.TerminalNode
	AllPERCENT() []antlr.TerminalNode
	PERCENT(i int) antlr.TerminalNode

	// IsMultiplicativeExpressionContext differentiates from other interfaces.
	IsMultiplicativeExpressionContext()
}

type MultiplicativeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeExpressionContext() *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_multiplicativeExpression
	return p
}

func InitEmptyMultiplicativeExpressionContext(p *MultiplicativeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_multiplicativeExpression
}

func (*MultiplicativeExpressionContext) IsMultiplicativeExpressionContext() {}

func NewMultiplicativeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_multiplicativeExpression

	return p
}

func (s *MultiplicativeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExpressionContext) AllUnaryExpression() []IUnaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IUnaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnaryExpressionContext); ok {
			tst[i] = t.(IUnaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) UnaryExpression(i int) IUnaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *MultiplicativeExpressionContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(KQLParserSTAR)
}

func (s *MultiplicativeExpressionContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserSTAR, i)
}

func (s *MultiplicativeExpressionContext) AllSLASH() []antlr.TerminalNode {
	return s.GetTokens(KQLParserSLASH)
}

func (s *MultiplicativeExpressionContext) SLASH(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserSLASH, i)
}

func (s *MultiplicativeExpressionContext) AllPERCENT() []antlr.TerminalNode {
	return s.GetTokens(KQLParserPERCENT)
}

func (s *MultiplicativeExpressionContext) PERCENT(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserPERCENT, i)
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitMultiplicativeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) MultiplicativeExpression() (localctx IMultiplicativeExpressionContext) {
	localctx = NewMultiplicativeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, KQLParserRULE_multiplicativeExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1594)
		p.UnaryExpression()
	}
	p.SetState(1599)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1595)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-124)) & ^0x3f) == 0 && ((int64(1)<<(_la-124))&7) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1596)
				p.UnaryExpression()
			}

		}
		p.SetState(1601)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryExpressionContext is an interface to support dynamic dispatch.
type IUnaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MINUS() antlr.TerminalNode
	UnaryExpression() IUnaryExpressionContext
	PLUS() antlr.TerminalNode
	PostfixExpression() IPostfixExpressionContext

	// IsUnaryExpressionContext differentiates from other interfaces.
	IsUnaryExpressionContext()
}

type UnaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExpressionContext() *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_unaryExpression
	return p
}

func InitEmptyUnaryExpressionContext(p *UnaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_unaryExpression
}

func (*UnaryExpressionContext) IsUnaryExpressionContext() {}

func NewUnaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_unaryExpression

	return p
}

func (s *UnaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExpressionContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KQLParserMINUS, 0)
}

func (s *UnaryExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *UnaryExpressionContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KQLParserPLUS, 0)
}

func (s *UnaryExpressionContext) PostfixExpression() IPostfixExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *UnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterUnaryExpression(s)
	}
}

func (s *UnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitUnaryExpression(s)
	}
}

func (s *UnaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitUnaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) UnaryExpression() (localctx IUnaryExpressionContext) {
	localctx = NewUnaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, KQLParserRULE_unaryExpression)
	p.SetState(1607)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KQLParserMINUS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1602)
			p.Match(KQLParserMINUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1603)
			p.UnaryExpression()
		}

	case KQLParserPLUS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1604)
			p.Match(KQLParserPLUS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1605)
			p.UnaryExpression()
		}

	case KQLParserWHERE, KQLParserSEARCH, KQLParserTAKE, KQLParserDISTINCT, KQLParserCOUNT, KQLParserPROJECT, KQLParserEXTEND, KQLParserPARSE, KQLParserSORT, KQLParserTOP, KQLParserSUMMARIZE, KQLParserJOIN, KQLParserLOOKUP, KQLParserUNION, KQLParserAS, KQLParserEVALUATE, KQLParserRANGE, KQLParserPRINT, KQLParserRENDER, KQLParserLET, KQLParserSET, KQLParserKIND, KQLParserINNER, KQLParserOUTER, KQLParserLEFT, KQLParserRIGHT, KQLParserSTAR, KQLParserLPAREN, KQLParserLBRACKET, KQLParserLBRACE, KQLParserASC, KQLParserDESC, KQLParserBY, KQLParserON, KQLParserWITH, KQLParserOF, KQLParserTO, KQLParserFROM, KQLParserSTEP, KQLParserDEFAULT, KQLParserTYPEOF, KQLParserPACK, KQLParserPACK_ALL, KQLParserBAG_PACK, KQLParserCASE, KQLParserIFF, KQLParserIIF, KQLParserTOSCALAR, KQLParserPACK_ARRAY, KQLParserTRUE, KQLParserFALSE, KQLParserNULL, KQLParserDATETIME_LITERAL, KQLParserTIMESPAN_LITERAL, KQLParserTIMESPAN_SHORT, KQLParserDYNAMIC_LITERAL, KQLParserGUID_LITERAL, KQLParserTYPE_BOOL, KQLParserTYPE_DATETIME, KQLParserTYPE_DECIMAL, KQLParserTYPE_DOUBLE, KQLParserTYPE_DYNAMIC, KQLParserTYPE_GUID, KQLParserTYPE_INT, KQLParserTYPE_LONG, KQLParserTYPE_REAL, KQLParserTYPE_STRING, KQLParserTYPE_TIMESPAN, KQLParserSTRING_LITERAL, KQLParserVERBATIM_STRING, KQLParserMULTILINE_STRING, KQLParserHEX_NUMBER, KQLParserREAL_NUMBER, KQLParserLONG_NUMBER, KQLParserINT_NUMBER, KQLParserDECIMAL_NUMBER, KQLParserIDENTIFIER, KQLParserQUOTED_IDENTIFIER, KQLParserCLIENT_PARAMETER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1606)
			p.PostfixExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixExpressionContext is an interface to support dynamic dispatch.
type IPostfixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpression() IPrimaryExpressionContext
	AllPostfixOperator() []IPostfixOperatorContext
	PostfixOperator(i int) IPostfixOperatorContext

	// IsPostfixExpressionContext differentiates from other interfaces.
	IsPostfixExpressionContext()
}

type PostfixExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExpressionContext() *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_postfixExpression
	return p
}

func InitEmptyPostfixExpressionContext(p *PostfixExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_postfixExpression
}

func (*PostfixExpressionContext) IsPostfixExpressionContext() {}

func NewPostfixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_postfixExpression

	return p
}

func (s *PostfixExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PostfixExpressionContext) AllPostfixOperator() []IPostfixOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPostfixOperatorContext); ok {
			len++
		}
	}

	tst := make([]IPostfixOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPostfixOperatorContext); ok {
			tst[i] = t.(IPostfixOperatorContext)
			i++
		}
	}

	return tst
}

func (s *PostfixExpressionContext) PostfixOperator(i int) IPostfixOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixOperatorContext)
}

func (s *PostfixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterPostfixExpression(s)
	}
}

func (s *PostfixExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitPostfixExpression(s)
	}
}

func (s *PostfixExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitPostfixExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) PostfixExpression() (localctx IPostfixExpressionContext) {
	localctx = NewPostfixExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, KQLParserRULE_postfixExpression)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1609)
		p.PrimaryExpression()
	}
	p.SetState(1613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1610)
				p.PostfixOperator()
			}

		}
		p.SetState(1615)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 148, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixOperatorContext is an interface to support dynamic dispatch.
type IPostfixOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT() antlr.TerminalNode
	Identifier() IIdentifierContext
	FunctionCall() IFunctionCallContext
	LBRACKET() antlr.TerminalNode
	Expression() IExpressionContext
	RBRACKET() antlr.TerminalNode
	QUESTIONDOT() antlr.TerminalNode

	// IsPostfixOperatorContext differentiates from other interfaces.
	IsPostfixOperatorContext()
}

type PostfixOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixOperatorContext() *PostfixOperatorContext {
	var p = new(PostfixOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_postfixOperator
	return p
}

func InitEmptyPostfixOperatorContext(p *PostfixOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_postfixOperator
}

func (*PostfixOperatorContext) IsPostfixOperatorContext() {}

func NewPostfixOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixOperatorContext {
	var p = new(PostfixOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_postfixOperator

	return p
}

func (s *PostfixOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixOperatorContext) DOT() antlr.TerminalNode {
	return s.GetToken(KQLParserDOT, 0)
}

func (s *PostfixOperatorContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PostfixOperatorContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PostfixOperatorContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(KQLParserLBRACKET, 0)
}

func (s *PostfixOperatorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PostfixOperatorContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(KQLParserRBRACKET, 0)
}

func (s *PostfixOperatorContext) QUESTIONDOT() antlr.TerminalNode {
	return s.GetToken(KQLParserQUESTIONDOT, 0)
}

func (s *PostfixOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterPostfixOperator(s)
	}
}

func (s *PostfixOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitPostfixOperator(s)
	}
}

func (s *PostfixOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitPostfixOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) PostfixOperator() (localctx IPostfixOperatorContext) {
	localctx = NewPostfixOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, KQLParserRULE_postfixOperator)
	p.SetState(1626)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 149, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1616)
			p.Match(KQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1617)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1618)
			p.Match(KQLParserDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1619)
			p.FunctionCall()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1620)
			p.Match(KQLParserLBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1621)
			p.Expression()
		}
		{
			p.SetState(1622)
			p.Match(KQLParserRBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1624)
			p.Match(KQLParserQUESTIONDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1625)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	Identifier() IIdentifierContext
	QUOTED_IDENTIFIER() antlr.TerminalNode
	CLIENT_PARAMETER() antlr.TerminalNode
	FunctionCall() IFunctionCallContext
	LPAREN() antlr.TerminalNode
	Expression() IExpressionContext
	RPAREN() antlr.TerminalNode
	TabularExpression() ITabularExpressionContext
	CaseExpression() ICaseExpressionContext
	IffExpression() IIffExpressionContext
	ToScalarExpression() IToScalarExpressionContext
	ArrayExpression() IArrayExpressionContext
	ObjectExpression() IObjectExpressionContext
	STAR() antlr.TerminalNode

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrimaryExpressionContext) QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KQLParserQUOTED_IDENTIFIER, 0)
}

func (s *PrimaryExpressionContext) CLIENT_PARAMETER() antlr.TerminalNode {
	return s.GetToken(KQLParserCLIENT_PARAMETER, 0)
}

func (s *PrimaryExpressionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PrimaryExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *PrimaryExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *PrimaryExpressionContext) TabularExpression() ITabularExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabularExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabularExpressionContext)
}

func (s *PrimaryExpressionContext) CaseExpression() ICaseExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseExpressionContext)
}

func (s *PrimaryExpressionContext) IffExpression() IIffExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIffExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIffExpressionContext)
}

func (s *PrimaryExpressionContext) ToScalarExpression() IToScalarExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IToScalarExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IToScalarExpressionContext)
}

func (s *PrimaryExpressionContext) ArrayExpression() IArrayExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayExpressionContext)
}

func (s *PrimaryExpressionContext) ObjectExpression() IObjectExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectExpressionContext)
}

func (s *PrimaryExpressionContext) STAR() antlr.TerminalNode {
	return s.GetToken(KQLParserSTAR, 0)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitPrimaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, KQLParserRULE_primaryExpression)
	p.SetState(1647)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 150, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1628)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1629)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1630)
			p.Match(KQLParserQUOTED_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1631)
			p.Match(KQLParserCLIENT_PARAMETER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1632)
			p.FunctionCall()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1633)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1634)
			p.Expression()
		}
		{
			p.SetState(1635)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1637)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1638)
			p.TabularExpression()
		}
		{
			p.SetState(1639)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1641)
			p.CaseExpression()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1642)
			p.IffExpression()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1643)
			p.ToScalarExpression()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1644)
			p.ArrayExpression()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1645)
			p.ObjectExpression()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1646)
			p.Match(KQLParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ArgumentList() IArgumentListContext
	BuiltinFunction() IBuiltinFunctionContext

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_functionCall
	return p
}

func InitEmptyFunctionCallContext(p *FunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_functionCall
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionCallContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *FunctionCallContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *FunctionCallContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *FunctionCallContext) BuiltinFunction() IBuiltinFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBuiltinFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBuiltinFunctionContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (s *FunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, KQLParserRULE_functionCall)
	var _la int

	p.SetState(1657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KQLParserWHERE, KQLParserSEARCH, KQLParserTAKE, KQLParserDISTINCT, KQLParserCOUNT, KQLParserPROJECT, KQLParserEXTEND, KQLParserPARSE, KQLParserSORT, KQLParserTOP, KQLParserSUMMARIZE, KQLParserJOIN, KQLParserLOOKUP, KQLParserUNION, KQLParserAS, KQLParserEVALUATE, KQLParserRANGE, KQLParserPRINT, KQLParserRENDER, KQLParserLET, KQLParserSET, KQLParserKIND, KQLParserINNER, KQLParserOUTER, KQLParserLEFT, KQLParserRIGHT, KQLParserASC, KQLParserDESC, KQLParserBY, KQLParserON, KQLParserWITH, KQLParserOF, KQLParserTO, KQLParserFROM, KQLParserSTEP, KQLParserDEFAULT, KQLParserTRUE, KQLParserFALSE, KQLParserTYPE_BOOL, KQLParserTYPE_DATETIME, KQLParserTYPE_DECIMAL, KQLParserTYPE_DOUBLE, KQLParserTYPE_DYNAMIC, KQLParserTYPE_GUID, KQLParserTYPE_INT, KQLParserTYPE_LONG, KQLParserTYPE_REAL, KQLParserTYPE_STRING, KQLParserTYPE_TIMESPAN, KQLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1649)
			p.Identifier()
		}
		{
			p.SetState(1650)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1652)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1722596028691838186) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2017612633061998593) != 0) || ((int64((_la-136)) & ^0x3f) == 0 && ((int64(1)<<(_la-136))&-137430566699) != 0) || ((int64((_la-200)) & ^0x3f) == 0 && ((int64(1)<<(_la-200))&255) != 0) {
			{
				p.SetState(1651)
				p.ArgumentList()
			}

		}
		{
			p.SetState(1654)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserTYPEOF, KQLParserPACK, KQLParserPACK_ALL, KQLParserBAG_PACK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1656)
			p.BuiltinFunction()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBuiltinFunctionContext is an interface to support dynamic dispatch.
type IBuiltinFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPEOF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	TypeSpecifier() ITypeSpecifierContext
	RPAREN() antlr.TerminalNode
	PACK() antlr.TerminalNode
	ArgumentList() IArgumentListContext
	PACK_ALL() antlr.TerminalNode
	BAG_PACK() antlr.TerminalNode

	// IsBuiltinFunctionContext differentiates from other interfaces.
	IsBuiltinFunctionContext()
}

type BuiltinFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBuiltinFunctionContext() *BuiltinFunctionContext {
	var p = new(BuiltinFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_builtinFunction
	return p
}

func InitEmptyBuiltinFunctionContext(p *BuiltinFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_builtinFunction
}

func (*BuiltinFunctionContext) IsBuiltinFunctionContext() {}

func NewBuiltinFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BuiltinFunctionContext {
	var p = new(BuiltinFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_builtinFunction

	return p
}

func (s *BuiltinFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *BuiltinFunctionContext) TYPEOF() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPEOF, 0)
}

func (s *BuiltinFunctionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *BuiltinFunctionContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *BuiltinFunctionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *BuiltinFunctionContext) PACK() antlr.TerminalNode {
	return s.GetToken(KQLParserPACK, 0)
}

func (s *BuiltinFunctionContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *BuiltinFunctionContext) PACK_ALL() antlr.TerminalNode {
	return s.GetToken(KQLParserPACK_ALL, 0)
}

func (s *BuiltinFunctionContext) BAG_PACK() antlr.TerminalNode {
	return s.GetToken(KQLParserBAG_PACK, 0)
}

func (s *BuiltinFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BuiltinFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BuiltinFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterBuiltinFunction(s)
	}
}

func (s *BuiltinFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitBuiltinFunction(s)
	}
}

func (s *BuiltinFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitBuiltinFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) BuiltinFunction() (localctx IBuiltinFunctionContext) {
	localctx = NewBuiltinFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, KQLParserRULE_builtinFunction)
	var _la int

	p.SetState(1680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KQLParserTYPEOF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1659)
			p.Match(KQLParserTYPEOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1660)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1661)
			p.TypeSpecifier()
		}
		{
			p.SetState(1662)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserPACK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1664)
			p.Match(KQLParserPACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1665)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1666)
			p.ArgumentList()
		}
		{
			p.SetState(1667)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserPACK_ALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1669)
			p.Match(KQLParserPACK_ALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1670)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1672)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1722596028691838186) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2017612633061998593) != 0) || ((int64((_la-136)) & ^0x3f) == 0 && ((int64(1)<<(_la-136))&-137430566699) != 0) || ((int64((_la-200)) & ^0x3f) == 0 && ((int64(1)<<(_la-200))&255) != 0) {
			{
				p.SetState(1671)
				p.ArgumentList()
			}

		}
		{
			p.SetState(1674)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserBAG_PACK:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1675)
			p.Match(KQLParserBAG_PACK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1676)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1677)
			p.ArgumentList()
		}
		{
			p.SetState(1678)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllArgument() []IArgumentContext
	Argument(i int) IArgumentContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_argumentList
	return p
}

func InitEmptyArgumentListContext(p *ArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_argumentList
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) AllArgument() []IArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentContext); ok {
			len++
		}
	}

	tst := make([]IArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentContext); ok {
			tst[i] = t.(IArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentListContext) Argument(i int) IArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArgumentListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *ArgumentListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (s *ArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, KQLParserRULE_argumentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1682)
		p.Argument()
	}
	p.SetState(1687)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(1683)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1684)
			p.Argument()
		}

		p.SetState(1689)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Identifier() IIdentifierContext
	ASSIGN() antlr.TerminalNode
	STAR() antlr.TerminalNode

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_argument
	return p
}

func InitEmptyArgumentContext(p *ArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_argument
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArgumentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ArgumentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *ArgumentContext) STAR() antlr.TerminalNode {
	return s.GetToken(KQLParserSTAR, 0)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitArgument(s)
	}
}

func (s *ArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, KQLParserRULE_argument)
	p.SetState(1696)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 156, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1690)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1691)
			p.Identifier()
		}
		{
			p.SetState(1692)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1693)
			p.Expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1695)
			p.Match(KQLParserSTAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseExpressionContext is an interface to support dynamic dispatch.
type ICaseExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CASE() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllCaseBranch() []ICaseBranchContext
	CaseBranch(i int) ICaseBranchContext
	RPAREN() antlr.TerminalNode
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	Expression() IExpressionContext

	// IsCaseExpressionContext differentiates from other interfaces.
	IsCaseExpressionContext()
}

type CaseExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseExpressionContext() *CaseExpressionContext {
	var p = new(CaseExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_caseExpression
	return p
}

func InitEmptyCaseExpressionContext(p *CaseExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_caseExpression
}

func (*CaseExpressionContext) IsCaseExpressionContext() {}

func NewCaseExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseExpressionContext {
	var p = new(CaseExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_caseExpression

	return p
}

func (s *CaseExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseExpressionContext) CASE() antlr.TerminalNode {
	return s.GetToken(KQLParserCASE, 0)
}

func (s *CaseExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *CaseExpressionContext) AllCaseBranch() []ICaseBranchContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseBranchContext); ok {
			len++
		}
	}

	tst := make([]ICaseBranchContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseBranchContext); ok {
			tst[i] = t.(ICaseBranchContext)
			i++
		}
	}

	return tst
}

func (s *CaseExpressionContext) CaseBranch(i int) ICaseBranchContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseBranchContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseBranchContext)
}

func (s *CaseExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *CaseExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *CaseExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *CaseExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterCaseExpression(s)
	}
}

func (s *CaseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitCaseExpression(s)
	}
}

func (s *CaseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitCaseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) CaseExpression() (localctx ICaseExpressionContext) {
	localctx = NewCaseExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, KQLParserRULE_caseExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1698)
		p.Match(KQLParserCASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1699)
		p.Match(KQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1700)
		p.CaseBranch()
	}
	p.SetState(1705)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 157, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1701)
				p.Match(KQLParserCOMMA)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1702)
				p.CaseBranch()
			}

		}
		p.SetState(1707)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 157, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1710)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserCOMMA {
		{
			p.SetState(1708)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1709)
			p.Expression()
		}

	}
	{
		p.SetState(1712)
		p.Match(KQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaseBranchContext is an interface to support dynamic dispatch.
type ICaseBranchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	COMMA() antlr.TerminalNode

	// IsCaseBranchContext differentiates from other interfaces.
	IsCaseBranchContext()
}

type CaseBranchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseBranchContext() *CaseBranchContext {
	var p = new(CaseBranchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_caseBranch
	return p
}

func InitEmptyCaseBranchContext(p *CaseBranchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_caseBranch
}

func (*CaseBranchContext) IsCaseBranchContext() {}

func NewCaseBranchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseBranchContext {
	var p = new(CaseBranchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_caseBranch

	return p
}

func (s *CaseBranchContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseBranchContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CaseBranchContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseBranchContext) COMMA() antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, 0)
}

func (s *CaseBranchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseBranchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaseBranchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterCaseBranch(s)
	}
}

func (s *CaseBranchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitCaseBranch(s)
	}
}

func (s *CaseBranchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitCaseBranch(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) CaseBranch() (localctx ICaseBranchContext) {
	localctx = NewCaseBranchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, KQLParserRULE_caseBranch)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1714)
		p.Expression()
	}
	{
		p.SetState(1715)
		p.Match(KQLParserCOMMA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1716)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIffExpressionContext is an interface to support dynamic dispatch.
type IIffExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IFF() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	IIF() antlr.TerminalNode

	// IsIffExpressionContext differentiates from other interfaces.
	IsIffExpressionContext()
}

type IffExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIffExpressionContext() *IffExpressionContext {
	var p = new(IffExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_iffExpression
	return p
}

func InitEmptyIffExpressionContext(p *IffExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_iffExpression
}

func (*IffExpressionContext) IsIffExpressionContext() {}

func NewIffExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IffExpressionContext {
	var p = new(IffExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_iffExpression

	return p
}

func (s *IffExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *IffExpressionContext) IFF() antlr.TerminalNode {
	return s.GetToken(KQLParserIFF, 0)
}

func (s *IffExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *IffExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *IffExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IffExpressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *IffExpressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *IffExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *IffExpressionContext) IIF() antlr.TerminalNode {
	return s.GetToken(KQLParserIIF, 0)
}

func (s *IffExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IffExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IffExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterIffExpression(s)
	}
}

func (s *IffExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitIffExpression(s)
	}
}

func (s *IffExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitIffExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) IffExpression() (localctx IIffExpressionContext) {
	localctx = NewIffExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, KQLParserRULE_iffExpression)
	p.SetState(1736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KQLParserIFF:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1718)
			p.Match(KQLParserIFF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1719)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1720)
			p.Expression()
		}
		{
			p.SetState(1721)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1722)
			p.Expression()
		}
		{
			p.SetState(1723)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1724)
			p.Expression()
		}
		{
			p.SetState(1725)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserIIF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1727)
			p.Match(KQLParserIIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1728)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1729)
			p.Expression()
		}
		{
			p.SetState(1730)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1731)
			p.Expression()
		}
		{
			p.SetState(1732)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1733)
			p.Expression()
		}
		{
			p.SetState(1734)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IToScalarExpressionContext is an interface to support dynamic dispatch.
type IToScalarExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TOSCALAR() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	TabularExpression() ITabularExpressionContext
	RPAREN() antlr.TerminalNode

	// IsToScalarExpressionContext differentiates from other interfaces.
	IsToScalarExpressionContext()
}

type ToScalarExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyToScalarExpressionContext() *ToScalarExpressionContext {
	var p = new(ToScalarExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_toScalarExpression
	return p
}

func InitEmptyToScalarExpressionContext(p *ToScalarExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_toScalarExpression
}

func (*ToScalarExpressionContext) IsToScalarExpressionContext() {}

func NewToScalarExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ToScalarExpressionContext {
	var p = new(ToScalarExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_toScalarExpression

	return p
}

func (s *ToScalarExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ToScalarExpressionContext) TOSCALAR() antlr.TerminalNode {
	return s.GetToken(KQLParserTOSCALAR, 0)
}

func (s *ToScalarExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *ToScalarExpressionContext) TabularExpression() ITabularExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabularExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabularExpressionContext)
}

func (s *ToScalarExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *ToScalarExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ToScalarExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ToScalarExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterToScalarExpression(s)
	}
}

func (s *ToScalarExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitToScalarExpression(s)
	}
}

func (s *ToScalarExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitToScalarExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ToScalarExpression() (localctx IToScalarExpressionContext) {
	localctx = NewToScalarExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, KQLParserRULE_toScalarExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1738)
		p.Match(KQLParserTOSCALAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1739)
		p.Match(KQLParserLPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1740)
		p.TabularExpression()
	}
	{
		p.SetState(1741)
		p.Match(KQLParserRPAREN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayExpressionContext is an interface to support dynamic dispatch.
type IArrayExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PACK_ARRAY() antlr.TerminalNode
	LPAREN() antlr.TerminalNode
	RPAREN() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	LBRACKET() antlr.TerminalNode
	RBRACKET() antlr.TerminalNode

	// IsArrayExpressionContext differentiates from other interfaces.
	IsArrayExpressionContext()
}

type ArrayExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayExpressionContext() *ArrayExpressionContext {
	var p = new(ArrayExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_arrayExpression
	return p
}

func InitEmptyArrayExpressionContext(p *ArrayExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_arrayExpression
}

func (*ArrayExpressionContext) IsArrayExpressionContext() {}

func NewArrayExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayExpressionContext {
	var p = new(ArrayExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_arrayExpression

	return p
}

func (s *ArrayExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayExpressionContext) PACK_ARRAY() antlr.TerminalNode {
	return s.GetToken(KQLParserPACK_ARRAY, 0)
}

func (s *ArrayExpressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserLPAREN, 0)
}

func (s *ArrayExpressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(KQLParserRPAREN, 0)
}

func (s *ArrayExpressionContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArrayExpressionContext) LBRACKET() antlr.TerminalNode {
	return s.GetToken(KQLParserLBRACKET, 0)
}

func (s *ArrayExpressionContext) RBRACKET() antlr.TerminalNode {
	return s.GetToken(KQLParserRBRACKET, 0)
}

func (s *ArrayExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterArrayExpression(s)
	}
}

func (s *ArrayExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitArrayExpression(s)
	}
}

func (s *ArrayExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitArrayExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ArrayExpression() (localctx IArrayExpressionContext) {
	localctx = NewArrayExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, KQLParserRULE_arrayExpression)
	var _la int

	p.SetState(1754)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KQLParserPACK_ARRAY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1743)
			p.Match(KQLParserPACK_ARRAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1744)
			p.Match(KQLParserLPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1722596028691838186) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2017612633061998593) != 0) || ((int64((_la-136)) & ^0x3f) == 0 && ((int64(1)<<(_la-136))&-137430566699) != 0) || ((int64((_la-200)) & ^0x3f) == 0 && ((int64(1)<<(_la-200))&255) != 0) {
			{
				p.SetState(1745)
				p.ExpressionList()
			}

		}
		{
			p.SetState(1748)
			p.Match(KQLParserRPAREN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserLBRACKET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1749)
			p.Match(KQLParserLBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1751)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1722596028691838186) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2017612633061998593) != 0) || ((int64((_la-136)) & ^0x3f) == 0 && ((int64(1)<<(_la-136))&-137430566699) != 0) || ((int64((_la-200)) & ^0x3f) == 0 && ((int64(1)<<(_la-200))&255) != 0) {
			{
				p.SetState(1750)
				p.ExpressionList()
			}

		}
		{
			p.SetState(1753)
			p.Match(KQLParserRBRACKET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectExpressionContext is an interface to support dynamic dispatch.
type IObjectExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LBRACE() antlr.TerminalNode
	RBRACE() antlr.TerminalNode
	ObjectPropertyList() IObjectPropertyListContext

	// IsObjectExpressionContext differentiates from other interfaces.
	IsObjectExpressionContext()
}

type ObjectExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectExpressionContext() *ObjectExpressionContext {
	var p = new(ObjectExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_objectExpression
	return p
}

func InitEmptyObjectExpressionContext(p *ObjectExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_objectExpression
}

func (*ObjectExpressionContext) IsObjectExpressionContext() {}

func NewObjectExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectExpressionContext {
	var p = new(ObjectExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_objectExpression

	return p
}

func (s *ObjectExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectExpressionContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(KQLParserLBRACE, 0)
}

func (s *ObjectExpressionContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(KQLParserRBRACE, 0)
}

func (s *ObjectExpressionContext) ObjectPropertyList() IObjectPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectPropertyListContext)
}

func (s *ObjectExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterObjectExpression(s)
	}
}

func (s *ObjectExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitObjectExpression(s)
	}
}

func (s *ObjectExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitObjectExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ObjectExpression() (localctx IObjectExpressionContext) {
	localctx = NewObjectExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, KQLParserRULE_objectExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1756)
		p.Match(KQLParserLBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1758)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-1722596028691838186) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2017612633061998593) != 0) || ((int64((_la-136)) & ^0x3f) == 0 && ((int64(1)<<(_la-136))&-137430566699) != 0) || ((int64((_la-200)) & ^0x3f) == 0 && ((int64(1)<<(_la-200))&255) != 0) {
		{
			p.SetState(1757)
			p.ObjectPropertyList()
		}

	}
	{
		p.SetState(1760)
		p.Match(KQLParserRBRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectPropertyListContext is an interface to support dynamic dispatch.
type IObjectPropertyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllObjectProperty() []IObjectPropertyContext
	ObjectProperty(i int) IObjectPropertyContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsObjectPropertyListContext differentiates from other interfaces.
	IsObjectPropertyListContext()
}

type ObjectPropertyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectPropertyListContext() *ObjectPropertyListContext {
	var p = new(ObjectPropertyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_objectPropertyList
	return p
}

func InitEmptyObjectPropertyListContext(p *ObjectPropertyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_objectPropertyList
}

func (*ObjectPropertyListContext) IsObjectPropertyListContext() {}

func NewObjectPropertyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectPropertyListContext {
	var p = new(ObjectPropertyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_objectPropertyList

	return p
}

func (s *ObjectPropertyListContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectPropertyListContext) AllObjectProperty() []IObjectPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectPropertyContext); ok {
			len++
		}
	}

	tst := make([]IObjectPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectPropertyContext); ok {
			tst[i] = t.(IObjectPropertyContext)
			i++
		}
	}

	return tst
}

func (s *ObjectPropertyListContext) ObjectProperty(i int) IObjectPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectPropertyContext)
}

func (s *ObjectPropertyListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *ObjectPropertyListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *ObjectPropertyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectPropertyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectPropertyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterObjectPropertyList(s)
	}
}

func (s *ObjectPropertyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitObjectPropertyList(s)
	}
}

func (s *ObjectPropertyListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitObjectPropertyList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ObjectPropertyList() (localctx IObjectPropertyListContext) {
	localctx = NewObjectPropertyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, KQLParserRULE_objectPropertyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1762)
		p.ObjectProperty()
	}
	p.SetState(1767)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(1763)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1764)
			p.ObjectProperty()
		}

		p.SetState(1769)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IObjectPropertyContext is an interface to support dynamic dispatch.
type IObjectPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	COLON() antlr.TerminalNode
	Identifier() IIdentifierContext
	STRING_LITERAL() antlr.TerminalNode

	// IsObjectPropertyContext differentiates from other interfaces.
	IsObjectPropertyContext()
}

type ObjectPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectPropertyContext() *ObjectPropertyContext {
	var p = new(ObjectPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_objectProperty
	return p
}

func InitEmptyObjectPropertyContext(p *ObjectPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_objectProperty
}

func (*ObjectPropertyContext) IsObjectPropertyContext() {}

func NewObjectPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectPropertyContext {
	var p = new(ObjectPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_objectProperty

	return p
}

func (s *ObjectPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectPropertyContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ObjectPropertyContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ObjectPropertyContext) COLON() antlr.TerminalNode {
	return s.GetToken(KQLParserCOLON, 0)
}

func (s *ObjectPropertyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ObjectPropertyContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(KQLParserSTRING_LITERAL, 0)
}

func (s *ObjectPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterObjectProperty(s)
	}
}

func (s *ObjectPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitObjectProperty(s)
	}
}

func (s *ObjectPropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitObjectProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ObjectProperty() (localctx IObjectPropertyContext) {
	localctx = NewObjectPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, KQLParserRULE_objectProperty)
	p.SetState(1781)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1770)
			p.Expression()
		}
		{
			p.SetState(1771)
			p.Match(KQLParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1772)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1774)
			p.Identifier()
		}
		{
			p.SetState(1775)
			p.Match(KQLParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1776)
			p.Expression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1778)
			p.Match(KQLParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1779)
			p.Match(KQLParserCOLON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1780)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionParametersContext is an interface to support dynamic dispatch.
type IFunctionParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFunctionParameter() []IFunctionParameterContext
	FunctionParameter(i int) IFunctionParameterContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsFunctionParametersContext differentiates from other interfaces.
	IsFunctionParametersContext()
}

type FunctionParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionParametersContext() *FunctionParametersContext {
	var p = new(FunctionParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_functionParameters
	return p
}

func InitEmptyFunctionParametersContext(p *FunctionParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_functionParameters
}

func (*FunctionParametersContext) IsFunctionParametersContext() {}

func NewFunctionParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionParametersContext {
	var p = new(FunctionParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_functionParameters

	return p
}

func (s *FunctionParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionParametersContext) AllFunctionParameter() []IFunctionParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionParameterContext); ok {
			len++
		}
	}

	tst := make([]IFunctionParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionParameterContext); ok {
			tst[i] = t.(IFunctionParameterContext)
			i++
		}
	}

	return tst
}

func (s *FunctionParametersContext) FunctionParameter(i int) IFunctionParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionParameterContext)
}

func (s *FunctionParametersContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *FunctionParametersContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *FunctionParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterFunctionParameters(s)
	}
}

func (s *FunctionParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitFunctionParameters(s)
	}
}

func (s *FunctionParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitFunctionParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) FunctionParameters() (localctx IFunctionParametersContext) {
	localctx = NewFunctionParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, KQLParserRULE_functionParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1783)
		p.FunctionParameter()
	}
	p.SetState(1788)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(1784)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1785)
			p.FunctionParameter()
		}

		p.SetState(1790)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionParameterContext is an interface to support dynamic dispatch.
type IFunctionParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	COLON() antlr.TerminalNode
	TypeSpecifier() ITypeSpecifierContext
	ASSIGN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsFunctionParameterContext differentiates from other interfaces.
	IsFunctionParameterContext()
}

type FunctionParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionParameterContext() *FunctionParameterContext {
	var p = new(FunctionParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_functionParameter
	return p
}

func InitEmptyFunctionParameterContext(p *FunctionParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_functionParameter
}

func (*FunctionParameterContext) IsFunctionParameterContext() {}

func NewFunctionParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionParameterContext {
	var p = new(FunctionParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_functionParameter

	return p
}

func (s *FunctionParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionParameterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(KQLParserCOLON, 0)
}

func (s *FunctionParameterContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *FunctionParameterContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(KQLParserASSIGN, 0)
}

func (s *FunctionParameterContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterFunctionParameter(s)
	}
}

func (s *FunctionParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitFunctionParameter(s)
	}
}

func (s *FunctionParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitFunctionParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) FunctionParameter() (localctx IFunctionParameterContext) {
	localctx = NewFunctionParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, KQLParserRULE_functionParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1791)
		p.Identifier()
	}
	{
		p.SetState(1792)
		p.Match(KQLParserCOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1793)
		p.TypeSpecifier()
	}
	p.SetState(1796)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == KQLParserASSIGN {
		{
			p.SetState(1794)
			p.Match(KQLParserASSIGN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1795)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeSpecifierContext is an interface to support dynamic dispatch.
type ITypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE_BOOL() antlr.TerminalNode
	TYPE_DATETIME() antlr.TerminalNode
	TYPE_DECIMAL() antlr.TerminalNode
	TYPE_DOUBLE() antlr.TerminalNode
	TYPE_DYNAMIC() antlr.TerminalNode
	TYPE_GUID() antlr.TerminalNode
	TYPE_INT() antlr.TerminalNode
	TYPE_LONG() antlr.TerminalNode
	TYPE_REAL() antlr.TerminalNode
	TYPE_STRING() antlr.TerminalNode
	TYPE_TIMESPAN() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsTypeSpecifierContext differentiates from other interfaces.
	IsTypeSpecifierContext()
}

type TypeSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSpecifierContext() *TypeSpecifierContext {
	var p = new(TypeSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_typeSpecifier
	return p
}

func InitEmptyTypeSpecifierContext(p *TypeSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_typeSpecifier
}

func (*TypeSpecifierContext) IsTypeSpecifierContext() {}

func NewTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSpecifierContext {
	var p = new(TypeSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_typeSpecifier

	return p
}

func (s *TypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSpecifierContext) TYPE_BOOL() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_BOOL, 0)
}

func (s *TypeSpecifierContext) TYPE_DATETIME() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_DATETIME, 0)
}

func (s *TypeSpecifierContext) TYPE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_DECIMAL, 0)
}

func (s *TypeSpecifierContext) TYPE_DOUBLE() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_DOUBLE, 0)
}

func (s *TypeSpecifierContext) TYPE_DYNAMIC() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_DYNAMIC, 0)
}

func (s *TypeSpecifierContext) TYPE_GUID() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_GUID, 0)
}

func (s *TypeSpecifierContext) TYPE_INT() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_INT, 0)
}

func (s *TypeSpecifierContext) TYPE_LONG() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_LONG, 0)
}

func (s *TypeSpecifierContext) TYPE_REAL() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_REAL, 0)
}

func (s *TypeSpecifierContext) TYPE_STRING() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_STRING, 0)
}

func (s *TypeSpecifierContext) TYPE_TIMESPAN() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_TIMESPAN, 0)
}

func (s *TypeSpecifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterTypeSpecifier(s)
	}
}

func (s *TypeSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitTypeSpecifier(s)
	}
}

func (s *TypeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitTypeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) TypeSpecifier() (localctx ITypeSpecifierContext) {
	localctx = NewTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, KQLParserRULE_typeSpecifier)
	p.SetState(1810)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 168, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1798)
			p.Match(KQLParserTYPE_BOOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1799)
			p.Match(KQLParserTYPE_DATETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1800)
			p.Match(KQLParserTYPE_DECIMAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1801)
			p.Match(KQLParserTYPE_DOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1802)
			p.Match(KQLParserTYPE_DYNAMIC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1803)
			p.Match(KQLParserTYPE_GUID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1804)
			p.Match(KQLParserTYPE_INT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1805)
			p.Match(KQLParserTYPE_LONG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1806)
			p.Match(KQLParserTYPE_REAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1807)
			p.Match(KQLParserTYPE_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1808)
			p.Match(KQLParserTYPE_TIMESPAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1809)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING_LITERAL() antlr.TerminalNode
	VERBATIM_STRING() antlr.TerminalNode
	MULTILINE_STRING() antlr.TerminalNode
	INT_NUMBER() antlr.TerminalNode
	LONG_NUMBER() antlr.TerminalNode
	REAL_NUMBER() antlr.TerminalNode
	DECIMAL_NUMBER() antlr.TerminalNode
	HEX_NUMBER() antlr.TerminalNode
	BooleanLiteral() IBooleanLiteralContext
	NULL() antlr.TerminalNode
	DATETIME_LITERAL() antlr.TerminalNode
	TIMESPAN_LITERAL() antlr.TerminalNode
	TIMESPAN_SHORT() antlr.TerminalNode
	GUID_LITERAL() antlr.TerminalNode
	DYNAMIC_LITERAL() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(KQLParserSTRING_LITERAL, 0)
}

func (s *LiteralContext) VERBATIM_STRING() antlr.TerminalNode {
	return s.GetToken(KQLParserVERBATIM_STRING, 0)
}

func (s *LiteralContext) MULTILINE_STRING() antlr.TerminalNode {
	return s.GetToken(KQLParserMULTILINE_STRING, 0)
}

func (s *LiteralContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(KQLParserINT_NUMBER, 0)
}

func (s *LiteralContext) LONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(KQLParserLONG_NUMBER, 0)
}

func (s *LiteralContext) REAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(KQLParserREAL_NUMBER, 0)
}

func (s *LiteralContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(KQLParserDECIMAL_NUMBER, 0)
}

func (s *LiteralContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(KQLParserHEX_NUMBER, 0)
}

func (s *LiteralContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *LiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(KQLParserNULL, 0)
}

func (s *LiteralContext) DATETIME_LITERAL() antlr.TerminalNode {
	return s.GetToken(KQLParserDATETIME_LITERAL, 0)
}

func (s *LiteralContext) TIMESPAN_LITERAL() antlr.TerminalNode {
	return s.GetToken(KQLParserTIMESPAN_LITERAL, 0)
}

func (s *LiteralContext) TIMESPAN_SHORT() antlr.TerminalNode {
	return s.GetToken(KQLParserTIMESPAN_SHORT, 0)
}

func (s *LiteralContext) GUID_LITERAL() antlr.TerminalNode {
	return s.GetToken(KQLParserGUID_LITERAL, 0)
}

func (s *LiteralContext) DYNAMIC_LITERAL() antlr.TerminalNode {
	return s.GetToken(KQLParserDYNAMIC_LITERAL, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, KQLParserRULE_literal)
	p.SetState(1827)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case KQLParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1812)
			p.Match(KQLParserSTRING_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserVERBATIM_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1813)
			p.Match(KQLParserVERBATIM_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserMULTILINE_STRING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1814)
			p.Match(KQLParserMULTILINE_STRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserINT_NUMBER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1815)
			p.Match(KQLParserINT_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserLONG_NUMBER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1816)
			p.Match(KQLParserLONG_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserREAL_NUMBER:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1817)
			p.Match(KQLParserREAL_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserDECIMAL_NUMBER:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1818)
			p.Match(KQLParserDECIMAL_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserHEX_NUMBER:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1819)
			p.Match(KQLParserHEX_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserTRUE, KQLParserFALSE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1820)
			p.BooleanLiteral()
		}

	case KQLParserNULL:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1821)
			p.Match(KQLParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserDATETIME_LITERAL:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1822)
			p.Match(KQLParserDATETIME_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserTIMESPAN_LITERAL:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1823)
			p.Match(KQLParserTIMESPAN_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserTIMESPAN_SHORT:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1824)
			p.Match(KQLParserTIMESPAN_SHORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserGUID_LITERAL:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1825)
			p.Match(KQLParserGUID_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case KQLParserDYNAMIC_LITERAL:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1826)
			p.Match(KQLParserDYNAMIC_LITERAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_booleanLiteral
	return p
}

func InitEmptyBooleanLiteralContext(p *BooleanLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_booleanLiteral
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(KQLParserTRUE, 0)
}

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(KQLParserFALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, KQLParserRULE_booleanLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1829)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KQLParserTRUE || _la == KQLParserFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	PROJECT() antlr.TerminalNode
	EXTEND() antlr.TerminalNode
	SUMMARIZE() antlr.TerminalNode
	SORT() antlr.TerminalNode
	TOP() antlr.TerminalNode
	TAKE() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	UNION() antlr.TerminalNode
	LOOKUP() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	DISTINCT() antlr.TerminalNode
	SEARCH() antlr.TerminalNode
	PARSE() antlr.TerminalNode
	EVALUATE() antlr.TerminalNode
	RENDER() antlr.TerminalNode
	LET() antlr.TerminalNode
	SET() antlr.TerminalNode
	AS() antlr.TerminalNode
	BY() antlr.TerminalNode
	ON() antlr.TerminalNode
	WITH() antlr.TerminalNode
	OF() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	STEP() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	PRINT() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	INNER() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode
	TYPE_STRING() antlr.TerminalNode
	TYPE_INT() antlr.TerminalNode
	TYPE_LONG() antlr.TerminalNode
	TYPE_BOOL() antlr.TerminalNode
	TYPE_DATETIME() antlr.TerminalNode
	TYPE_TIMESPAN() antlr.TerminalNode
	TYPE_DYNAMIC() antlr.TerminalNode
	TYPE_REAL() antlr.TerminalNode
	TYPE_DOUBLE() antlr.TerminalNode
	TYPE_DECIMAL() antlr.TerminalNode
	TYPE_GUID() antlr.TerminalNode
	KIND() antlr.TerminalNode
	FROM() antlr.TerminalNode
	TO() antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KQLParserIDENTIFIER, 0)
}

func (s *IdentifierContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KQLParserWHERE, 0)
}

func (s *IdentifierContext) PROJECT() antlr.TerminalNode {
	return s.GetToken(KQLParserPROJECT, 0)
}

func (s *IdentifierContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(KQLParserEXTEND, 0)
}

func (s *IdentifierContext) SUMMARIZE() antlr.TerminalNode {
	return s.GetToken(KQLParserSUMMARIZE, 0)
}

func (s *IdentifierContext) SORT() antlr.TerminalNode {
	return s.GetToken(KQLParserSORT, 0)
}

func (s *IdentifierContext) TOP() antlr.TerminalNode {
	return s.GetToken(KQLParserTOP, 0)
}

func (s *IdentifierContext) TAKE() antlr.TerminalNode {
	return s.GetToken(KQLParserTAKE, 0)
}

func (s *IdentifierContext) JOIN() antlr.TerminalNode {
	return s.GetToken(KQLParserJOIN, 0)
}

func (s *IdentifierContext) UNION() antlr.TerminalNode {
	return s.GetToken(KQLParserUNION, 0)
}

func (s *IdentifierContext) LOOKUP() antlr.TerminalNode {
	return s.GetToken(KQLParserLOOKUP, 0)
}

func (s *IdentifierContext) COUNT() antlr.TerminalNode {
	return s.GetToken(KQLParserCOUNT, 0)
}

func (s *IdentifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(KQLParserDISTINCT, 0)
}

func (s *IdentifierContext) SEARCH() antlr.TerminalNode {
	return s.GetToken(KQLParserSEARCH, 0)
}

func (s *IdentifierContext) PARSE() antlr.TerminalNode {
	return s.GetToken(KQLParserPARSE, 0)
}

func (s *IdentifierContext) EVALUATE() antlr.TerminalNode {
	return s.GetToken(KQLParserEVALUATE, 0)
}

func (s *IdentifierContext) RENDER() antlr.TerminalNode {
	return s.GetToken(KQLParserRENDER, 0)
}

func (s *IdentifierContext) LET() antlr.TerminalNode {
	return s.GetToken(KQLParserLET, 0)
}

func (s *IdentifierContext) SET() antlr.TerminalNode {
	return s.GetToken(KQLParserSET, 0)
}

func (s *IdentifierContext) AS() antlr.TerminalNode {
	return s.GetToken(KQLParserAS, 0)
}

func (s *IdentifierContext) BY() antlr.TerminalNode {
	return s.GetToken(KQLParserBY, 0)
}

func (s *IdentifierContext) ON() antlr.TerminalNode {
	return s.GetToken(KQLParserON, 0)
}

func (s *IdentifierContext) WITH() antlr.TerminalNode {
	return s.GetToken(KQLParserWITH, 0)
}

func (s *IdentifierContext) OF() antlr.TerminalNode {
	return s.GetToken(KQLParserOF, 0)
}

func (s *IdentifierContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(KQLParserDEFAULT, 0)
}

func (s *IdentifierContext) STEP() antlr.TerminalNode {
	return s.GetToken(KQLParserSTEP, 0)
}

func (s *IdentifierContext) RANGE() antlr.TerminalNode {
	return s.GetToken(KQLParserRANGE, 0)
}

func (s *IdentifierContext) PRINT() antlr.TerminalNode {
	return s.GetToken(KQLParserPRINT, 0)
}

func (s *IdentifierContext) ASC() antlr.TerminalNode {
	return s.GetToken(KQLParserASC, 0)
}

func (s *IdentifierContext) DESC() antlr.TerminalNode {
	return s.GetToken(KQLParserDESC, 0)
}

func (s *IdentifierContext) INNER() antlr.TerminalNode {
	return s.GetToken(KQLParserINNER, 0)
}

func (s *IdentifierContext) OUTER() antlr.TerminalNode {
	return s.GetToken(KQLParserOUTER, 0)
}

func (s *IdentifierContext) LEFT() antlr.TerminalNode {
	return s.GetToken(KQLParserLEFT, 0)
}

func (s *IdentifierContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(KQLParserRIGHT, 0)
}

func (s *IdentifierContext) TRUE() antlr.TerminalNode {
	return s.GetToken(KQLParserTRUE, 0)
}

func (s *IdentifierContext) FALSE() antlr.TerminalNode {
	return s.GetToken(KQLParserFALSE, 0)
}

func (s *IdentifierContext) TYPE_STRING() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_STRING, 0)
}

func (s *IdentifierContext) TYPE_INT() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_INT, 0)
}

func (s *IdentifierContext) TYPE_LONG() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_LONG, 0)
}

func (s *IdentifierContext) TYPE_BOOL() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_BOOL, 0)
}

func (s *IdentifierContext) TYPE_DATETIME() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_DATETIME, 0)
}

func (s *IdentifierContext) TYPE_TIMESPAN() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_TIMESPAN, 0)
}

func (s *IdentifierContext) TYPE_DYNAMIC() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_DYNAMIC, 0)
}

func (s *IdentifierContext) TYPE_REAL() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_REAL, 0)
}

func (s *IdentifierContext) TYPE_DOUBLE() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_DOUBLE, 0)
}

func (s *IdentifierContext) TYPE_DECIMAL() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_DECIMAL, 0)
}

func (s *IdentifierContext) TYPE_GUID() antlr.TerminalNode {
	return s.GetToken(KQLParserTYPE_GUID, 0)
}

func (s *IdentifierContext) KIND() antlr.TerminalNode {
	return s.GetToken(KQLParserKIND, 0)
}

func (s *IdentifierContext) FROM() antlr.TerminalNode {
	return s.GetToken(KQLParserFROM, 0)
}

func (s *IdentifierContext) TO() antlr.TerminalNode {
	return s.GetToken(KQLParserTO, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, KQLParserRULE_identifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1831)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-1)) & ^0x3f) == 0 && ((int64(1)<<(_la-1))&-861298014345919093) != 0) || ((int64((_la-142)) & ^0x3f) == 0 && ((int64(1)<<(_la-142))&-9187360625863417885) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *IdentifierListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, KQLParserRULE_identifierList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1833)
		p.Identifier()
	}
	p.SetState(1838)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(1834)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1835)
			p.Identifier()
		}

		p.SetState(1840)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllCOMMA() []antlr.TerminalNode
	COMMA(i int) antlr.TerminalNode

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = KQLParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = KQLParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(KQLParserCOMMA)
}

func (s *ExpressionListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(KQLParserCOMMA, i)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KQLParserListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case KQLParserVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *KQLParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, KQLParserRULE_expressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1841)
		p.Expression()
	}
	p.SetState(1846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == KQLParserCOMMA {
		{
			p.SetState(1842)
			p.Match(KQLParserCOMMA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1843)
			p.Expression()
		}

		p.SetState(1848)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
